<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-12-28T03:38:52Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions</id>
		<title>Entity Framework conventions</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions" />
		<updated>2022-12-28T00:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework comes out of the box with a number of default &lt;em&gt;conventions&lt;/em&gt; - however &lt;code&gt;new conventions can easily be added&lt;/code&gt; to an application specific EF configuration to customize how Entity Framework operates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;By default, when a &lt;code&gt;string&lt;/code&gt; property on an entity is mapped to a SQL database column, it will be generated as &lt;code&gt;nvarchar(max)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the DbContext configuration, some additional logging for demo purposes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=ConfigConventions;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

        // enable additional logging for demo purposes
        optionsBuilder.EnableSensitiveDataLogging(true);
        optionsBuilder.LogTo((string query) =&amp;gt;
        {
            Console.WriteLine(query);
        }, LogLevel.Information);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;CREATE TABLE SQL&lt;/em&gt; generated is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(max) NOT NULL,
    [Description] nvarchar(max) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the default for C# properties of type &lt;code&gt;string&lt;/code&gt; is &lt;code&gt;nvarchar(max)&lt;/code&gt; - next we'll go through the various steps to change the convention for &lt;em&gt;non-explicitly set string&lt;/em&gt; properties from &lt;code&gt;nvarchar(max)&lt;/code&gt; to &lt;code&gt;nvarchar(256)&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-definition"&gt;Convention definition&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;em&gt;convention&lt;/em&gt; to change the default string length. This is achieved by implementing the &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; interface (which inherits the &lt;code&gt;IConvention&lt;/code&gt; interface). The &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; implementations, as the name suggests, are executed once the model has mostly been built (using the built-in and other custom conventions), and is being &lt;em&gt;finalized&lt;/em&gt;. This is the &amp;quot;safest&amp;quot; time to execute custom conventions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MaxStringLengthConvention : IModelFinalizingConvention
{
    private readonly int _maxLength;

    public MaxStringLengthConvention(int maxLength)
	{
        this._maxLength = maxLength;
    }

    // implement the only method on the interface
    public void ProcessModelFinalizing(IConventionModelBuilder modelBuilder, 
        IConventionContext&amp;lt;IConventionModelBuilder&amp;gt; context)
    {
        // iterate through each type defined in the EF model
        // and through each property and check if a string
        foreach (var property in modelBuilder.Metadata.GetEntityTypes()
                     .SelectMany(entityType =&amp;gt; entityType.GetDeclaredProperties()
                                    .Where( property =&amp;gt; property.ClrType == typeof(string))))
        {
            // set the max length based on the value passed in
            property.Builder.HasMaxLength(_maxLength);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The implementation for this convention effectively checks &lt;em&gt;each type&lt;/em&gt; and &lt;em&gt;each property&lt;/em&gt; on the type to see if it is of type &lt;em&gt;string&lt;/em&gt; - if so, the max length is set based on the max length specified on initialization.&lt;/p&gt;
&lt;p&gt;Now to register the newly created convention!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-configuration"&gt;Convention configuration&lt;/h3&gt;
&lt;p&gt;The convention is required to be registered with Entity Framework - so EF knows to apply the convention to the model (adn when to apply it)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ConfigureConventions&lt;/code&gt; method is &lt;em&gt;overridden&lt;/em&gt; on the &lt;em&gt;DbContext&lt;/em&gt;, and the convention(s) registered:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    configurationBuilder.Conventions.Add(_ =&amp;gt; new MaxStringLengthConvention(256));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;With the convention configured, the SQL generated now looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(256) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All string properties/columns are set to have a length of 256 by default.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="explicitly-set-properties"&gt;Explicitly set properties&lt;/h3&gt;
&lt;p&gt;Entity Framework is smart enough to know that if the &lt;em&gt;max length&lt;/em&gt; has explicitly been set on a property/column, then the default length set by the convention will &lt;code&gt;not be applied&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the &lt;em&gt;Title&lt;/em&gt; property on the &lt;em&gt;Blog&lt;/em&gt; was set to have a max length of 500:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    [MaxLength(500)]
    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(500) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An explicitly defined max length on a property, takes precedence over the max length specified by the convention.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While all of the above could have been achieved by overwriting the &lt;code&gt;OnModelCreating&lt;/code&gt; method on the &lt;em&gt;DbContext&lt;/em&gt;, the conventions approach is more flexible and reusable. The conventions can be packaged and shared across teams in an enterprise to ensure consistent database standards.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=6apfe1L1FhY&amp;amp;t=2041s"&gt;.NET Data Community Standup - EF7 Custom Model Conventions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;224: 16-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/p/2022-12-holiday</id>
		<title>Holiday Break 2022</title>
		<link href="https://alwaysdeveloping.net/p/2022-12-holiday" />
		<updated>2022-12-16T01:00:00Z</updated>
		<content>&lt;h2 id="until-next-year"&gt;Until next year&lt;/h2&gt;
&lt;p&gt;Today will be the final Daily Drop post for 2022 - alwaysdeveloping.net is taking a break until the begining of January. The learning and growing will continue, just not the posts. Until next year!&lt;/p&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection</id>
		<title>.NET8 Frozen collection</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection" />
		<updated>2022-12-15T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET8 &lt;em&gt;potentially&lt;/em&gt; introduces a new collection type called a &lt;code&gt;Frozen collection&lt;/code&gt; - this post will explore the new collection, and see how to compares to existing collection implementations.&lt;/p&gt;
&lt;p&gt;As .NET8 is still currently in alpha, the &lt;code&gt;Frozen collection&lt;/code&gt; as well as any specific functionality it may offer could change before the final release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;To see how the &lt;code&gt;Frozen collection&lt;/code&gt; operates, below it is used along with other common collection implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create a base list of 10 items
List&amp;lt;int&amp;gt; baseList = Enumerable
    .Range(1, 10).ToList();

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

// now add another item to the list
baseList.Add(11);

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 11
ReadOnlyList count: 11
FrozenSet count: 10
ImmutableList count: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see, that when &lt;em&gt;adding an item to the underlying list&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;ReadOnlyList&lt;/code&gt; count also increases, as it is a readonly view into the underlying list&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt; count is &lt;em&gt;not increased&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what's the difference between the &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt;?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="set-vs-list"&gt;Set vs List&lt;/h2&gt;
&lt;p&gt;As per their name, the &lt;code&gt;FrozenSet&lt;/code&gt; is a &lt;em&gt;set&lt;/em&gt;, while the &lt;code&gt;ImmutableList&lt;/code&gt; is a &lt;em&gt;list&lt;/em&gt; - &lt;code&gt;a set cannot contain duplicates and is unordered&lt;/code&gt;, unlike a list. Consider the following code, similar to the previous example, but now with duplicate items:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
List&amp;lt;int&amp;gt; baseList = Enumerable.Range(1, 10)
    .ToList();
// add duplicate items to the base list
baseList.Add(1);
baseList.Add(2);
baseList.Add(3);

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 13
ReadOnlyList count: 13
FrozenSet count: 10
ImmutableList count: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 3 duplicate items are automatically removed when converting the base list to a set.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="another-collection-type"&gt;Another collection type&lt;/h2&gt;
&lt;p&gt;So why the need for another specialized collection type - &lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Steven Giesel&lt;/a&gt; benchmark's the performance of the &lt;code&gt;FrozenSet&lt;/code&gt; against other collection types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is substantially &lt;em&gt;quicker&lt;/em&gt; vs the other types when &lt;em&gt;performing a lookup&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;it is however &lt;em&gt;slower&lt;/em&gt; when creating the set vs creating the other types&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A new specialized collection type, which might not see every day use by the majority, but which, with the right use case, can improve the performance of the code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Frozen collections in .NET 8&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;223: 15-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query</id>
		<title>New HTTP methods</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query" />
		<updated>2022-12-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Standards have been published for a new HTTP method, &lt;code&gt;QUERY&lt;/code&gt;, which aims to effectively be a merge between the GET and POST methods.&lt;/p&gt;
&lt;p&gt;While this post will focus on handling the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, the same configuration and logic could be applied to any custom HTTP method (although not advised)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-need-for-query"&gt;The need for QUERY&lt;/h2&gt;
&lt;p&gt;First, a quick word on the need for the QUERY method. When using the GET method, all information to be passed to the server is contained in the URL as a &lt;em&gt;GET method does not have a body&lt;/em&gt;. The problem is that URL's have a finite length and when this limit is reached, often developers will switch to using a POST method which allows for more complex and lengthy information to be &lt;em&gt;passed in the body&lt;/em&gt;.
While this technique will work, the two different methods will generally have different caching mechanisms and a POST method may not offer the same performance as a GET method.&lt;/p&gt;
&lt;p&gt;The QUERY method aims to address this, by effectively providing a method which operates like the &amp;quot;GET&amp;quot; method, but which allows for a body to be posted to the server.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="defining-the-endpoint"&gt;Defining the endpoint&lt;/h2&gt;
&lt;p&gt;Defining an endpoint which uses a custom or new HTTP method is surprisingly easy - the &lt;code&gt;MapMethods&lt;/code&gt; method can be used, with a list of &lt;em&gt;httpMethods&lt;/em&gt; the endpoint supports:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define an endpoint with QUERY http method
app.MapMethods(&amp;quot;/query&amp;quot;, new[] { &amp;quot;QUERY&amp;quot; }, async (HttpContext context) =&amp;gt;
{
    string? text = null;
    var request = context.Request;

    // the body has to be read manually
    if (!request.Body.CanSeek)
    {
        request.EnableBuffering();
    }

    if (request.Body.CanRead)
    {
        // read the body as a stream, and then set the
        // reader position back to the start
        request.Body.Position = 0;
        var reader = new StreamReader(request.Body, Encoding.UTF8);
        text = await reader.ReadToEndAsync();
        request.Body.Position = 0;
    }

    // return the body
    return Results.Ok($&amp;quot;Querying data using body: {text}&amp;quot;);

})
// give the endpoint a name, just making it easier to 
// find later. Not required
.WithName(&amp;quot;query&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an endpoint &lt;code&gt;/query&lt;/code&gt; is defined, which uses the HTTP method &lt;code&gt;QUERY&lt;/code&gt;. The endpoint will read the contents of the body supplied with the HTTP request, and return it back to the caller.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;WithName&lt;/em&gt; method is used to name the endpoint, which will be used in the next step to easily build up the URL to be invoked - this is not strictly required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="calling-the-endpoint"&gt;Calling the endpoint&lt;/h2&gt;
&lt;p&gt;Calling the endpoint is a &lt;em&gt;little&lt;/em&gt; tricker, as the typical tools one might use (e.g. Postman) will not support the new or custom HTTP method. In this example, the C# HttpClient will be used to call the &lt;code&gt;QUERY&lt;/code&gt; endpoint - we are going to &lt;em&gt;create a GET endpoint, which will call the QUERY endpoint&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/callquery&amp;quot;, async (HttpContext context, 
    LinkGenerator generator) =&amp;gt;
{
    var client = new HttpClient();

    // set the http method as QUERY
    var request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;QUERY&amp;quot;),
        // get the URL by the name specified
        generator.GetUriByName(context, &amp;quot;query&amp;quot;, null)
    );

    // set the body of the QUERY call
    request.Content = new StringContent(&amp;quot;This is a body of a QUERY call&amp;quot;, 
        Encoding.UTF8, &amp;quot;text/plain&amp;quot;);

    // call the QUERY endpoint
    var response = client.Send(request);
    var result = await response.Content.ReadAsStringAsync();

    // the expected result should be the same 
    // as the body specified
    return result;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the &lt;code&gt;/callquery&lt;/code&gt; endpoint yields the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;&amp;quot;Querying data using body: This is a body of a QUERY call&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Success! We have successfully defined an endpoint which uses the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, which was successfully invoked with a body supplied.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="simplifying-the-code"&gt;Simplifying the code&lt;/h2&gt;
&lt;p&gt;The above is a very rough implementation of the &lt;code&gt;QUERY&lt;/code&gt; (or any custom HTTP method) implementation - in &lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Khalid Abuhakmeh's post&lt;/a&gt;, he has some good ways to simplify the code, and make it more generic. I suggest having a look at the techniques mentioned in his post on how to streamline the code for reuse.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful &lt;em&gt;experiment&lt;/em&gt; to see how support for any HTTP method support can be added relatively easily. There are limitation of custom HTTP methods - including the above mention support from 3rd party applications (Postman) as well as libraries (Swashbuckle), as well as limited or no support from caching or load balancing mechanisms.&lt;/p&gt;
&lt;p&gt;With reference to the &lt;code&gt;QUERY&lt;/code&gt; HTTP method - personally I like this, and will make sue of this, so I hope it does get adopted in the mainstream in future.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;222: 14-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags</id>
		<title>EF tags and interceptors</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags" />
		<updated>2022-12-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tags&lt;/code&gt;, in conjunction with an &lt;code&gt;IInterceptor&lt;/code&gt; implementation, can be used to intercept SQL commands before being executed on the database, and modify them to fix the tag requirements.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In the examples below, we are using DbContext setup the standard way, with a &lt;code&gt;Blog&lt;/code&gt; DbSet.&lt;/p&gt;
&lt;p&gt;As per normal, to get a list of all &lt;em&gt;Blogs&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var normalQuery = context.Blogs.ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll look at how to &lt;em&gt;tag&lt;/em&gt; the queries with a &lt;code&gt;nolock&lt;/code&gt; tag, and then how to &lt;em&gt;intercept&lt;/em&gt; the query, look presence of the &lt;em&gt;tag&lt;/em&gt;, and modify the query to include &lt;code&gt;nolock&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tagging-queries"&gt;Tagging queries&lt;/h3&gt;
&lt;p&gt;The first step is to &lt;em&gt;tag&lt;/em&gt; the query with the &lt;code&gt;nolock&lt;/code&gt; tag - this is relatively straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var nolockQuery = context
    .Blogs
    .TagWith(&amp;quot;Nolock&amp;quot;)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the generated SQL is inspected, one will see the query is now tagged as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 1 completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="interceptor"&gt;Interceptor&lt;/h3&gt;
&lt;p&gt;The next step is to &lt;em&gt;intercept&lt;/em&gt; the query before it's executed on the database and modify it - luckily this is also fairly straightforward, as Entity Framework has a built in mechanism for this.&lt;/p&gt;
&lt;p&gt;To create an &lt;em&gt;interceptor&lt;/em&gt; (in this example) all that is required is to inherit from &lt;code&gt;DbCommandInterceptor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inherit DbCommandInterceptor
public class NoLockInterceptor : DbCommandInterceptor
{
    // overwrite the ReaderExecuting method
    public override InterceptionResult&amp;lt;DbDataReader&amp;gt; ReaderExecuting(DbCommand command, 
        CommandEventData eventData, 
        InterceptionResult&amp;lt;DbDataReader&amp;gt; result)
    {
        // if the query generated by EF starts with &amp;quot;nolock&amp;quot;
        if(command.CommandText.StartsWith(&amp;quot;-- Nolock&amp;quot;, StringComparison.Ordinal))
        {
            // append &amp;quot;nolock&amp;quot; to the end
            command.CommandText += &amp;quot; (NOLOCK)&amp;quot;;
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ReaderExecuting&lt;/code&gt; method is executed before the query is about to be executed - in this method, the query is (crudely) checked to see if it has been &lt;em&gt;tagged&lt;/em&gt; for &lt;code&gt;nolock&lt;/code&gt;, and if so, the &lt;code&gt;NOLOCK&lt;/code&gt; keyword is added to the end of the query.&lt;/p&gt;
&lt;p&gt;This is very crude and only for demo purposes - it is not production ready. Ror example, this does not take into account any &lt;em&gt;WHERE&lt;/em&gt; statements in the SQL.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dbcontext"&gt;DbContext&lt;/h3&gt;
&lt;p&gt;Now that we have the &lt;em&gt;interceptor&lt;/em&gt; defined, the next step is to register it with EF.&lt;/p&gt;
&lt;p&gt;In this demo, this is done in the &lt;em&gt;OnConfiguring&lt;/em&gt; method of the &lt;code&gt;DbContext&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(
        &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFTagging;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

    // add the interceptor
    optionsBuilder.AddInterceptors(new NoLockInterceptor());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuration is now completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;When querying (without an predicate in this sample) and tagging the query, the &lt;code&gt;nolock&lt;/code&gt; keyword is automatically added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// query without tagging
var normalQuery = context.Blogs.ToList();

//query with the tag
var nolockQuery = context.Blogs.TagWith(&amp;quot;Nolock&amp;quot;).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated by the two queries.&lt;/p&gt;
&lt;p&gt;Without the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b] (NOLOCK)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful and interesting way to combine two EF features - the &lt;em&gt;tagging&lt;/em&gt; and &lt;em&gt;interception&lt;/em&gt; features. Manually modifying SQL generated by EF can be dangerous as there are a lot of options and variations to the SQL generated - so do it with caution and test extensively.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/DaveCallanIE/status/1599379983817879552"&gt;Dave Callan Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;221: 13-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/12-enum-iteration</id>
		<title>Enum iteration</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/12-enum-iteration" />
		<updated>2022-12-12T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;code&gt;Enum.GetValues&lt;/code&gt; method value be used to get an array of the enum values, which can be output as a &lt;em&gt;string&lt;/em&gt; or corresponding compatible &lt;em&gt;underlying value&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="enum.getvalues"&gt;Enum.GetValues&lt;/h2&gt;
&lt;p&gt;The function and usage of &lt;code&gt;Enum.GetValues&lt;/code&gt; is very simple - it &lt;em&gt;converts an enum into an array of the enum values&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following enum:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum OrderStatus
{
    New = 0,
    Processing = 1,
    Fulfilled = 2,
    OutOnDelivery = 3,
    Delivered = 4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be converted to an array as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;OrderStatus[] enumItems = Enum.GetValues&amp;lt;OrderStatus&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This array can now be iterated over, and output either as a &lt;em&gt;string&lt;/em&gt; or &lt;em&gt;compatible underlying type&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach (var item in Enum.GetValues&amp;lt;OrderStatus&amp;gt;())
{
    // output the string value
    Console.WriteLine(item);

    // output the underlying value
    Console.WriteLine((int)item);
    // this would also work
    //Console.WriteLine((double)item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;New
0
Processing
1
Fulfilled
2
OutOnDelivery
3
Delivered
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simple, easy and very useful.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small but useful piece of knowledge for today.  This can be leveraged to automatically populate a UI dropdown with available options, for example, instead of having multiple places with a list of possible values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/enumerate-enum-csharp/"&gt;How to Enumerate an Enum in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;220: 12-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add</id>
		<title>Fast, potentially unsafe iteration</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add" />
		<updated>2022-12-09T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CollectionsMarshal&lt;/code&gt;, &lt;code&gt;MemoryMarshal&lt;/code&gt; and &lt;code&gt;Unsafe&lt;/code&gt; can be used in conjunction to create a &lt;em&gt;very fast&lt;/em&gt; &lt;code&gt;method of iteration&lt;/code&gt; (possibly the fastest method of performing for loops in C#)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iteration"&gt;Iteration&lt;/h2&gt;
&lt;p&gt;The technique may look a bit complex and complicated at first glance (or at least more complex than a normal &lt;code&gt;for&lt;/code&gt; loop) - but going through it step-by-step it is actually relatively simple. This technique is also not as &lt;code&gt;safe&lt;/code&gt; as the traditional method, due to the way memory is being handled in a potentially &lt;code&gt;unsafe&lt;/code&gt; way.&lt;/p&gt;
&lt;p&gt;The full code snippet is at the bottom of the section, but for now we'll have a look at it step-by-step.&lt;/p&gt;
&lt;p&gt;Assume we have a list of 50 items we want to iterate through:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="list-to-span"&gt;List to Span&lt;/h3&gt;
&lt;p&gt;The first step is to convert the &lt;code&gt;List&lt;/code&gt; to a &lt;code&gt;Span&lt;/code&gt;, using the &lt;em&gt;System.Runtime.InteropServices.CollectionsMarshal.AsSpan&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the &lt;code&gt;Span&lt;/code&gt; is in use, (as per the documentation) &lt;em&gt;items should not be added or removed from List&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="span-reference"&gt;Span reference&lt;/h3&gt;
&lt;p&gt;The next step is to get a reference to the &lt;em&gt;element of the span at index 0&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref int searchLocation = ref MemoryMarshal.GetReference(itemsAsSpan);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;em&gt;searchLocation&lt;/em&gt; is effectively now pointing to the first item in the &lt;em&gt;Span&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="iterate"&gt;Iterate&lt;/h3&gt;
&lt;p&gt;Next, we can perform the actual iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// for loop as per usual
for (int i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    // Instead of using itemsAsSpan[i], which is still fast
    // we start with the first item (searchLocation)
    // and offset it by i items
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop is defined as per normal, but instead of accessing the &lt;code&gt;Span&lt;/code&gt; item at position &lt;em&gt;i&lt;/em&gt; as one usually would (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), the &lt;code&gt;Unsafe.Add&lt;/code&gt; method is used.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unsafe.Add&lt;/code&gt; &lt;em&gt;adds an element offset to the given reference&lt;/em&gt; - in this case it will use &lt;em&gt;searchLocation&lt;/em&gt;, the first item in the Span as the given reference, and offset by &lt;em&gt;i items&lt;/em&gt; each time.
Each iteration, the offset is larger (as i increases) and as the given reference, &lt;em&gt;searchLocation&lt;/em&gt;, stays the same the item being referenced each loop is different.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="code-snippet"&gt;Code snippet&lt;/h3&gt;
&lt;p&gt;The full code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);

for (var i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;A full breakdown of the performance can be seen on Nick Chapsas's video, &lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8&amp;amp;t=490s"&gt;right here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But in short, using &lt;code&gt;the above method is the fastest way to iterate&lt;/code&gt;, slightly beating out using the index on the span (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), but significantly faster than all other methods (for loop, foreach loop etc)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This should probably not be the go-to iteration method for all applications in all use cases - however, when performance is critical and every fraction of a second is important, then this kind of optimization could make a difference.
As mentioned, this technique is less &amp;quot;safe&amp;quot; than the usual &lt;em&gt;for&lt;/em&gt; or &lt;em&gt;foreach&lt;/em&gt; methods, so should be used with caution.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8"&gt;The weirdest way to loop in C# is also the fastest&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;219: 09-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by</id>
		<title>EF7 GroupBy support</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by" />
		<updated>2022-12-08T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Prior to Entity Framework 7, having a LINQ &lt;code&gt;GroupBy&lt;/code&gt; as the final operator in a query would result in an exception being thrown - EF7 adds support for this scenario, allowing &lt;code&gt;GroupBy&lt;/code&gt; to be the final operator.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;In this scenario, we have a simple &lt;em&gt;Blog&lt;/em&gt; class, setup as a &lt;em&gt;DbSet&lt;/em&gt; in a &lt;em&gt;DbContext&lt;/em&gt;, configured to connect to SQL Server:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we want to &lt;em&gt;select all Blogs&lt;/em&gt;, but &lt;code&gt;group them by the DateCreated&lt;/code&gt; - lets see how this can be done.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="before-ef7"&gt;Before EF7&lt;/h3&gt;
&lt;p&gt;If we try perform the &lt;em&gt;GroupBy&lt;/em&gt; as the final operation &lt;code&gt;prior to EF7&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we're not querying the actual database
// just getting the query which would be 
// generated
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

Console.WriteLine(query);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An exception is thrown!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The LINQ expression 'DbSet&amp;lt;Blog&amp;gt;().GroupBy(b =&amp;gt; b.DateCreated)' could not be translated. 
Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To perform this, the &lt;em&gt;group by&lt;/em&gt; logic would need to be done in code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// get all relevent blogs, ungrouped
var List&amp;lt;Blog&amp;gt; = context.Blogs.ToList();

// group the blogs by date in code
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? blogByDate = 
    blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the requirement to group by &lt;em&gt;DateCreated&lt;/em&gt; is definitely do-able, just maybe not as simple and intuitive to do as it should be.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ef7"&gt;EF7&lt;/h3&gt;
&lt;p&gt;EF7 makes implementing the same requirement a little bit easier. Upgrading to EF7, and executing the exact same code as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we not querying the actual database
// just getting the query the following would
// generate
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now yields the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;SELECT [b].[DateCreated], [b].[Id], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
ORDER BY [b].[DateCreated]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;GroupBy&lt;/em&gt; is not perform on the database itself, but is again, performed in code - just this time it is done automatically by EF.&lt;/p&gt;
&lt;p&gt;The output type is the same as when the operation is performed manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small enhancement to EF, but one which makes building up queries in EF using LINQ more intuitive, and results in the developer having to do slightly less work overall.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1595887786535575554"&gt;Oleg Kyrylchuk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 08-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception</id>
		<title>Unreachable code and UnreachableException</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception" />
		<updated>2022-12-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; was introduced in .NET 7, which is used in situations &lt;em&gt;when the application executes code thought to be unreachable&lt;/em&gt;. If this exception does occur, then there is an error in the flow or data of the application causing the, previous thought, unreachable code to be executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unreachable-code-setup"&gt;Unreachable code setup&lt;/h2&gt;
&lt;p&gt;Consider the follow example of example - we have an &lt;code&gt;enum&lt;/code&gt; of &lt;em&gt;OrderStatus&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum OrderStatus
{
    New = 0,
    Processing = 1,
    Fulfilled = 2,
    OutOnDelivery = 3,
    Delivered = 4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As well as a switch expression to convert the &lt;code&gt;enum&lt;/code&gt; value to a &lt;code&gt;string description&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; is used if the code tries to convert an &lt;code&gt;OrderStatus which does not exist&lt;/code&gt; to a string - in theory a situation which should never occur.&lt;/p&gt;
&lt;p&gt;We also have a method to retrieve the order status, &lt;code&gt;stored as an int&lt;/code&gt;, from the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public OrderStatus GetOrderStatusFromDatabase()
{
    // simulate getting the value from the database
    return (OrderStatus)2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="executing-unreachable-code"&gt;Executing unreachable code&lt;/h2&gt;
&lt;p&gt;If the database stores a valid &lt;em&gt;OrderStatus&lt;/em&gt; int value, everything will execute as expected.&lt;/p&gt;
&lt;p&gt;In this example, the database &lt;code&gt;stores an OrderStatus value of 2&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 2
OrderStatus currentStatus = GetOrderStatusFromDatabase();

var currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException()
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Order: Processing Order
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if the &lt;em&gt;OrderStatus&lt;/em&gt; was manually, incorrectly &lt;code&gt;updated to be 5&lt;/code&gt; in the database - this is a situation which &lt;em&gt;should never happen, but in reality it could&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 5
OrderStatus currentStatus = GetOrderStatusFromDatabase();

string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The C# code &lt;code&gt;allows the currentStatus variable to be set to a value of 5, an enum value which doesn't exist&lt;/code&gt; - and only when it comes time to convert to a string (in the  switch expression), will there be no match to any of the options and the &lt;code&gt;UnreachableException&lt;/code&gt; be thrown.&lt;/p&gt;
&lt;p&gt;Monitoring tools or logs can now be checked for the presence of &lt;code&gt;UnreachableException&lt;/code&gt; and if such an exception occurs, something has gone wrong.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful tool at a developers disposal to assist in tracking down completely unexpected issues which may arise - but a tool which should hopefully never actually be reached to be used!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=s_NrqRI7Gnc&amp;amp;t=308s"&gt;The new .NET Exception that should NEVER be thrown&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 07-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes</id>
		<title>Determining bytes of memory allocated</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes" />
		<updated>2022-12-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;em&gt;Garbage Collector&lt;/em&gt; class &lt;code&gt;GC&lt;/code&gt; contains a &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; method which can be used to &lt;em&gt;get the number of bytes allocated&lt;/em&gt; in the current thread (as the name implies).&lt;/p&gt;
&lt;p&gt;This can be leveraged to discover some interesting facts about how the application is allocated &lt;em&gt;unessacary memory&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getallocatedbytes-usage"&gt;GetAllocatedBytes usage&lt;/h2&gt;
&lt;p&gt;The usage of &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; is very simple and straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the bytes allocated at the start of the process
long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declare a string and use it
string strValue = &amp;quot;This is a string&amp;quot;;
Console.WriteLine(strValue);

// get the bytes allocated after
long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

// output the results
Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A snapshot of the bytes used is taken before the work, and then again after.&lt;/p&gt;
&lt;p&gt;The result of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a string
Before allocation: 1761952 | After allocation: 1764552
Bytes used: 2600
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="interesting-findings"&gt;Interesting findings&lt;/h2&gt;
&lt;h3 id="unused-variable"&gt;Unused variable&lt;/h3&gt;
&lt;p&gt;In some instances, if a variable is defined, but never used, the compiler will remove it and no memory will be allocated.&lt;/p&gt;
&lt;p&gt;Below is the same example as above, but &lt;em&gt;without the variable &amp;quot;strValue&amp;quot; ever being used&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declared, but never used
string strValue = &amp;quot;This is a string&amp;quot;;

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output here:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768144 | After allocation: 1768144
Bytes used: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler is performing optimizations to remove unused code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="empty-array"&gt;Empty array&lt;/h3&gt;
&lt;p&gt;Declaring an empty array, will still allocated memory - this is because the array itself is of type &lt;code&gt;Array&lt;/code&gt; and contains information about what the array itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768112
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Declaring multiple empty arrays, will use memory in multiples of 24 bytes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];
int[] list1 = new int[0];
int[] list2 = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this, 24 bytes x 3:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768160
Bytes used: 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use less memory, the static &lt;code&gt;Array.Empty&lt;/code&gt; method is used. This will assign the same empty static array to each instance, thus not allocated additional memory each time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// use Array.Empty instead of new []
int[] list = Array.Empty&amp;lt;int&amp;gt;();
int[] list1 = Array.Empty&amp;lt;int&amp;gt;();
int[] list2 = Array.Empty&amp;lt;int&amp;gt;();

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output, only 24 bytes used in total:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1761896 | After allocation: 1761920
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful method which can help benchmark memory usage in an application, as well as just provide an insight into interesting aspects of how the compiler allocates (or doesn't allocated) memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/db43d6f4-4b93-415f-be03-600ee358cdfd"&gt;How to get allocations in .NET? And how big is an empty array?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;217: 06-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>