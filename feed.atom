<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-10-14T05:07:33Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/14-newtonsoft-jsonconverter</id>
		<title>Deserializing incomparable types using JsonConverter</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/14-newtonsoft-jsonconverter" />
		<updated>2022-10-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;Newtonsoft.Json&lt;/code&gt; to perform deserialization, the &lt;code&gt;JsonConverter&lt;/code&gt; class can be used to customize how the data of a specific type is deserialized - this allows to perform custom logic, allowing seemingly incompatible types to be &lt;em&gt;&amp;quot;compatible&amp;quot;&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="real-world-scenario"&gt;Real world scenario&lt;/h2&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;
&lt;p&gt;In this use case, &lt;code&gt;Newtonsoft.Json&lt;/code&gt; is being used to serialize a simplified &lt;em&gt;source entity&lt;/em&gt; which looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SourceEntity
{
    public int Id { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The json string is then being deserialized into a separate &lt;em&gt;destination entity&lt;/em&gt; which looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DestinationEntity
{
    public int Id { get; set; }

    public DateTimeOffset DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;DateCreated&lt;/em&gt; property is defined as &lt;code&gt;DateTime&lt;/code&gt; in the source and &lt;code&gt;DateTimeOffset&lt;/code&gt; in the destination - &lt;code&gt;aren't those two types compatible&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Generally yes, those two types are compatible and the deserialization/serialization will occur without issue - that is unless the &lt;code&gt;SourceEntity DateCreated field contains DateTime.MinValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sourceDate = new SourceEntity
{
    Id = 100,
    // set to minimum value possible
    DateCreated = DateTime.MinValue
};

// serialize the source entity with a DateCreated value
// of DateTime.MinValue
string jsonEntity = 
    Newtonsoft.Json.JsonConvert.SerializeObject(sourceDate);

// this will cause an exception to occur
DestinationEntity destinationDate = Newtonsoft.Json.JsonConvert
    .DeserializeObject&amp;lt;DestinationEntity&amp;gt;(jsonEntity);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this happens, then the deserialization fails with the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;An unhandled exception of type 'Newtonsoft.Json.JsonReaderException' occurred in Newtonsoft.Json.dll
Could not convert string to DateTimeOffset: 0001-01-01T00:00:00. Path 'DateCreated', line 1, position 45.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To solve this issue, a custom &lt;code&gt;JsonConvert&lt;/code&gt; implementation can be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="jsonconvert"&gt;JsonConvert&lt;/h3&gt;
&lt;p&gt;To implement a custom converter one needs to inherit from the  the &lt;em&gt;abstract&lt;/em&gt; &lt;code&gt;JsonConverter&lt;/code&gt; class. There are a number of methods to override and implement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DateTimeConverter : JsonConverter
{
    public override bool CanRead =&amp;gt; true;
    public override bool CanWrite =&amp;gt; false;

    // this converter should only apply when the 
    // destination type being converted is a
    // datetimeoffset    
    public override bool CanConvert(Type objectType) 
        =&amp;gt; objectType == typeof(DateTimeOffset);

    // method is called when reading the json
    // this method is only called when the destination 
    // type is DateTimeOffset (as defined by the 
    // CanConvert method)
    public override object ReadJson(JsonReader reader, 
        Type objectType, object existingValue, 
        JsonSerializer serializer)
    {
        // try convert the value to a datetime offset
        if (DateTimeOffset.TryParse(reader.Value.ToString(), 
            out DateTimeOffset result))
        {
            // if it was converted successfully
            return result;
        }

        // return min value if it cannot
        return DateTimeOffset.MinValue;
    }

    // converter should not be used on serialization
    // so don't need to implement this method
    public override void WriteJson(JsonWriter writer, 
        object value, JsonSerializer serializer)
    {
        throw new NotImplementedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="deserialization"&gt;Deserialization&lt;/h3&gt;
&lt;p&gt;When deserializing, none or many converters can be passed into the &lt;em&gt;DeserializeObject&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sourceDate = new SourceEntity
{
    Id = 100,
    DateCreated = DateTime.MinValue
};

string jsonEntity = 
    Newtonsoft.Json.JsonConvert.SerializeObject(sourceDate);

// pass in the DateTimeConverter when deserializing
DestinationEntity destinationDate = Newtonsoft.Json.JsonConvert
        .DeserializeObject&amp;lt;DestinationEntity&amp;gt;(jsonEntity, new DateTimeConverter());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the additional of &lt;code&gt;DateTimeConverter&lt;/code&gt;, the conversion is now performed without any issue.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While Newtonsoft.Json should, in &lt;em&gt;most&lt;/em&gt; cases, be replaced with &lt;code&gt;System.Text.Json&lt;/code&gt; due to its performance improvements, Newtonsoft.Json still gets &lt;em&gt;a lot&lt;/em&gt; of usage due to the depth of functionality and flexibility it offers (although in this specific use case, System.Text.Json does offer the ability to implement custom converters as well).
It is beneficial to be aware of Newtonsoft.Json and how it can be leveraged when System.Text.Json doesn't provide the required functionality.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;182: 14-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/13-objectpool</id>
		<title>ObjectPool for resource management</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/13-objectpool" />
		<updated>2022-10-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Th &lt;code&gt;ObjectPool&lt;/code&gt; class can be leveraged to keep a &lt;em&gt;group of objects in memory for reuse&lt;/em&gt; rather than allowing the objects to be garbage collected and having to be reinitialized every time required.&lt;/p&gt;
&lt;p&gt;This is especially useful if the object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is expensive to allocate/initialize.&lt;/li&gt;
&lt;li&gt;represent some limited resource.&lt;/li&gt;
&lt;li&gt;is used predictably and frequently.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Usage of the &lt;code&gt;ObjectPool&lt;/code&gt; consists of a few steps:&lt;/p&gt;
&lt;h3 id="objectpoolprovider"&gt;ObjectPoolProvider&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ObjectPoolProvider&lt;/code&gt; is used to ultimately &lt;em&gt;create the ObjectPool&lt;/em&gt; based on a &lt;em&gt;policy&lt;/em&gt;. The below code snippet uses the &lt;code&gt;DefaultObjectPoolProvider&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The dependency injection container is configured as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.TryAddSingleton&amp;lt;ObjectPoolProvider, DefaultObjectPoolProvider&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the &lt;code&gt;DefaultObjectPoolProvider&lt;/code&gt; is used and the item stored in the pool (&lt;em&gt;StringBuilder&lt;/em&gt; in the following examples) implements IDisposable, Then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;items that are not returned to the pool will be disposed&lt;/li&gt;
&lt;li&gt;when the pool gets disposed by the dependency injection container, all items in the pool are disposed&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="objectpool"&gt;ObjectPool&lt;/h3&gt;
&lt;p&gt;The next step is to register the &lt;code&gt;ObjectPool&lt;/code&gt; itself with the dependency injection container, in this case using an implementation factory:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.TryAddSingleton&amp;lt;ObjectPool&amp;lt;StringBuilder&amp;gt;&amp;gt;(serviceProvider =&amp;gt;
{
    // get the provider registered in the previous step
    var provider = serviceProvider.GetRequiredService&amp;lt;ObjectPoolProvider&amp;gt;();
    // create a policy, using the built in string builder policy
    var policy = new StringBuilderPooledObjectPolicy();
    // return an ObjectPool&amp;lt;StringBuilder&amp;gt; instance created using the policy
    return provider.Create(policy);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="injection"&gt;Injection&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ObjectPool&amp;lt;StringBuilder&amp;gt;&lt;/code&gt; can now be injected into the relevent method/delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/buildstring&amp;quot;, (ObjectPool&amp;lt;StringBuilder&amp;gt; pool) =&amp;gt;
{
    // get a StringBuilder instance from the pool
    var sBuilder = pool.Get();

    try
    {
        // use the string builder
        sBuilder.Append(&amp;quot;This string has been built up using &amp;quot;);
        sBuilder.Append(&amp;quot;a StringBuilder instance from an &amp;quot;);
        sBuilder.Append(&amp;quot;ObjectPool&amp;lt;StringBuilder&amp;gt; instance&amp;quot;);

        return sBuilder.ToString();
    }
    finally
    {
        // return it to the pool
        pool.Return(sBuilder);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Get&lt;/code&gt; method on &lt;code&gt;ObjectPool&lt;/code&gt; is used to get an instance of the class from the pool (&lt;em&gt;StringBuilder&lt;/em&gt; in this example)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Return&lt;/code&gt; method is used to return the instance back to the &lt;code&gt;ObjectPool&lt;/code&gt;, making it available for reused in the future&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;While using the &lt;code&gt;ObjectPool&lt;/code&gt; can definitely increase performance, it does not always guarantee it. Object pooling usually won't improve performance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unless the initialization cost of an object is high, it's usually slower to get the object from the pool.&lt;/li&gt;
&lt;li&gt;objects managed by the pool aren't de-allocated until the pool is de-allocated.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Under the right use-case object pool can definitely make a difference to the performance of an application. However, if used incorrect it can be detrimental - so if performance is a concern, benchmark and make an informed decision for the specific use case.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-6.0"&gt;Object reuse with ObjectPool in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;181: 13-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/12-list-sort-performance</id>
		<title>Primitive collection performance</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/12-list-sort-performance" />
		<updated>2022-10-12T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduces a small update when using LINQ to perform &lt;code&gt;sorting on a collection&lt;/code&gt; to slightly &lt;code&gt;simplifying the code&lt;/code&gt; - however, when working with arrays, the &lt;code&gt;Array.Sort&lt;/code&gt; method is the most performant method to use to perform the sort.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-7-updates"&gt;.NET 7 updates&lt;/h2&gt;
&lt;p&gt;Prior to .NET 7, when performing a &lt;em&gt;sort&lt;/em&gt; on a collection of items, the &lt;code&gt;OrderBy&lt;/code&gt; or &lt;code&gt;OrderByDescending&lt;/code&gt; method is generally used to sort the items (&lt;em&gt;OrderBy&lt;/em&gt; and &lt;em&gt;OrderByDescending&lt;/em&gt; are extension methods on IEnumerable):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// generate a random list of 500 entities into an item array
var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine(items[0]);
// sort the items
var sortedItems = items.OrderBy(item =&amp;gt; item).ToArray();
Console.WriteLine(sortedItems[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When working with primitives, in the &lt;em&gt;OrderBy&lt;/em&gt; method the &lt;code&gt;keySelector&lt;/code&gt; (&lt;em&gt;item&lt;/em&gt; in the above example) is required to be specified, even though there is only one selector - the item in the collection. This is versus a collection of &lt;em&gt;classes&lt;/em&gt;, where the &lt;code&gt;keySelector&lt;/code&gt; could be any property on the class.&lt;/p&gt;
&lt;p&gt;With .Net 7, the &lt;code&gt;keySelector&lt;/code&gt; is no longer required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine($&amp;quot;First item before sort: {items[0]}&amp;quot;);
// sort the items, NO SELECTOR
var newSortedItems = items.Order().ToArray();
Console.WriteLine($&amp;quot;First item after sort: {newSortedItems[0]}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same output, however &lt;code&gt;slightly more readable and concise code&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="array.sort"&gt;Array.Sort&lt;/h2&gt;
&lt;p&gt;Using the LINQ &lt;code&gt;OrderBy&lt;/code&gt; or &lt;code&gt;OrderByDescending&lt;/code&gt; methods is the default go-to when wanting to sort a collection - however there is another option when &lt;em&gt;working with arrays&lt;/em&gt; - the static &lt;code&gt;Array.Sort&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;The method usage is straight forward - it takes an array as a parameter, and will &lt;code&gt;sort the supplied array, NOT return a sorted copy&lt;/code&gt;, as with the LINQ methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine($&amp;quot;First item before sort: {items[0]}&amp;quot;);
// Perform the sort
Array.Sort(items);
// use the SAME array
Console.WriteLine($&amp;quot;First item after sort: {items[0]}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One again, the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Let's benchmark the three methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the pre-dotnet 7 &lt;code&gt;OrderBy&lt;/code&gt; with a &lt;code&gt;keySelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the new .NET 7 &lt;code&gt;OrderBy&lt;/code&gt; without a &lt;code&gt;keySelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.Sort&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The below was run on the same 500 item collection as shown in the above examples:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OrderBy&lt;/td&gt;
&lt;td style="text-align: right;"&gt;41.56 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.216 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.181 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.2 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Order&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.75 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.304 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.285 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.98&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.23 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ArraySort&lt;/td&gt;
&lt;td style="text-align: right;"&gt;18.10 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.180 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.168 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.13 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The new and old version of &lt;code&gt;OrderBy&lt;/code&gt; practically have the same performance, however for this use case, the &lt;code&gt;Array.Sort&lt;/code&gt; is &lt;code&gt;over 200% faster&lt;/code&gt;, and uses only &lt;code&gt;20% of the memory&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The .NET 7 LINQ &lt;em&gt;OrderBy&lt;/em&gt; enhancements definitely make the code slightly more readable and concise - however if performance is critical, consider using &lt;code&gt;AArray.Sort&lt;/code&gt; and avoiding &lt;em&gt;OrderBy&lt;/em&gt; entirely. Result may vary based on the size of the array, so as always benchmark with your specific expected workload to get a comparison and make an informed choice.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1567620600599908352"&gt;Oleg Kyrylchuk tweet&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.youtube.com/watch?v=K1Ye_QEpAq8"&gt;Stop using LINQ to order your primitive collections in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;180: 12-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/11-readonly-list</id>
		<title>ReadOnlyList and runtime errors</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/11-readonly-list" />
		<updated>2022-10-11T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with a &lt;code&gt;ReadOnlyList&lt;/code&gt;, depending on how the list is defined, it is possible to &lt;em&gt;accidentally try&lt;/em&gt; change a value in the list, with the exception only becoming apparent at runtime and not compile time.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="runtime"&gt;Runtime&lt;/h2&gt;
&lt;p&gt;Suppose we have the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; golden = new List&amp;lt;int&amp;gt; { 1, 6, 1, 8 };

// readonlyGolden is a readonly list
IList&amp;lt;int&amp;gt; readonlyGolden = golden.AsReadOnly();

// still allows for trying to change the value
readonlyGolden[1] = 7;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though &lt;em&gt;golden&lt;/em&gt; is being &lt;code&gt;converted to readonly list with the AsReadOnly method&lt;/code&gt;, as it is being cast to &lt;em&gt;IList&amp;lt;int&amp;gt;&lt;/em&gt;, the compiler does recognize &lt;em&gt;readonlyGolden&lt;/em&gt; are read only.&lt;/p&gt;
&lt;p&gt;&amp;quot;Changing&amp;quot; the value in the readonly list is &amp;quot;allowed&amp;quot; at compiled, however at runtime a &lt;code&gt;NotSupportedException&lt;/code&gt; will be thrown:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Collection is read-only.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="compile-time"&gt;Compile time&lt;/h2&gt;
&lt;p&gt;Instead, of &lt;em&gt;IList&amp;lt;int&amp;gt;&lt;/em&gt; the &lt;em&gt;golden&lt;/em&gt; variable is cast to &lt;em&gt;IReadOnlyList&amp;lt;int&amp;gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; golden = new List&amp;lt;int&amp;gt; { 1, 6, 1, 8 };

// readonlyGolden is a readonly list
IReadOnlyList&amp;lt;int&amp;gt; readonlyGolden = golden.AsReadOnly();
// OR
// IReadOnlyList&amp;lt;int&amp;gt; readonlyGolden = golden

// this will cause a compiler error
readonlyGolden[1] = 7;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the code will not compile, as the compile recognizes &lt;em&gt;readonlyGolden&lt;/em&gt; as read-only.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Property or indexer 'IReadOnlyList&amp;lt;int&amp;gt;.this[int]' cannot be assigned to -- it is read only
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The above may seem obvious - cast a list to &lt;em&gt;IList&lt;/em&gt; and it's not (necessarily) readonly, while casting it to &lt;em&gt;IReadOnlyList&lt;/em&gt; will definitely make it readonly. However, the take away is that one &lt;code&gt;cannot assume that an IList is mutable&lt;/code&gt;, just because the compiler does not stop the code from compiling - the implementation could be a &lt;em&gt;ReadOnlyList&lt;/em&gt;, which will only become apparent at runtime, with an exception.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1567562406271885313"&gt;Davide Bellone tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;179: 11-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages</id>
		<title>Automatic redirect on http status code</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages" />
		<updated>2022-10-10T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UseStatusCodePagesWithRedirects&lt;/code&gt; method can be used to redirect the client to an error page in the case of a non-successful request (400-599 range)&lt;/p&gt;
&lt;p&gt;This method returns a &lt;em&gt;301-Found&lt;/em&gt; to the client, and then redirects to the &lt;em&gt;redirect endpoint&lt;/em&gt; which will return a status code of &lt;em&gt;200-Success&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is often used when the app:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should redirect the client to a different endpoint, perhaps to have a different application process the error. In the browser, the redirect endpoint will be reflected&lt;/li&gt;
&lt;li&gt;Doesn't need to preserve and return the original status code with the initial redirect response back to the client&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="middleware-setup"&gt;Middleware setup&lt;/h2&gt;
&lt;p&gt;First step is to enable the automatic redirect functionality - this step is very straight-froward, and entails adding a single middleware components:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = builder.Build();

// other middleware setup goes here
app.UseStatusCodePagesWithRedirects("/error?status={0}");
// other middleware setup goes here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the middleware is instructed to redirect any responses (which are not successful) to the &lt;code&gt;/error&lt;/code&gt; endpoint. The endpoint can include a &lt;code&gt;{0}&lt;/code&gt; placeholder which will contain the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="error-endpoint"&gt;Error endpoint&lt;/h2&gt;
&lt;p&gt;Next, up the &lt;code&gt;/error&lt;/code&gt; endpoint is defined.&lt;/p&gt;
&lt;p&gt;Here the &lt;em&gt;Map&lt;/em&gt; method is used - this takes an &lt;em&gt;IApplicationBuilder&lt;/em&gt; as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.Map("/error", errorApp =&amp;gt;
{
    errorApp.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync($"This is a redirected " +
            $"error message status {context.Request.Query["status"]}");
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For all &lt;em&gt;error&lt;/em&gt; responses, the message will be output along with the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="execution"&gt;Execution&lt;/h2&gt;
&lt;p&gt;A number of other endpoints were also defined to simulate different status code responses:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/500response", context =&amp;gt;
{
    context.Response.StatusCode = 500;
    return Task.CompletedTask;
});

app.MapGet("/401response", context =&amp;gt;
{
    context.Response.StatusCode = 401;
    return Task.CompletedTask;
});

app.MapGet("/200response", context =&amp;gt;
{
    context.Response.StatusCode = 200;
    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/500response&lt;/code&gt; from a browser, for example, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a redirected error message status 500
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And looking at the &lt;em&gt;Network&lt;/em&gt; tab of the browse, one can see that the initial status code returned is &lt;code&gt;302&lt;/code&gt;, followed by the &lt;code&gt;200 on redirect&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/statuscode.png" alt="HTTP Status code"&gt;&lt;/p&gt;
&lt;p&gt;Now, on error (500 status code), the caller is routed to a generic error page, with a &lt;em&gt;200&lt;/em&gt; response, and the actual error in the content of the page.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;For a lot of situations this might not be especially useful, as the return message and status code is not especially useful to the calling application to act on.&lt;/p&gt;
&lt;p&gt;For a customer facing application this could be useful (providing the actual error is logged and recorded somewhere) as the customer doesn't care about the details of the eror, but for a backend api-to-api call, the string response is not especially useful.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/diagnostics/diagnostics-5"&gt;Status Pages&lt;/a&gt;&lt;br&gt;
&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-6.0#usestatuscodepageswithredirects"&gt;UseStatusCodePages&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;178: 10-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/07-linq-type-performance</id>
		<title>Performant LINQ type checks</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/07-linq-type-performance" />
		<updated>2022-10-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In a previous post, we had a look at &lt;a href="https://alwaysdeveloping.net/08/19-linq-oftype"&gt;LINQ's OfType&lt;/a&gt; method - while personally this is still my preferred method (for readability) to do &lt;em&gt;type comparisons&lt;/em&gt; using LINQ, it is not the most performant.&lt;/p&gt;
&lt;p&gt;If performing &lt;em&gt;type checks&lt;/em&gt; using LINQ, a &lt;code&gt;GetType() == typeof&lt;/code&gt; check is the most performant.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="type-checks"&gt;Type checks&lt;/h2&gt;
&lt;p&gt;First, we'll have a look at the various methods for doing &lt;em&gt;type comparisons&lt;/em&gt; in LINQ which will be benchmarked.&lt;/p&gt;
&lt;p&gt;In all of the below example, as well as the benchmarks, a &lt;code&gt;List&amp;lt;object&amp;gt;&lt;/code&gt; is used, which contains &lt;code&gt;100 items&lt;/code&gt; either a &lt;em&gt;TypeA&lt;/em&gt; class, or a &lt;em&gt;TypeB&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// sample of the items - in the actual benchmark, _items
// contained 100 items
private List&amp;lt;object&amp;gt; _items = new List&amp;lt;object&amp;gt; {
    new TypeA(), new TypeA(), new TypeB(), new TypeA(), new TypeB()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where applicable,  different variations on the techniques, one using &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt; the cast, and the other using the &lt;code&gt;Cast&lt;/code&gt; method, were also benchmarked.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="oftype"&gt;OfType&lt;/h3&gt;
&lt;p&gt;The first method is by using the &lt;code&gt;OfType&lt;/code&gt; method, explored in a &lt;a href="https://alwaysdeveloping.net/08/19-linq-oftype"&gt;previous post&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
            .OfType&amp;lt;TypeA&amp;gt;()
            .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I still find this to be the cleanest and easiest to read method.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="cast-with-is"&gt;Cast with is&lt;/h3&gt;
&lt;p&gt;The next approach is to use the &lt;code&gt;is&lt;/code&gt; keyword to check the &lt;em&gt;type&lt;/em&gt; and then use the &lt;code&gt;Cast&lt;/code&gt; method to cast the filtered items to the desired type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t is TypeA)
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Where&lt;/code&gt; method filters down the list to items of only &lt;em&gt;TypeA&lt;/em&gt; however, the filtered list is still of type &lt;em&gt;object&lt;/em&gt;, and hence the &lt;code&gt;Cast&lt;/code&gt; method needs to be used to convert to the correct type.&lt;/p&gt;
&lt;p&gt;The variation is the same as the above, but instead using the &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t is TypeA)
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="cast-with-is-1"&gt;Cast with is&lt;/h3&gt;
&lt;p&gt;Next up we use the &lt;code&gt;as&lt;/code&gt; keyword to check the &lt;em&gt;type&lt;/em&gt;. This casts the object to &lt;em&gt;TypeA&lt;/em&gt;, and checks that the result is not null (the cast is possible). Then like the previous example, the &lt;code&gt;Cast&lt;/code&gt; method to cast the filtered items to the desired type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t as TypeA is not null)
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As before, the &lt;code&gt;Where&lt;/code&gt; method filters down the list to items of only &lt;em&gt;TypeA&lt;/em&gt; however, the filtered list is still of type &lt;em&gt;object&lt;/em&gt;, and hence the &lt;code&gt;Cast&lt;/code&gt; method needs to be used to convert to the correct type.&lt;/p&gt;
&lt;p&gt;As above, variation is the same as the above technique, but instead using the &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="gettype-with-typeof"&gt;GetType with typeof&lt;/h3&gt;
&lt;p&gt;The last method is the most &lt;em&gt;raw&lt;/em&gt; method - manually get the type of the item in the list, and check if its of the same type we desire. Then as before, perform the &lt;code&gt;Cast&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="performance-results"&gt;Performance Results&lt;/h2&gt;
&lt;p&gt;Running the above queries against a list of 100 items, the result are:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IsType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.759 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0334 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0279 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.749 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsTypeSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.430 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0275 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0609 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.416 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AsType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.862 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0570 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1071 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.844 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AsTypeSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.265 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0298 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0846 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.296 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OfType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.873 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0320 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0284 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.870 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.23 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GetTypeTypeOf&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.520 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0495 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0463 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.510 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GetTypeTypeOfSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.121 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0100 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0093 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.124 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the result, using &lt;code&gt;GetType == typeof&lt;/code&gt; is the &lt;code&gt;fastest method&lt;/code&gt; (while also very slightly using the most memory), while using &lt;code&gt;OfType&lt;/code&gt; is the &lt;code&gt;slowest method&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using &lt;em&gt;Select&lt;/em&gt; to cast is also approximately &lt;code&gt;twice as fast&lt;/code&gt; as using &lt;em&gt;Cast&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the &lt;em&gt;GetTypeTypeOfSelect&lt;/em&gt; method was my far the fastest method, when performing a single LINQ command, the difference is not going to be noticeable (nano-seconds scale) - however if the collections are larger, and the time frames start moving into the milliseconds or seconds realm, then the method used starts to make a difference. However as usual, benchmark your specific use case and result may vary based on the type of entity, as well as the collection size.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=dIu5EisoB_s"&gt;The fastest way to cast objects in C# is not so obvious&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;177: 07-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/06-string-create</id>
		<title>Culture specific strings with String.Create</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/06-string-create" />
		<updated>2022-10-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Introduced in C# 10 (.NET 6), the &lt;code&gt;String.Create&lt;/code&gt; method can be used to evaluate an &lt;em&gt;interpolated string&lt;/em&gt; to a specific culture (including the invariant culture). This method is faster, and uses less resources than the previously available method of using &lt;code&gt;FormattableString&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="formattablestring"&gt;FormattableString&lt;/h2&gt;
&lt;h3 id="invariant"&gt;Invariant&lt;/h3&gt;
&lt;p&gt;Prior to C# 10 &lt;code&gt;FormattableString&lt;/code&gt; was the method used, and evaluating an &lt;em&gt;interpolated string&lt;/em&gt; to &lt;em&gt;invariant culture&lt;/em&gt; was fairly straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output the string formatted to &amp;quot;invariant culture&amp;quot;
Console.WriteLine(FormattableString.Invariant(
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 03:49:41
Decimal: 1.99 | Date: 09/12/2022 03:49:41
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="culture-specific"&gt;Culture specific&lt;/h3&gt;
&lt;p&gt;Evaluating an &lt;em&gt;interpolated string&lt;/em&gt; to &lt;em&gt;a specific culture&lt;/em&gt; is slightly more complicated when using &lt;code&gt;FormattableString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output the string formatted in the specific culture
// first declare the FormattableString
FormattableString formattable = $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;;
// ToString specifying the culture
Console.Write(formattable.ToString(CultureInfo.GetCultureInfo(&amp;quot;en-US&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:00:47
Decimal: 1.99 | Date: 9/12/2022 4:00:47 AM
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="string.create"&gt;String.Create&lt;/h2&gt;
&lt;h3 id="invariant-1"&gt;Invariant&lt;/h3&gt;
&lt;p&gt;The new &lt;code&gt;String.Create&lt;/code&gt; method introduced in .NET6 with C# 10, simplifies the evaluation of a interpolated string to a specific culture:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output string with the specific culture (invariant)
Console.WriteLine(String.Create(CultureInfo.InvariantCulture,
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above (which is the same as when using &lt;em&gt;FormattableString.Invariant&lt;/em&gt; above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:02:59
Decimal: 1.99 | Date: 09/12/2022 04:02:59
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="culture-specific-1"&gt;Culture specific&lt;/h3&gt;
&lt;p&gt;Specifying a &lt;em&gt;specific culture&lt;/em&gt; with &lt;code&gt;String.Create&lt;/code&gt; is just as simple as specifying &lt;em&gt;InvariantCulture&lt;/em&gt;, and definitely simpler than the &lt;em&gt;FormattableString&lt;/em&gt; equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output string with the specific culture (en-US)
Console.WriteLine(String.Create(CultureInfo.GetCultureInfo(&amp;quot;en-US&amp;quot;),
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above (which is the same as when using &lt;em&gt;FormattableString&lt;/em&gt; with the specific culture above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:05:15
Decimal: 1.99 | Date: 9/12/2022 4:05:15 AM
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;BenchmarkDotNet&lt;/code&gt; to compare the speed and memory usage of the above 4 methods, we can see that in all cases, using the &lt;em&gt;String.Create&lt;/em&gt; version is &lt;code&gt;faster, and uses less memory&lt;/code&gt; than the &lt;em&gt;FormattableString versions&lt;/em&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;StringFormatterInvariant&lt;/td&gt;
&lt;td style="text-align: right;"&gt;342.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.92 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.60 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0367&lt;/td&gt;
&lt;td style="text-align: right;"&gt;232 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringFormatterCulture&lt;/td&gt;
&lt;td style="text-align: right;"&gt;400.2 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.81 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.87 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0429&lt;/td&gt;
&lt;td style="text-align: right;"&gt;272 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringCreateInvariant&lt;/td&gt;
&lt;td style="text-align: right;"&gt;272.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.86 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.42 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0162&lt;/td&gt;
&lt;td style="text-align: right;"&gt;104 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringCreateCulture&lt;/td&gt;
&lt;td style="text-align: right;"&gt;326.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.41 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.91 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0229&lt;/td&gt;
&lt;td style="text-align: right;"&gt;144 B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Even though the performance and memory improvements are slight (nano-seconds and bytes), if your application is making &lt;code&gt;heavy use of FormattableString&lt;/code&gt; to format strings to specific cultures, then there are gains to be had by converting to using &lt;code&gt;String.Create&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/performance-string-create-vs-formattablestring.htm"&gt;Performance: string.Create vs FormattableString&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;176: 06-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter</id>
		<title>Manually passing parameters to a middleware component</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter" />
		<updated>2022-10-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;It is possible to &lt;code&gt;manually pass parameters to a middleware component&lt;/code&gt; when configuring the component and middleware pipeline on startup. &lt;em&gt;Manually passed parameters&lt;/em&gt; can be used in conjunction with parameters provided by the &lt;em&gt;dependency injection&lt;/em&gt; container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="middleware-configuration"&gt;Middleware configuration&lt;/h2&gt;
&lt;p&gt;In the below examples, to demonstrate a parameter provided by the DI container, a simple &lt;em&gt;ApplicationConfiguration&lt;/em&gt; class has been configured with the dependency injection container as &lt;em&gt;transient&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient(typeof(ApplicationConfiguration));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="distinct-parameters"&gt;Distinct parameters&lt;/h3&gt;
&lt;p&gt;If a middleware component has &lt;code&gt;parameters which are of distinct types&lt;/code&gt; then when adding the component to the middleware pipeline, the parameters can be specified in &lt;code&gt;any order&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below, the &lt;em&gt;DistinctParamMiddleware&lt;/em&gt; constructor has distinct types as parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DistinctParamMiddleware 
{
    private readonly int _version;
    private readonly string _name;
    private readonly ApplicationConfiguration _setup;
    private readonly RequestDelegate _next;

    // all distinct parameters
    public DistinctParamMiddleware(RequestDelegate next, string name, 
        int version, ApplicationConfiguration setup)
    {
        _version = version;
        _name = name;
        _setup = setup;
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        Console.WriteLine($&amp;quot;In {nameof(DistinctParamMiddleware)} with&amp;quot; +
            $&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

        await _next(context);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parameters can manually be passed in when using the &lt;code&gt;UseMiddleware&lt;/code&gt; method on startup, and because the parameter types are distinct, the manually supplied parameters can be passed in any order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;DistinctParamMiddleware&amp;gt;( 1, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, &lt;code&gt;RequestDelegate&lt;/code&gt; and &lt;code&gt;ApplicationConfiguration&lt;/code&gt; are supplied from the &lt;em&gt;dependency injection container&lt;/em&gt;, while the &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; parameters are supplied &lt;code&gt;manually&lt;/code&gt;. Even though the constructor has the &lt;em&gt;string parameter&lt;/em&gt; specified first, and then the &lt;em&gt;int parameter&lt;/em&gt;, when invoking the &lt;em&gt;UseMiddleware&lt;/em&gt; method, the values are not supplied in that order.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="non-distinct-parameters"&gt;Non-distinct parameters&lt;/h3&gt;
&lt;p&gt;When dealing with a middleware component which does &lt;code&gt;not have parameters which are of distinct types&lt;/code&gt;, then the parameter values need to be supplied in order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DuplicateTypeParamMiddleware
{
	private readonly ApplicationConfiguration _setup;
	private readonly RequestDelegate _next;
	private readonly string _name;
	private readonly string _version;

    // two string parameters
	public DuplicateTypeParamMiddleware(RequestDelegate next, string name, 
        string version, ApplicationConfiguration setup)
	{
		_setup = setup;
		_next = next;
		_name = name;
		_version = version;
	}

	public async Task Invoke(HttpContext context)
	{
		Console.WriteLine($&amp;quot;In {nameof(DuplicateTypeParamMiddleware)} with&amp;quot; +
			$&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

		await _next(context);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As there are two &lt;code&gt;string parameters&lt;/code&gt;, the first string value supplied is assigned to the &lt;em&gt;name&lt;/em&gt; parameter, and the second string value supplied is assigned to the &lt;em&gt;version&lt;/em&gt; parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Correct
app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;MiddlewareParamDemo&amp;quot;, &amp;quot;2&amp;quot;);

// Incorrect
// app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;2&amp;quot;, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This functionality is especially useful in cases when a value determined at runtime (for example, &lt;em&gt;application startup datetime&lt;/em&gt;) needs to be passed into middleware - having the ability to manually pass the value in instead of creating new entities to hold the values, and registering them with the dependency injection container, can save time and simplify code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/middleware/middleware-8/Program.cs"&gt;Inject dependency to your middleware class manually&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;175: 05-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run</id>
		<title>Map all urls with IApplicationBuilder.Run</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run" />
		<updated>2022-10-04T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method on the &lt;code&gt;WebApplication&lt;/code&gt; (which implements &lt;em&gt;IApplicationBuilder&lt;/em&gt;) can be used to map &lt;strong&gt;any and all&lt;/strong&gt; urls to the specific delegate.&lt;/p&gt;
&lt;p&gt;This can be leveraged in the case where the api doesn't expose any functional endpoints (such as with a &lt;em&gt;Background Service&lt;/em&gt;) to always display a consistent message to the caller.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="root-endpoint"&gt;Root endpoint&lt;/h2&gt;
&lt;p&gt;Usually when a web application doesn't expose any endpoints, the root endpoint might be mapped so when browsing to the url, a message is returned to at least inform the caller that the service is up and running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;/&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to &lt;code&gt;/&lt;/code&gt; will display:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The downside of this approach, is that if the user browses to any URL other than &lt;code&gt;/&lt;/code&gt;, nothing will be returned. For example, browsing to &lt;code&gt;/api&lt;/code&gt; just returns a blank page.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="run-method"&gt;Run method&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method can be leveraged to map a &lt;em&gt;delegate&lt;/em&gt; to &lt;strong&gt;all&lt;/strong&gt; endpoints:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.Run(async context =&amp;gt;
{
   await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, browsing to &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/api&lt;/code&gt; or &lt;strong&gt;any&lt;/strong&gt; other url, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, no matter the endpoint called - the &lt;code&gt;same message&lt;/code&gt; is returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="endpoint-override"&gt;Endpoint override&lt;/h2&gt;
&lt;p&gt;A word of warning - using the &lt;code&gt;Run&lt;/code&gt; method will cause the specific delegate to be called on all endpoints - even if another endpoint has specifically been defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;hello&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;World&amp;quot;);
});

app.Run(async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, browsing to &lt;code&gt;/hello&lt;/code&gt; will return &lt;code&gt;Sample application - no endpoints exposed&lt;/code&gt; and &lt;strong&gt;NOT&lt;/strong&gt; &lt;code&gt;World&lt;/code&gt; - the &lt;em&gt;Run&lt;/em&gt; method delegate overrides all over endpoint delegates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not a technique to be used for every application, but in the cases where the application is running as a background service (for example) which doesn't expose any specific endpoints, this technique can be leveraged to always display &lt;em&gt;something&lt;/em&gt; to the user.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/application-environment/Program.cs"&gt;Application Environment&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;174: 04-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses</id>
		<title>Obtaining a list of app URLs</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses" />
		<updated>2022-10-03T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IServerAddressesFeature&lt;/code&gt; or &lt;code&gt;IServer&lt;/code&gt; implementations can be used to get a list of URLs your application is responding to. In a landscape with a large number of applications which serve on multiple URLs, this could be leveraged to easily self-document all URLs currently in use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-urls"&gt;Multiple urls&lt;/h2&gt;
&lt;p&gt;For the samples below, the application has been configured to use multiple urls using the &lt;code&gt;UseUrls&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.WebHost.UseUrls(&amp;quot;http://*:5096;http://*:5097;http://localhost:5098&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we had a &lt;em&gt;&amp;quot;hello&amp;quot;&lt;/em&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/hello&amp;quot;, () =&amp;gt;
{
    return &amp;quot;world&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would get a &lt;em&gt;&amp;quot;world&amp;quot;&lt;/em&gt; response by browsing to any of the below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://localhost:5096/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5097/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5098/hello&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="address-list"&gt;Address list&lt;/h2&gt;
&lt;h3 id="iserveraddressesfeature"&gt;IServerAddressesFeature&lt;/h3&gt;
&lt;p&gt;The first method to get a list of addresses is by casting the &lt;code&gt;WebApplication&lt;/code&gt; instance to &lt;code&gt;IApplicationBuilder&lt;/code&gt; and leveraging the &lt;em&gt;ServerFeatures&lt;/em&gt; method available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// app is obtained from var app = builder.Build();
// in this example, serverAddress is a free variable
var serverAddress = (app as IApplicationBuilder)
    .ServerFeatures.Get&amp;lt;IServerAddressesFeature&amp;gt;();

app.MapGet(&amp;quot;/addresses&amp;quot;, (context) =&amp;gt;
{
    // get all addresses and output
    foreach(var address in serverAddress.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="iserver"&gt;IServer&lt;/h3&gt;
&lt;p&gt;When &lt;code&gt;IApplicationBuilder&lt;/code&gt; is not available (outside of application startup), the information is also available by injecting &lt;code&gt;IServer&lt;/code&gt; into the required constructor or delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/iserver&amp;quot;, (HttpContext context, IServer server) =&amp;gt;
{
    // get the address from IServer instead of IApplicationBuilder
    // otherwise everything else is the same
    var addressFeature = server.Features.Get&amp;lt;IServerAddressesFeature&amp;gt;();

    foreach (var address in addressFeature.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;We've looked at two different ways to get a list of addresses the application is serving on. For most applications, this might never be useful as most applications serve on a single address. However in the case where there &lt;em&gt;are&lt;/em&gt; multiple addresses, this could be used to self document and easily keep track of application's addresses.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/features/features-server-addresses"&gt;Server Addresses Feature&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/features/features-server-addresses-2"&gt;Server Addresses Feature - 2&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;173: 03-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>