<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-07-14T04:30:17Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/14-dbcontext-pooling</id>
		<title>Entity Framework DbContext Pooling</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/14-dbcontext-pooling" />
		<updated>2022-07-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework Core's &lt;code&gt;DbContext pooling&lt;/code&gt; functionality can be used to improve the performance of an application.&lt;/p&gt;
&lt;p&gt;While generally a lightweight object, each context instance does require some internal setup of various services, which does have an overhead. &lt;code&gt;Context pooling&lt;/code&gt;, as the name implies, create a pool of DbContext instances, setup during startup of the application and reused, thus paying the setup cost only once.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="configuration"&gt;Configuration&lt;/h2&gt;
&lt;p&gt;Configuring an application to use &lt;code&gt;DbContext pooling&lt;/code&gt; instead of the non-pooling option is incredibly simple - in fact it requires just one small change to the usual DbContext setup.&lt;/p&gt;
&lt;p&gt;On startup of an application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Default non-pooling configuration&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDbContext&amp;lt;DemoContext&amp;gt;(o =&amp;gt; o
    .UseSqlServer(builder.Configuration.GetConnectionString(&amp;quot;DemoContext&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DbContext pooling configuration&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDbContextPool&amp;lt;DemoContext&amp;gt;(o =&amp;gt; o
    .UseSqlServer(builder.Configuration.GetConnectionString(&amp;quot;DemoContext&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead of the &lt;code&gt;AddDbContext&lt;/code&gt; method being called, the &lt;code&gt;AddDbContextPool&lt;/code&gt; method is called - thats all the configuration required.&lt;/p&gt;
&lt;p&gt;The default pool size can also be manually specified as part of the &lt;em&gt;AddDbContextPool&lt;/em&gt; call (with the default being 1024 in EF Core 6.0 and 128 in previous versions)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage is &lt;code&gt;exactly the same&lt;/code&gt; awith our without the context pooling - inject the application &lt;em&gt;DbContext&lt;/em&gt; (DemoContext in the above examples) into the relevent constructor and use it as per normal.&lt;/p&gt;
&lt;p&gt;Entity Framework will internally handle everything related to the pooling functionality.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;For the benchmarks, we have a database table with &lt;code&gt;50&lt;/code&gt; records, and will be comparing retrieving a single row (using the primary key) using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Manually created &lt;code&gt;DbContext&lt;/code&gt; instance each time&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;DbContext&lt;/code&gt; retrieved from the context pool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the below code, as dependency injection was not used, &lt;code&gt;PooledDbContextFactory&lt;/code&gt; is used to control getting an instance of a DbContext from the pool:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
private DbContextOptions&amp;lt;DemoContext&amp;gt; _options;
private PooledDbContextFactory&amp;lt;DemoContext&amp;gt; _poolingFactory;

public Benchmarks()
{
    // confiture the dbcontext options
    _options = new DbContextOptionsBuilder&amp;lt;DemoContext&amp;gt;()
        .UseSqlServer(&amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFPool;Integrated Security=True&amp;quot;)
        .Options;

    // setup the pooling factory using the options
    _poolingFactory = new PooledDbContextFactory&amp;lt;DemoContext&amp;gt;(_options);
}

[Benchmark]
public Song WithoutContextPooling()
{
    // new DbContext using the options
    using var context = new DemoContext(_options);

    return context.Songs.First(s =&amp;gt; s.Id == 1);
}

[Benchmark]
public Song WithContextPooling()
{
    // new DbContext using the PooledDbContextFactory which uses the options
    using var context = _poolingFactory.CreateDbContext();

    return context.Songs.First(s =&amp;gt; s.Id == 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;WithoutContextPooling&lt;/td&gt;
&lt;td style="text-align: right;"&gt;701.3 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.09 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;147.42 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;96 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithContextPooling&lt;/td&gt;
&lt;td style="text-align: right;"&gt;124.9 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.15 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.02 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.4648&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;context pooling results in a 5.5x speed improvement&lt;/code&gt; and &lt;code&gt;10x memory improvement!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Improvements such as the ones shown above in the benchmarks above might not be applicable in every application and use case - however my recommendation is to &lt;code&gt;default to using DbContext pooling&lt;/code&gt;. If performance is not where it should be, then benchmark the two options and revert to the option with the best performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics?tabs=with-di%2Cwith-constant#dbcontext-pooling"&gt;DbContext pooling&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;116: 14-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/08-length-pattern-matching</id>
		<title>String null or empty using pattern matching</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/08-length-pattern-matching" />
		<updated>2022-07-14T00:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pattern matching&lt;/code&gt; syntax can be used to check the nullability and length of a string, instead of the traditional &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; method - with interesting (and promising) performance benchmarks!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="isnullorempty"&gt;IsNullOrEmpty&lt;/h2&gt;
&lt;p&gt;Usually the &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; method is used to check if a specific string has a value (other than null or empty) - a string is passed in and a bool value is returned.&lt;/p&gt;
&lt;p&gt;Consider the following method which uses &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void IsStringNullOrEmpty(string value)
{ 
    if (!string.IsNullOrEmpty(value))
    {
        Console.WriteLine($&amp;quot;Using 'IsNullOrEmpty' the '{value}' is NOT empty or null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the method is called with three different values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string checkValue = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = &amp;quot;&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = null;
IsStringNullOrEmpty(checkValue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, only one value triggers an output to the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;    Using 'IsNullOrEmpty' the value 'www.alwaysdeveloping.net' is NOT empty or null
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="pattern-matching"&gt;Pattern Matching&lt;/h2&gt;
&lt;p&gt;However, instead of this, &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; the following &lt;code&gt;pattern matching&lt;/code&gt; syntax could be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    value is { Length: &amp;gt; 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This checks if the &lt;em&gt;value&lt;/em&gt; variable has a value (not null) and has a length greater than zero.&lt;/p&gt;
&lt;p&gt;Again, consider the following method which uses &lt;code&gt;pattern matching&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void IsStringNullOrEmpty(string value)
{
    if (value is { Length: &amp;gt; 0 })
    {
        Console.WriteLine($&amp;quot;Using 'pattern matching' the value '{value}' is NOT empty or null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the method is called with three different values (the same values as above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string checkValue = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = &amp;quot;&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = null;
IsStringNullOrEmpty(checkValue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, as expected, the same values as when using &lt;code&gt;IsNullOrEmpty&lt;/code&gt; are picked up as valid or not:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;    Using 'pattern matching' the value 'www.alwaysdeveloping.net' is NOT empty or null
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;So there doesn't appear to be any difference in the output of the two methods. Next let's see how each performs using BenchmarkDotNet.&lt;/p&gt;
&lt;p&gt;The two different methods were compared, using the same three values as above: a string with a &lt;code&gt;value&lt;/code&gt;, and &lt;code&gt;empty&lt;/code&gt; string and a &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[MemoryDiagnoser]
public class Benchmarks
{
    [Params(&amp;quot;alwaysdeveloping.net&amp;quot;, &amp;quot;&amp;quot;, null)]
    public string? strValue { get; set; }

    [Benchmark]
    public void IsNullOrEmpty()
    {
        _ = !string.IsNullOrEmpty(strValue);
    }

    [Benchmark]
    public void PatternMatching()
    {
        _ = strValue is { Length: &amp;gt; 0 };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;strValue&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2562 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0367 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0307 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2615 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2592 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0203 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0190 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2627 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0158 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0148 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0123 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0133 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0150 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0144 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0163 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;alwaysdeveloping.net&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0355 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0298 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0279 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0296 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;alwaysdeveloping.net&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0093 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0113 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0105 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0056 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the result, when the string is &lt;code&gt;null or empty performance is pretty much equivalent&lt;/code&gt;, however when the string &lt;code&gt;has a value, pattern matching is about 4x faster&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;pattern matching&lt;/code&gt; syntax is definitely interesting and intriguing, however is definitely not as intuitive or informative to the developer as to what it does. If micro-optimization is required, this is definitely something to look into, however for most applications the performance improvement would be unnoticeable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1545094497138360323"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;133: 08-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/13-sql-schema-compare</id>
		<title>Visual Studio Schema Compare</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/13-sql-schema-compare" />
		<updated>2022-07-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Visual Studio has a built in feature called &lt;code&gt;Schema Compare&lt;/code&gt; which easily allows for the comparing of two SQL database schemas and the generation of a script to bring them in sync.&lt;/p&gt;
&lt;p&gt;In the past I've had to perform database schema comparisons numerous times (admittedly the majority of these times have been in the fairly distant past when proper CI/CD tools and DevOps practices were not in place) - and there were limited tools available. &lt;code&gt;Schema Compare&lt;/code&gt; contains the all the features I've required in the past in an incredibly simple to use package.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;The feature is available through the installation of the &lt;code&gt;SQL Server Data Tools&lt;/code&gt; Visual Studio component. One can use the &lt;em&gt;Visual Studio Installer&lt;/em&gt; to confirm if the component is installed or not:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open &lt;em&gt;Visual Studio Installer&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Modify&lt;/em&gt; on the relevent Visual Studio installation&lt;/li&gt;
&lt;li&gt;Select the &lt;em&gt;Individual components&lt;/em&gt; tab&lt;/li&gt;
&lt;li&gt;Search for "sql server data tools"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/installation.png" alt="SQL Server Data Tools"&gt;&lt;/p&gt;
&lt;p&gt;Once installed, the feature will be available under &lt;code&gt;Tools -&amp;gt; SQL Server -&amp;gt; New Schema Comparison&lt;/code&gt; in Visual Studio:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/menu-feature.png" alt="New Schema Comparison"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage of the feature is straightforward - when opened you will be presented with two drop down lists, one to select the &lt;em&gt;Source&lt;/em&gt; database and one to select the &lt;em&gt;Target&lt;/em&gt; database:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/source-target.png" alt="Source and Target selection"&gt;&lt;/p&gt;
&lt;p&gt;A screen with the traditional database connection settings is presented when adding the &lt;em&gt;Source&lt;/em&gt; and &lt;em&gt;Target&lt;/em&gt; database:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/connection.png" alt="Source and Target selection"&gt;&lt;/p&gt;
&lt;p&gt;Once the &lt;em&gt;Source&lt;/em&gt; and &lt;em&gt;Target&lt;/em&gt; databases have been set, the &lt;code&gt;Compare&lt;/code&gt; button becomes available - clicking on this will perform the database comparison.&lt;/p&gt;
&lt;p&gt;A list of differences between the databases will be presented, drilling down and clicking on the specific item will then show the specific difference.&lt;/p&gt;
&lt;p&gt;In the example below, there are differences between the &lt;em&gt;Song&lt;/em&gt; tables in the two databases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;em&gt;Length&lt;/em&gt; discrepancy on the &lt;em&gt;Artist&lt;/em&gt; column&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;Nullability&lt;/em&gt; discrepancy on the &lt;em&gt;LengthInSeconds&lt;/em&gt; column&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clicking on the &lt;em&gt;Length&lt;/em&gt; item, displays the specific difference:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/differences.png" alt="List of differences"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="application"&gt;Application&lt;/h2&gt;
&lt;p&gt;Once the differences have been identified, the next step is bring the &lt;em&gt;Destination&lt;/em&gt; database in line with the &lt;em&gt;Source&lt;/em&gt; database.&lt;/p&gt;
&lt;p&gt;This can be done by &lt;code&gt;updating the target database directly&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/update.png" alt="Update target"&gt;&lt;/p&gt;
&lt;p&gt;This may not always be possible or feasible, so another option is to have a &lt;code&gt;script generated&lt;/code&gt; to align the &lt;em&gt;Target&lt;/em&gt; to the &lt;em&gt;Source&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/script.png" alt="Generate Script"&gt;&lt;/p&gt;
&lt;p&gt;The script generated by the tool looks as follows (abbreviated to include only the relevent portion):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;--
--
-- some preamble removed for brevity
--
--
USE [$(DatabaseName)];


GO
PRINT N'Altering Table [dbo].[Song]...';


GO
ALTER TABLE [dbo].[Song] ALTER COLUMN [Artist] NVARCHAR (500) NOT NULL;

ALTER TABLE [dbo].[Song] ALTER COLUMN [LengthInSeconds] INT NULL;


GO
PRINT N'Update complete.';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default all differences are included in the &lt;code&gt;Update&lt;/code&gt; or &lt;code&gt;Generate Script&lt;/code&gt; but it is possible to uncheck specific differences if you wish to exclude them from the update.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;In a perfect world this feature is never required as DevOps practices ensure that a dev, test and production database are always in sync (or can easily be brought in sync). However in the real world, differences sometimes occur - sometimes its easier to sync a database schema from production to dev instead of creating the dev database from scratch, for example.&lt;/p&gt;
&lt;p&gt;In these cases, the &lt;code&gt;Schema Compare&lt;/code&gt; feature will prove to be invaluable in tracking down and remedying any differences.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.sqlshack.com/how-to-compare-two-sql-databases-from-visual-studio/"&gt;How to compare two SQL databases from Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;!--?# DailyDrop ?--&gt;116: 13-07-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/12-maybenullwhen-attribute</id>
		<title>MaybeNullWhen attribute usage</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/12-maybenullwhen-attribute" />
		<updated>2022-07-12T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;MaybeNullWhen&lt;/code&gt; attribute can be used to specify that when a method returns &amp;quot;ReturnValue&amp;quot;, an &lt;code&gt;out&lt;/code&gt; parameter may be &lt;code&gt;null&lt;/code&gt; even if the corresponding type does not allow it.&lt;/p&gt;
&lt;p&gt;This is especially applicable in the &lt;code&gt;TryGet*&lt;/code&gt; methods, such as the &lt;em&gt;TryGetValue&lt;/em&gt; method on &lt;em&gt;Dictionary&lt;/em&gt;, for example.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In all the examples below, the project has been set to allow nullable types. In the csproj file, the following is set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have also defined a &lt;em&gt;Person&lt;/em&gt; class, with a single &lt;em&gt;Name&lt;/em&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Person
{
    public string Name { get; set; } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A dictionary is then created of &lt;em&gt;Person&lt;/em&gt;'s, and &lt;em&gt;id&lt;/em&gt; value set for a &lt;code&gt;person which does not exist&lt;/code&gt; in the dictionary:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var people = new Dictionary&amp;lt;int, Person&amp;gt;();

people.Add(1, new Person { Name = &amp;quot;Dave&amp;quot; });
people.Add(2, new Person { Name = &amp;quot;John&amp;quot; });
people.Add(3, new Person { Name = &amp;quot;Mike&amp;quot; });
people.Add(4, new Person { Name = &amp;quot;Chris&amp;quot; });

// This Id does not exist in the dictionary
int id = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="compiler-warning"&gt;Compiler warning&lt;/h2&gt;
&lt;p&gt;Next, we'll write a method to &lt;code&gt;TryGet&lt;/code&gt; a person out of the dictionary - the function will return &lt;code&gt;true/false&lt;/code&gt; if the dictionary contains the id, as well as having an &lt;code&gt;out&lt;/code&gt; Person parameter which will contain the &lt;em&gt;Person&lt;/em&gt; record, if found.&lt;/p&gt;
&lt;p&gt;This is a standard pattern used often by many core .NET libraries - &lt;em&gt;Dictionary&lt;/em&gt; already has a &lt;em&gt;TryGetValue&lt;/em&gt; method following this pattern, but for demo purposes we will write a custom method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// return false if the record not found in the dictionary
// return true if found AND set the out Person to the found record
public bool TryGetPerson(Dictionary&amp;lt;int, Person&amp;gt; d, int id, out Person p)
{
    // check if the dictionary contains the key
    if (!d.ContainsKey(id))
    {
        // set the out parameter value to null
        p = null;
        return false;
    }

    // set the out parameter value to the item in the dictionary
    p = d[id];
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above method will work, and performs as expected - however, the compiler gives us a warning for the line &lt;code&gt;p = null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot convert null literal to non-nullable reference type.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the code is assigning a &lt;code&gt;null&lt;/code&gt; value to the out &lt;em&gt;Person&lt;/em&gt; p object, when the parameter hasn't been marked as explicitly allowing nulls.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nullable-type"&gt;Nullable type&lt;/h2&gt;
&lt;p&gt;Let's address the warning - the compiler is telling us we are assigning a &lt;code&gt;null&lt;/code&gt; value to a &lt;code&gt;non-nullable&lt;/code&gt; type, so let's make the type &lt;code&gt;nullable&lt;/code&gt;. This is done by adding a question mark (&lt;code&gt;?&lt;/code&gt;) after the type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Person has changed to nullable, Person?
public bool TryGetPerson(Dictionary&amp;lt;int, Person&amp;gt; d, int id, out Person? p)
{
    // check if the dictionary contains the key
    if (!d.ContainsKey(id))
    {
        // set the out parameter value to null
        p = null;
        return false;
    }

    // set the out parameter value to the item in the dictionary
    p = d[id];
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Making the above update will resolve the initial warning - however the usage of the above method has now introduced another warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if(!TryGetPerson(people, id, out var person))
{
    return;
}

Console.WriteLine(person.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Console.WriteLine(person.Name);&lt;/code&gt; line of code results in the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Dereference of a possibly null reference.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler is informing us that the code is referencing the &lt;em&gt;Name&lt;/em&gt; property on a possibly null object (resulting in an exception).&lt;/p&gt;
&lt;p&gt;This can be solved by checking if &lt;em&gt;person&lt;/em&gt; is null, again using the question mark:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(person?.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="maybenullwhen-usage"&gt;MaybeNullWhen usage&lt;/h2&gt;
&lt;p&gt;Another option is, instead of making the &lt;em&gt;Person&lt;/em&gt; out parameter nullable, to make use of the &lt;code&gt;MaybeNullWhen&lt;/code&gt; attribute:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// The attribute is added to the parameter
public bool TryGetPerson(Dictionary&amp;lt;int, Person&amp;gt; d, int id, 
    [MaybeNullWhen(returnValue: false)]out Person p)
{
    // check if the dictionary contains the key
    if (!d.ContainsKey(id))
    {
        // set the out parameter value to null
        p = null;
        return false;
    }

    // set the out parameter value to the item in the dictionary
    p = d[id];
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The addition of the parameter is an indicator to the compiler that &lt;code&gt;the out Person parameter can maybe be NULL when the return value is false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The usage of the method is the same as before, but now no longer results in any warnings!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if(!TryGetPerson(people, id, out var person))
{
    return;
}

Console.WriteLine(person.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If however &lt;em&gt;person&lt;/em&gt; is reference in a path where it could be null, then the warning occurs again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if(!TryGetPerson(people, id, out var person))
{
    // person is null here
    Console.WriteLine(person.Name);

    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code snippet, &lt;em&gt;person.Name&lt;/em&gt; is being used in a path where &lt;em&gt;person&lt;/em&gt; is null (when &lt;em&gt;TryGetPerson&lt;/em&gt; returns false) - thanks to the &lt;code&gt;MaybeNullWhen&lt;/code&gt; attribute, the compiler has enough information to know this will most likely result in a null reference and so the warning occurs.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Whether writing a line of business application or a reusable library, if applicable, the &lt;code&gt;MaybeNullWhen&lt;/code&gt; attribute should be used to give more information to the compiler about the intention of the code, thus improving developer experience.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/uxlkub/nullable_types_dictionaries_and_magic/"&gt;Nullable types, dictionaries and magic&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;115: 12-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/11-initializer-expansion</id>
		<title>Expanding on an property initializer</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/11-initializer-expansion" />
		<updated>2022-07-11T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A class &lt;code&gt;property initializer can be expanded on in the class declaration&lt;/code&gt; (assuming the property type supports it, such as Dictionary) to a have additional values added.&lt;/p&gt;
&lt;p&gt;This technique (explained further below) does have fairly limited practical application and is quite niche - but it does have its place, and practical or not, is very interesting.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case"&gt;Use case&lt;/h2&gt;
&lt;p&gt;In our use case, when an exception occurs, we want to capture some generic information about the PC on which the exception occurred (machine name, operating system), as well as the actual exception.&lt;/p&gt;
&lt;p&gt;If we have an &lt;code&gt;ExceptionInformation&lt;/code&gt; class to capture all this information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static information such as the &lt;em&gt;machine name&lt;/em&gt; can be &lt;code&gt;automatically initialized&lt;/code&gt; on instantiation of an &lt;em&gt;ExceptionInformation&lt;/em&gt; instance&lt;/li&gt;
&lt;li&gt;Dynamic information such as the &lt;em&gt;exception&lt;/em&gt; must be &lt;code&gt;manually supplied&lt;/code&gt; to our capture class&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="constructor"&gt;Constructor&lt;/h3&gt;
&lt;p&gt;One way of &lt;em&gt;manually&lt;/em&gt; supplying the exception information is pass it to the &lt;code&gt;ExceptionInformation&lt;/code&gt; instance in the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ExceptionInformation
{
    // string representation of the exception
    private readonly string _exceptionString;

    // set the exception in the constructor
    public ExceptionInformation(string exceptionString)
    {
        _exceptionString = exceptionString;
    }

    // A dictionary to contain all the relevent information about the exception
    // initialize it with the information on class initialization
    public Dictionary&amp;lt;string, object&amp;gt; Configuration { get; } = 
        new Dictionary&amp;lt;string, object&amp;gt;
        {
            [&amp;quot;MachineName&amp;quot;] = Environment.MachineName,
            [&amp;quot;OsVersion&amp;quot;] = Environment.OSVersion
        };

    // override method to be able to output a representation of the class
    public override string ToString()
    {
        return $&amp;quot;{_exceptionString}{Environment.NewLine}&amp;quot; +
            $&amp;quot;{String.Join(Environment.NewLine, Configuration.Select(d =&amp;gt; $&amp;quot;{d.Key}: { d.Value}&amp;quot;))}&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usage of the class would be as follows (with an exception being forced to occur):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;try
{
    // force a divide by zero exception
    var intValue = 100;
    _ = intValue / 0;
}
catch(Exception ex)
{
    // capture the exception
    var ei = new ExceptionInformation(ex.ToString());
    Console.WriteLine(ei.ToString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;System.DivideByZeroException: Attempted to divide by zero.
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in 
    C:\Development\Projects\InitializerExpansion\Program.cs:line 5
MachineName: T800
OsVersion: Microsoft Windows NT 10.0.22000.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are other options to achieve the same result - instead of a setting the private &lt;em&gt;_exceptionString&lt;/em&gt; variable, the exception string value could have been added directly to the dictionary in the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public ExceptionInformation(string exceptionString)
{
    this.Configuration.Add(&amp;quot;ExceptionString&amp;quot;, exceptionString);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the above approaches are valid and will achieve the desired result, however another interesting approach is to &lt;em&gt;expand on the property initializer&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="initializer-expansion"&gt;Initializer expansion&lt;/h3&gt;
&lt;p&gt;The initializer can be expanded to include adding custom information to the &lt;em&gt;ExceptionInformation&lt;/em&gt; instance. Similar to how the &lt;em&gt;exceptionString&lt;/em&gt; was added to the dictionary in the constructor in the above example, except this method is more dynamic and allows for any values to be added.&lt;/p&gt;
&lt;p&gt;If we remove all references to &lt;em&gt;exceptionString&lt;/em&gt; from the &lt;em&gt;ExceptionInformation&lt;/em&gt; class, including from the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ExceptionInformation
{
    // No constructor which takes the exception
   
    // A dictionary to contain all the relevent information about the exception
    // initialize it with the information on class initialization
    public Dictionary&amp;lt;string, object&amp;gt; Configuration { get; } = 
        new Dictionary&amp;lt;string, object&amp;gt;
        {
            [&amp;quot;MachineName&amp;quot;] = Environment.MachineName,
            [&amp;quot;OsVersion&amp;quot;] = Environment.OSVersion
        };

    // override method to be able to output a representation of the class
    // Now ONLY outputs the dictionary
    public override string ToString()
    {
        return String.Join(Environment.NewLine, Configuration.Select(d =&amp;gt; $&amp;quot;{d.Key}: {d.Value}&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This usage of the class is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;try
{
    // force a divide by zero exception
    var intValue = 100;
    _ = intValue / 0;
}
catch(Exception ex)
{
    // capture the exception by expanding the Configuration initialization
    var ei = new ExceptionInformation
    {
        Configuration =
        {
            [&amp;quot;ExceptionString&amp;quot;] = ex.ToString()
            // any other data can be added here
        }
    };
    Console.WriteLine(ei.ToString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;em&gt;Configuration&lt;/em&gt; values specified when an instance of &lt;em&gt;ExceptionInformation&lt;/em&gt; is initialized, &lt;code&gt;are added&lt;/code&gt; to the values initialized internally in the class.&lt;/p&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;MachineName: T800
OsVersion: Microsoft Windows NT 10.0.22000.0
ExceptionString: System.DivideByZeroException: Attempted to divide by zero.
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in 
    C:\Development\Projects\InitializerExpansion\Program.cs:line 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One &lt;code&gt;advantage&lt;/code&gt; of the initializer expansion method, is that all data is now contained in a single place (the dictionary) and more values can be added dynamically.&lt;br /&gt;
However, on the &lt;code&gt;negative side&lt;/code&gt;, its not apparently obvious to the developer using the &lt;em&gt;ExceptionInformation&lt;/em&gt; class, that additional items can be added to the dictionary in this manner.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, this has a fairly niche use case - and even though there are other methods to do the achieve the same outcome, I find this method especially appealing. Even if I never have a practical need for it in a real application - I still find it an interesting usage of the language features.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/8BitVentilator/status/1524685108606914564"&gt;8 Bit Ventilator tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;114: 11-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/08-lowing-for-loop</id>
		<title>For loop lowering in C#</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/08-lowing-for-loop" />
		<updated>2022-07-08T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In C#, a &lt;code&gt;for loop&lt;/code&gt; is &lt;em&gt;lowered&lt;/em&gt; to a &lt;code&gt;while loop&lt;/code&gt; by the compiler.&lt;/p&gt;
&lt;p&gt;At a lower level, the &lt;code&gt;for&lt;/code&gt; loop &lt;em&gt;does not exist&lt;/em&gt; - it gets translated into a &lt;code&gt;while&lt;/code&gt; loop by the C# compiler, and then is executed as such.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="lowering"&gt;Lowering&lt;/h2&gt;
&lt;p&gt;Done by the C# compiler, &lt;code&gt;lowering&lt;/code&gt; is the process of rewriting high-level language features, into low-level language features in the &lt;em&gt;same language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are a number of C# features, which are just &lt;em&gt;syntactic sugar&lt;/em&gt; over (often) more complex lower-level features - the compiler will take the high-level feature and &lt;em&gt;lower&lt;/em&gt; it to the lower-level feature.&lt;/p&gt;
&lt;p&gt;Lowering is done for a number of reasons, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Working with high-level features, are easier and simpler to work with&lt;/li&gt;
&lt;li&gt;Optimization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is specifically about the &lt;code&gt;for&lt;/code&gt; loop, not an especially complex feature - however it is more complex than the &lt;code&gt;while&lt;/code&gt; loop, its lower-level equivalent.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="for-loop"&gt;For loop&lt;/h2&gt;
&lt;p&gt;Using &lt;a href="https://sharplab.io/"&gt;sharplab.io&lt;/a&gt;, one is able to see the lowered code the compiler generates.&lt;/p&gt;
&lt;p&gt;Here is an example of some code written in Visual Studio:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForLoopExample() 
{
    for(int i = 0; i &amp;lt; 100; i++)
    {
        Console.WriteLine(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the lowered code the compiler generates:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForLoopExample()
{
    int num = 0;
    while (num &amp;lt; 100)
    {
        Console.WriteLine(num);
        num++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see - the &lt;code&gt;for&lt;/code&gt; loop is converted to a &lt;code&gt;while&lt;/code&gt; loop!&lt;/p&gt;
&lt;p&gt;Another example, in a previous post we learnt how the &lt;em&gt;iterator section&lt;/em&gt; of a for loop could &lt;a href="https://alwaysdeveloping.net/06/30-for-multi-operations"&gt;contain multiple statements&lt;/a&gt;. Looking at the lowered code for that example, the &lt;code&gt;while&lt;/code&gt; loop is controlled only by the &lt;em&gt;condition section&lt;/em&gt; of the &lt;code&gt;for&lt;/code&gt; loop - this is why this portion of the for loop can only contain one statement, while the other sections can contain multiple.&lt;/p&gt;
&lt;p&gt;Original C# code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForLoopExample2() 
{
    int countDown = 100;
    for(int i = 0; i &amp;lt; 100; i++, countDown--)
    {
        Console.WriteLine(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the lowered code the compiler generates:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForLoopExample2()
{
    int num = 100;
    int num2 = 0;
    while (num2 &amp;lt; 100)
    {
        Console.WriteLine(num2);
        num2++;
        num--;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="foreach"&gt;Foreach&lt;/h2&gt;
&lt;p&gt;Just for reference, the &lt;code&gt;foreach&lt;/code&gt; does not operate the same way as the &lt;code&gt;for&lt;/code&gt; loop - even though both iterate through a list of items, they do it very differently.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Foreach&lt;/code&gt; works using the &lt;em&gt;&lt;a href="https://alwaysdeveloping.net/03/03-getenumerator"&gt;GetEnumerator&lt;/a&gt;&lt;/em&gt; method on a class, and is not lowered to a &lt;code&gt;while&lt;/code&gt; loop:&lt;/p&gt;
&lt;p&gt;Original C# code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForEachLoopExample() 
{
    var list = new List&amp;lt;int&amp;gt; { 1, 2, 3, 4, 5, };

    foreach (var item in list)
    {
        Console.WriteLine(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the lowered code the compiler generates:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForEachLoopExample()
{
    List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();
    list.Add(1);
    list.Add(2);
    list.Add(3);
    list.Add(4);
    list.Add(5);
    List&amp;lt;int&amp;gt; list2 = list;
    List&amp;lt;int&amp;gt;.Enumerator enumerator = list2.GetEnumerator();
    try
    {
        while (enumerator.MoveNext())
        {
            int current = enumerator.Current;
            Console.WriteLine(current);
        }
    }
    finally
    {
        ((IDisposable)enumerator).Dispose();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While the developer written code for a &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;foreach&lt;/code&gt; loop are fairly similar - the lowered code for the &lt;code&gt;foreach&lt;/code&gt; is a bit more complex than a simple &lt;code&gt;while&lt;/code&gt; loop.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this may not be something one has to worry or think about when coding - its always good to have a general knowledge of how the compiler works, and what its doing (even at a high level), and how the code written impacts the lowered code which gets executed.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://sharplab.io/"&gt;sharplab.io&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;!--?# DailyDrop ?--&gt;113: 08-07-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/07-implicit-type-conversion</id>
		<title>Type conversion with the implicit operator</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/07-implicit-type-conversion" />
		<updated>2022-07-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;implicit operator&lt;/code&gt; keywords can be used to define a method to perform an implicit conversion from one type to another.&lt;/p&gt;
&lt;p&gt;Effectively this is a mapper function, which is implicitly invoked without any special syntax - making its usage automatic and more natural.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In this simple example, we have two types, &lt;em&gt;SourceType&lt;/em&gt; and &lt;em&gt;DestinationType&lt;/em&gt; - &lt;em&gt;SourceType&lt;/em&gt; contains an &lt;strong&gt;int&lt;/strong&gt; field, while &lt;em&gt;DestinationType&lt;/em&gt; contains a &lt;strong&gt;string&lt;/strong&gt; field. We require the ability to convert an instance of &lt;em&gt;SourceType&lt;/em&gt; to an instance of &lt;em&gt;DestinationType&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SourceType
{
    public int Value { get; set; }
}

public class DestinationType
{
    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="mapper"&gt;Mapper&lt;/h2&gt;
&lt;p&gt;A conversion between the two types can be performed with a &lt;em&gt;mapper&lt;/em&gt; method. There are a number of places this method could be defined, including (but not limited to):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a method inside source type&lt;/li&gt;
&lt;li&gt;the constructor of the destination type&lt;/li&gt;
&lt;li&gt;a method outside of the source or destination types&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SourceType
{
    // 1. Method inside SourceType to return
    // an instance of DestinationType
    DestinationType ToDestinationType()
    {
        return new DestinationType
        {
            Name = this.Value.ToString()
        };
    }

    public int Value { get; set; }
}

public class DestinationType
{
    public DestinationType() { }

    // 2. Constructor which takes a parameter of SourceType
    public DestinationType(SourceType sourceType)
    {
        this.Name = sourceType.Value.ToString();
    }

    public string Name { get; set; }
}

// 3. External method to do the mapping between SourceType 
// and DestinationType
DestinationType SourceToDestinationMapper(SourceType sourceType)
{
    return new DestinationType
    {
        Name = sourceType.Value.ToString()
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any of the above will work, however they are required to be invoked explicitly for the conversion to take place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="implicit"&gt;Implicit&lt;/h2&gt;
&lt;p&gt;Instead of one of the mapper methods described above, another technique is to use the &lt;code&gt;implicit operator&lt;/code&gt; keywords. Effectively this is a mapper method - but is implicitly invoked under certain conditions, instead of having to explicitly be invoked as with a mapper method.&lt;/p&gt;
&lt;p&gt;The operator is added to the &lt;em&gt;SourceType&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SourceType
{
    public int Value { get; set; }

    public static implicit operator DestinationType(SourceType t) =&amp;gt; 
        new DestinationType { Name = t.Value.ToString() };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the operator has the same logic as the mapper methods above - a &lt;em&gt;SourceType&lt;/em&gt; is accepted as a parameter, and a &lt;em&gt;DestinationType&lt;/em&gt; is returned.&lt;/p&gt;
&lt;p&gt;Next'll we'll look at how the operator is implicitly invoked.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;There are a number of scenarios in which the implicit operator is automatically invoked.&lt;/p&gt;
&lt;p&gt;Assigning a &lt;em&gt;SourceType&lt;/em&gt; to a &lt;em&gt;DestinationType&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var source = new SourceType { Value = 100 };

// implicit operator code is called for this line
DestinationType destination = source;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;em&gt;cast&lt;/em&gt; from one type to the other:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var source = new SourceType { Value = 100 };

// implicit operator code is called for this line
// x is of type DestinationType
var x = (DestinationType)source;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling a method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var source = new SourceType { Value = 100 };

// pass SourceType to the method
DoProcessing(source);

// method accepts DestinationType
// implicit operator code is called for this line
public void DoProcessing(DestinationType dest)
{
    Console.WriteLine($&amp;quot;Doing processing on '{dest.Name}'&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, no mapper functions are required to be called - the conversion &lt;em&gt;implicitly&lt;/em&gt; occurs, resulting in cleaner code.&lt;/p&gt;
&lt;h2 id="limitations"&gt;Limitations&lt;/h2&gt;
&lt;p&gt;One limitation of this &lt;code&gt;implicit operator&lt;/code&gt; keywords, is that is not considered by the &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;as&lt;/code&gt; operators. A &lt;em&gt;cast&lt;/em&gt; should be invoked to the explicit conversion.&lt;/p&gt;
&lt;p&gt;The following will &lt;strong&gt;NOT&lt;/strong&gt; compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// NOT ALLOWED
var destination = source as DestinationType;
Console.WriteLine(destination.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Personally, I find this simplifies the usage and readability of the code and is something I will try to implement more where it makes sense.&lt;br /&gt;
One potentially drawback of the &lt;code&gt;implicit operator&lt;/code&gt;, depending on the specific code architecture, is that &lt;em&gt;SourceType&lt;/em&gt; now requires a reference to &lt;em&gt;DestinationType&lt;/em&gt; which may not make sense or be practical (if &lt;em&gt;SourceType&lt;/em&gt; is from a 3rd party for example).&lt;/p&gt;
&lt;p&gt;As always, consider your own use case, and which method will work best for that use case.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators"&gt;User-defined conversion operators (C# reference)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;112: 07-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/06-sql-2022-enhancements</id>
		<title>T-SQL enhancements in SQL Server 2022</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/06-sql-2022-enhancements" />
		<updated>2022-07-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;There are a number of very useful T-SQL enhancements coming with SQL Server 2022 (currently in preview). Some of these include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;STRING_SPLIT&lt;/code&gt; - splits a string into rows of substrings, based on a specified separator character, now with &lt;strong&gt;ordinal support&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GREATEST/LEAST&lt;/code&gt; - Similar to &lt;em&gt;MAX/MIN&lt;/em&gt;, but operates across columns instead of across rows&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GENERATE_SERIES&lt;/code&gt; - Produces a set-based sequence of numeric values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JSON functions&lt;/code&gt; - Including functions to test whether a string is valid JSON, construct a JSON object and construct a JSON array&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DATE_BUCKET&lt;/code&gt; - Returns the date-time value corresponding to the start of each date-time bucket from the timestamp defined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below we'll explore some of the enhancements I will find most useful (based on my previous experiences and requirements), while additional details on the other enhancements can be found in the references below.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="string_split"&gt;STRING_SPLIT&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;SPLIT_STRING&lt;/code&gt; function, first introduced with SQL Server 2016, allows for the splitting a string into rows of substrings - especially useful for developers making extensive use of stored procedures (for example, with SQL Server Reporting Services)&lt;/p&gt;
&lt;p&gt;For example, executing the following SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * from STRING_SPLIT('one,two,three,four,five', ',')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;value
-----------------------
one
two
three
four
five
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;Coming in SQL Server 2022, is the ability to &lt;em&gt;determine the nth item of the list&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, executing the following SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * from STRING_SPLIT('one,two,three,four,five', ',' , 1) WHERE ordinal = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;value                   ordinal
----------------------- --------------------
three                   3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An additional parameter, &lt;em&gt;enable_ordinal&lt;/em&gt; is available which will return an &lt;em&gt;ordinal&lt;/em&gt; column - which can then be used as part of a WHERE clause.&lt;/p&gt;
&lt;p&gt;One limitation of the &lt;code&gt;SPLIT_STRING&lt;/code&gt; remains, and that is that the delimiter can only be a single character, and not a string.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="greatestleast"&gt;GREATEST/LEAST&lt;/h2&gt;
&lt;p&gt;The new &lt;code&gt;GREATEST and LEAST&lt;/code&gt; functions, are similar to the existing  &lt;em&gt;MAX and MIN&lt;/em&gt; functions, but operates across columns instead of across rows.&lt;/p&gt;
&lt;p&gt;Consider the following &lt;em&gt;VisitorsPerMonth&lt;/em&gt; table which stores the number of unique visitors to a website, per month, per year.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * FROM VisitorsPerMonth

Year        Jan         Feb         March
----------- ----------- ----------- -----------
2020        435         643         763
2021        893         1121        1327
2022        1923        2107        2782

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use &lt;em&gt;Max&lt;/em&gt; to determine &lt;em&gt;maximum number of visitors in any January&lt;/em&gt; (a max across rows):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT MAX(Jan)
FROM VisitorsPerMonth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, what if we wanted the &lt;em&gt;max number of visitors in any particular month in a year&lt;/em&gt; - this requires an operation across columns, which is where the &lt;code&gt;GREATEST&lt;/code&gt; function comes into play.&lt;/p&gt;
&lt;p&gt;A number of &lt;em&gt;columns&lt;/em&gt; are supplied to the function, and the greatest value will be returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT Year, GREATEST(Jan, Feb, March) as HighestVisitors
FROM VisitorsPerMonth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;Year        HighestVisitors
----------- ---------------
2020        763
2021        1327
2022        2782
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now know how many visitors the site had in its most popular month in each year.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generate_series"&gt;GENERATE_SERIES&lt;/h2&gt;
&lt;p&gt;This new function produces a set-based sequence of numeric values based on specified &lt;em&gt;START&lt;/em&gt;, &lt;em&gt;STOP&lt;/em&gt; and &lt;em&gt;STEP&lt;/em&gt; values.&lt;/p&gt;
&lt;p&gt;The usage is fairly straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT value FROM GENERATE_SERIES(START = 1, STOP = 3);
SELECT value FROM GENERATE_SERIES(START = 0, STOP = 25, STEP = 5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which results in the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;value
-----------
1
2
3

value
-----------
0
5
10
15
20
25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If no &lt;em&gt;STEP&lt;/em&gt; value is specified, a value of &lt;strong&gt;1&lt;/strong&gt; is used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As a C# developer, in recent years, my focus has been more on using Entity Framework Core and less on raw SQL usage - however, knowledge of these enhancement will come in useful when the need arises to do raw SQL (a custom query through EF, or Dapper, or a report stored procedure, for example).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mssqltips.com/sqlservertip/7265/sql-server-2022-t-sql-enhancements/"&gt;My Favorite T-SQL Enhancements in SQL Server 2022&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/date-bucket-transact-sql?view=sql-server-ver16"&gt;DATE_BUCKET (Transact-SQL)&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/json-object-transact-sql?view=sql-server-ver16"&gt;JSON_OBJECT (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;111: 06-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/05-getdebugview</id>
		<title>View config values with GetDebugView</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/05-getdebugview" />
		<updated>2022-07-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;All configuration values for an aapplication, as well &lt;code&gt;as their source&lt;/code&gt;, can be viewed with the &lt;code&gt;GetDebugView&lt;/code&gt; method on &lt;em&gt;IConfigurationRoot&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;While this core functionality has been available since .NET Core 3, enhancements are also coming with .NET7 (currently in preview) to allow for confidential values to be masked.&lt;/p&gt;
&lt;p&gt;All of this in more detail below.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getdebugview-current"&gt;GetDebugView: Current&lt;/h2&gt;
&lt;p&gt;To retrieve the configuration information is fairly straightforward - all one needs is the &lt;em&gt;IConfiguration&lt;/em&gt; implementation.&lt;/p&gt;
&lt;p&gt;The below uses top-level statements and minimal API to expose a &lt;em&gt;config&lt;/em&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject IConfiguration from dependency injection container
app.MapGet(&amp;quot;/config&amp;quot;, (IConfiguration config) =&amp;gt;
{
    // convert to IConfigurationRoot
    var root = config as IConfigurationRoot;

    return root.GetDebugView();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With a &lt;em&gt;appsettings.json&lt;/em&gt; file which contains the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;Logging&amp;quot;: {
    &amp;quot;LogLevel&amp;quot;: {
      &amp;quot;Default&amp;quot;: &amp;quot;Information&amp;quot;,
      &amp;quot;Microsoft.AspNetCore&amp;quot;: &amp;quot;Warning&amp;quot;
    }
  },
  &amp;quot;AllowedHosts&amp;quot;: &amp;quot;*&amp;quot;,
  &amp;quot;ServiceCredentials&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;admin123&amp;quot;,
    &amp;quot;password&amp;quot; : &amp;quot;admin456&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the endpoint will return the following &lt;em&gt;relevent configuration values&lt;/em&gt; (along with numerous other system environment variables):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;AllowedHosts=* (JsonConfigurationProvider for 'appsettings.json' (Optional))
ASPNETCORE_ENVIRONMENT=Development (EnvironmentVariablesConfigurationProvider Prefix: '')
Logging:
  LogLevel:
    Default=Information (JsonConfigurationProvider for 'appsettings.Development.json' (Optional))
    Microsoft.AspNetCore=Warning (JsonConfigurationProvider for 'appsettings.Development.json' (Optional))
ServiceCredentials:
  password=admin456 (JsonConfigurationProvider for 'appsettings.json' (Optional))
  username=admin123 (JsonConfigurationProvider for 'appsettings.json' (Optional))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The configuration from the &lt;em&gt;appsettings.json&lt;/em&gt; config file are displayed, with the corresponding provider source (&lt;em&gt;JsonConfigurationProvider&lt;/em&gt;) as well as a configuration value sourced from the environment variable provider (&lt;em&gt;EnvironmentVariablesConfigurationProvider&lt;/em&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="secrets-exposed"&gt;Secrets exposed&lt;/h3&gt;
&lt;p&gt;One limitation of the current (.NET Core 3 to .NET 6) implementation, which is demonstrated above - is that configuration values which are secrets (keys, passwords, etc.) are included in the output.&lt;/p&gt;
&lt;p&gt;In my example the password was stored in the &lt;em&gt;appsettings.json&lt;/em&gt;, which ideally shouldn't happen - however even if injected at runtime as an environment variable, the same would occur, and the value would still be exposed (just coming from a different provider source).&lt;/p&gt;
&lt;p&gt;The enhancements in .NET7 aim to improve this.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getdebugview-preview"&gt;GetDebugView: Preview&lt;/h2&gt;
&lt;p&gt;Bear in mind, that the following is done using a &lt;em&gt;Preview&lt;/em&gt; version of .NET7, and may change by the time it is officially release.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;GetDebugView&lt;/code&gt; now has an overload which accepts a &lt;em&gt;Func&lt;/em&gt; and allows for custom processing and manipulation of the configuration values for display:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject IConfiguration from dependency injection container
app.MapGet(&amp;quot;/config&amp;quot;, (IConfiguration config) =&amp;gt;
{
    // convert to IConfigurationRoot
    var root = config as IConfigurationRoot;

    return root.GetDebugView(context =&amp;gt;
    {
        // this Func keys called for each Key in the configuration

        // if the key is one we know contains a password
        if(context.Key == &amp;quot;ServiceCredentials:password&amp;quot;)
        {
            // return a masked value
            return &amp;quot;***&amp;quot;;
        }
        
        // otherwise return the original configuration value
        return context.Value;
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With a &lt;em&gt;appsettings.json&lt;/em&gt; file the same as before&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;Logging&amp;quot;: {
    &amp;quot;LogLevel&amp;quot;: {
      &amp;quot;Default&amp;quot;: &amp;quot;Information&amp;quot;,
      &amp;quot;Microsoft.AspNetCore&amp;quot;: &amp;quot;Warning&amp;quot;
    }
  },
  &amp;quot;AllowedHosts&amp;quot;: &amp;quot;*&amp;quot;,
  &amp;quot;ServiceCredentials&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;admin123&amp;quot;,
    &amp;quot;password&amp;quot; : &amp;quot;admin456&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the endpoint will return the same as before, but with one small adjustment:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;AllowedHosts=* (JsonConfigurationProvider for 'appsettings.json' (Optional))
ASPNETCORE_ENVIRONMENT=Development (EnvironmentVariablesConfigurationProvider Prefix: '')
Logging:
  LogLevel:
    Default=Information (JsonConfigurationProvider for 'appsettings.Development.json' (Optional))
    Microsoft.AspNetCore=Warning (JsonConfigurationProvider for 'appsettings.Development.json' (Optional))
ServiceCredentials:
  password=*** (JsonConfigurationProvider for 'appsettings.json' (Optional))
  username=admin123 (JsonConfigurationProvider for 'appsettings.json' (Optional))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The password returned is now the &lt;code&gt;masked value&lt;/code&gt; specified in the &lt;em&gt;Func&lt;/em&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having the ability to expose all configuration values can definitely save time and effort - it eliminates the need to remote into other machines or containers and get a list of environment variables when doing investigations. However the fact that confidential information could be exposed is far from ideal, and depending on how serious security is taken, could render the functionality unusable.&lt;/p&gt;
&lt;p&gt;However the .NET7 enhancements provides a working solution for this, which I look forward to being able to leverage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dunnhq.com/posts/2022/viewing-configuration-values/"&gt;Viewing .NET configuration values&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;110: 05-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/04-ef-find-vs-single</id>
		<title>EF Find vs First performance </title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/04-ef-find-vs-single" />
		<updated>2022-07-04T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When retrieving a single record from the database using Entity Framework, the &lt;code&gt;Single (or SingleOrDefault)&lt;/code&gt; method can be used - however the &lt;code&gt;Find&lt;/code&gt; method on the DbSet is potentially more efficient, however it comes with some limitations.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="first"&gt;First&lt;/h2&gt;
&lt;p&gt;The first method is using &lt;code&gt;First (or FirstOrDefault)&lt;/code&gt; - this is an extension method on &lt;em&gt;Queryable&lt;/em&gt; (an important factor when comparing it to the &lt;em&gt;Find&lt;/em&gt; method)&lt;/p&gt;
&lt;p&gt;As &lt;em&gt;DbSet&lt;/em&gt; implement &lt;em&gt;IQueryable&lt;/em&gt;, this method can be use directly on the &lt;em&gt;DbSet&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Assuming we have a &lt;em&gt;DbContext&lt;/em&gt; with a &amp;quot;Song&amp;quot; &lt;em&gt;DbSet&lt;/em&gt;, a single record can be retrieved as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

// using Single
var song = context.Songs.Single(x =&amp;gt; x.Id == 43);

// using SingleOrDefault
var song2 = context.Songs.SingleOrDefault(x =&amp;gt; x.Id == 43);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="find"&gt;Find&lt;/h2&gt;
&lt;p&gt;The next method is using &lt;code&gt;Find&lt;/code&gt; - this is an extension method on &lt;em&gt;DBset&lt;/em&gt; itself.&lt;/p&gt;
&lt;p&gt;Again, assuming we have a &lt;em&gt;DbContext&lt;/em&gt; with a &amp;quot;Song&amp;quot; &lt;em&gt;DbSet&lt;/em&gt;, a record can be retrieved as follows using &lt;em&gt;Find&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

var song = context.Songs.Find(43);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="limitation"&gt;Limitation&lt;/h3&gt;
&lt;p&gt;As mentioned above, having &lt;code&gt;Find&lt;/code&gt; as an extension method on &lt;strong&gt;DbSet&lt;/strong&gt; does limit its usage. It cannot be used in conjunction with other &lt;em&gt;IQueryable&lt;/em&gt; extension methods.&lt;/p&gt;
&lt;p&gt;The following examples are &lt;strong&gt;NOT&lt;/strong&gt; valid and will &lt;strong&gt;NOT&lt;/strong&gt; compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Find() returns a 'Song' and as such Include()
// cannot be used in this example
var song = context.Songs.Find(43).Include(&amp;quot;Artist&amp;quot;);

// Include() returns a 'IQueryable' and as such Find()
// cannot be used in this example
var song2 = context.Songs.Include(&amp;quot;Artist&amp;quot;).Find(43);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the following using &lt;code&gt;Single&lt;/code&gt; &lt;strong&gt;is VALID&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Include() returns a 'IQueryable' and as Single is
// an extension method on 'IQueryable' it CAN be used
var song = context.Songs.Include(&amp;quot;Artist&amp;quot;).Single(x =&amp;gt; x.Id == 43);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmark"&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;The different methods where benchmarked, with a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shared DbContext&lt;/code&gt; - defined in the constructor once, and reused&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Single-use DbContext&lt;/code&gt; - a new DbContext is declared for each database call&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FindSharedContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;14.93 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.845 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.071 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12.00 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.14&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.07&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleDefaultSharedContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;123.26 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.294 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.146 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;123.22 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.98&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleSharedContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;123.78 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.320 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.242 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;122.09 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FindOneUseContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;488.81 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.539 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.207 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;487.06 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.91&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleDefaultOneUseContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;261.49 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.098 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.236 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;260.91 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.09&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleOneUseContext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;259.93 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.166 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.317 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;257.45 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.11&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;p&gt;The &lt;em&gt;Find&lt;/em&gt; method is &lt;code&gt;substantially quicker&lt;/code&gt; when reusing the DbContext (as one should).&lt;/p&gt;
&lt;p&gt;However, interestingly, with a single-use DbContext, the &lt;em&gt;Single/SingleOrDefault&lt;/em&gt; method is almost twice as quick as the &lt;em&gt;Find&lt;/em&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While &lt;em&gt;Find&lt;/em&gt; is approximately &lt;code&gt;7 times&lt;/code&gt; faster than the equivalent &lt;em&gt;Single&lt;/em&gt; method, it does come with considerable limitations. If performance is critical, it might be worth finding a way to work around the limitations - however keep in mind that the differences are being measured in microseconds, so the performance gain might not be worth the potential additional effort.&lt;/p&gt;
&lt;p&gt;Be aware of the performance differences, and the limitations - and for each specific use case, apply the more appropriate technique.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/danylaws/status/1524284247049216000"&gt;Daniel Lawson tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;109: 04-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>