<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2023</rights>
	<updated>2023-01-17T03:38:14Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic</id>
		<title>Non-generic to generic method call</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic" />
		<updated>2023-01-17T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;dynamic&lt;/code&gt; type can be used in the use case when required to call into a &lt;em&gt;generic method, from a non-generic method&lt;/em&gt;. This is a fairly niche use case, but when required, the &lt;code&gt;dynamic&lt;/code&gt; technique explained below can be of great benefit.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generic-method"&gt;Generic method&lt;/h2&gt;
&lt;p&gt;Assume we have the following simple generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static void GenericMethod&amp;lt;T&amp;gt;(T parameter)
{
    Console.WriteLine($&amp;quot;T is of type: {typeof(T).Name}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method needs to be called from another non-generic method which contains an &lt;code&gt;object&lt;/code&gt; variable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="object-technique"&gt;Object technique&lt;/h3&gt;
&lt;p&gt;Calling into the generic method with an &lt;code&gt;object&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // call into the generic method with the
        // object type
        GenericMethod(randomObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this will compile and &amp;quot;work&amp;quot;, calling the &lt;code&gt;ObjectMethod&lt;/code&gt; method with various types, will result in the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: Object
T is of type: Object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an &lt;code&gt;Object&lt;/code&gt; is being passed to the generic method (even though the underlying types are different), the values are &lt;em&gt;boxed&lt;/em&gt; into that type, and that is what is output.&lt;/p&gt;
&lt;p&gt;If we would like to know the &lt;em&gt;actual&lt;/em&gt; type output, then the &lt;code&gt;dynamic technique&lt;/code&gt; can be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dynamic-technique"&gt;Dynamic technique&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;dynamic technique&lt;/code&gt; involves casting the &lt;code&gt;object to dynamic&lt;/code&gt; before calling the generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // cast the object to dynamic
        dynamic dynObj = randomObj;
        GenericMethod(dynObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, calling the generic method with the same variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: String
T is of type: Int32
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A fairly niche use case, and a small difference in code but one which can make a big difference when the use case is encountered. There might be a performance impact with the &lt;em&gt;dynamic technique&lt;/em&gt; (as dynamic generally is less performant), but this might be out-weighed by the benefit the technique gives. As always, if performance is an issue, benchmark and and make an informed decision which technique to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/RogerAlsing/status/1609955500363333632"&gt;Roger Johansson Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;236: 17-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation</id>
		<title>Cancelling a collection iteration</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation" />
		<updated>2023-01-16T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When iterating over a collection or items, the &lt;code&gt;TakeWhile&lt;/code&gt; method can be used in conjunction with a &lt;code&gt;CancellationToken&lt;/code&gt; to successfully stop iterating if the parent process is cancelled.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-cancellationtoken"&gt;No CancellationToken&lt;/h2&gt;
&lt;p&gt;Generally, when iteration through a collection, a &lt;code&gt;foreach&lt;/code&gt; (or &lt;code&gt;for&lt;/code&gt;) loop is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task ExecuteLoopNoCancel()
{
    // generate a collection of 100 items
    var iterationItems = Enumerable.Range(0, 100);

    // iterate through the 100 items
    foreach (var item in iterationItems)
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the above &lt;code&gt;/ExecuteLoopNoCancel&lt;/code&gt; endpoint has the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processing item: 0
Processing item: 1
Processing item: 2
Processing item: 3
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, and &lt;em&gt;especially in an endpoint which can be cancelled at any time&lt;/em&gt;, is that if the parent process is cancelled, the &lt;code&gt;iteration of the collection will continue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;loop will continue to execute in the background&lt;/em&gt; (and output to the console), as it is being executed &lt;code&gt;asynchronously&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="with-cancellationtoken"&gt;With CancellationToken&lt;/h2&gt;
&lt;p&gt;To correctly &lt;code&gt;cancel the iteration&lt;/code&gt; when the parent process is cancelled, a &lt;code&gt;CancellationToken&lt;/code&gt; should be passed from the top of the stack all the way down to the loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// pass in a CancellationToken
async Task ExecuteLoop(CancellationToken cnlTkn)
{
    var iterationItems = Enumerable.Range(0, 100);

    // only loop while the CancellationToken is not cancelled
    foreach(var item in iterationItems
        .TakeWhile(_ =&amp;gt; !cnlTkn.IsCancellationRequested))
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; token is passed into the endpoint - this is &lt;em&gt;linked&lt;/em&gt; to client, so if the request is &lt;em&gt;cancelled from the client side, the CancellationToken is &amp;quot;notified&amp;quot;&lt;/em&gt; of the cancellation&lt;/li&gt;
&lt;li&gt;In the &lt;em&gt;foreach&lt;/em&gt; loop, the &lt;code&gt;TakeWhile&lt;/code&gt; method is called, with a &lt;code&gt;CancellationToken&lt;/code&gt; passed in as a parameter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, when the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;CancellationToken is marked as cancelled (IsCancellationRequested is set to true), and the iteration will stop&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When performing iterations over a collection, where it makes sense (in situations when the calling process can be cancelled, such as in an endpoint), a &lt;code&gt;CancellationToken&lt;/code&gt; instance should always be used. This ensures any iterations being done asynchronously will be cancelled, ensuring resources are not being unessacary used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/vekzdran/status/1610197203901091840"&gt;&amp;#64;vekzdran&amp;#64;hachyderm.io Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;235: 16-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname</id>
		<title>Naming minimal endpoints</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname" />
		<updated>2023-01-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A minimal endpoint can be &lt;code&gt;given a name&lt;/code&gt;, which can then be leveraged to &lt;code&gt;automatically generate a link to the endpoint&lt;/code&gt; making it easier to be invoked.&lt;/p&gt;
&lt;p&gt;The endpoint name metadata is also treated as the &lt;em&gt;operation Id&lt;/em&gt; in the OpenAPI specification, which is used by tools which use the swagger file to generate a client.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint"&gt;Named endpoint&lt;/h2&gt;
&lt;p&gt;The first step is to give the endpoint a name - this is very simply and involves using the &lt;em&gt;WithName&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the default sample endpoint
app.MapGet(&amp;quot;/weatherforecast&amp;quot;, () =&amp;gt;
{
    WeatherForecast[]? forecast = Enumerable.Range(1, 5).Select(index =&amp;gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
// give it a name
.WithName(&amp;quot;GetWeatherForecast&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the body of the minimal API is defined, the &lt;em&gt;WithName&lt;/em&gt; method is called, with the endpoint name supplied. In this example the sample &lt;em&gt;/weatherforecast&lt;/em&gt; endpoint is given the name &lt;code&gt;GetWeatherForecast&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="link-generation"&gt;Link generation&lt;/h2&gt;
&lt;p&gt;This &lt;em&gt;endpoint name&lt;/em&gt; can now be used to generate a URL to the endpoint - this is done using the &lt;code&gt;LinkGenerator&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject LinkGenerator from DI
app.MapGet(&amp;quot;/generateUrl&amp;quot;, (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    // use the name to get a link to the GetWeatherForecast endpoint
    return generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code defines an endpoint, which when invoked will return the URL of the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint. Browsing to the &lt;code&gt;/generateUrl&lt;/code&gt; endpoint returns the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;http://localhost:5276/weatherforecast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The full URL (including port etc) is automatically calculated by the &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; method, based on the &lt;em&gt;HttpContext&lt;/em&gt; and the &lt;em&gt;endpoint name&lt;/em&gt;. &lt;em&gt;LinkGenerator&lt;/em&gt; is available through the dependency injection container and can just be injected into the relevent constructor/delegate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint-invocation"&gt;Named endpoint invocation&lt;/h2&gt;
&lt;p&gt;A practical use of this functionality is &lt;em&gt;when an endpoint is required to call another endpoint in the same application&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/weatherforecastproxy&amp;quot;, async (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    HttpClient? client = new HttpClient();

    // get the URL for the &amp;quot;GetWeatherForecast&amp;quot; endpoint
    // and create an HttpRequestMessage for it
    HttpRequestMessage? request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;GET&amp;quot;),
        generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null)
    );

    // invoke it
    HttpResponseMessage? response = client.Send(request);
    return await response.Content.ReadAsStringAsync();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, calling &lt;code&gt;/weatherforecastproxy&lt;/code&gt; will proxy the call to the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint and returns the result - this proxy endpoint is not adding much value in this sample, but it could do more complicated logic, such as calling multiple endpoints and reconciling the results, for example.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;named endpoints&lt;/code&gt; and &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; is a safer approach to generating the URL, instead of manually trying to build up the URL based on the information extracted from the &lt;em&gt;HttpContext&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A simple and easy way to name, and then generate a link using the name. If the code is required to call another endpoint in the same application, or will be used with a client generation tool - then all endpoints should be named, and &lt;em&gt;LinkGenerator&lt;/em&gt; used when generating the links.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;234: 13-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable</id>
		<title>Request binding with IParseable</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable" />
		<updated>2023-01-12T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post&lt;/a&gt; we had a look at the &lt;code&gt;IParseable interface&lt;/code&gt; which allows for a &lt;code&gt;string to be parsed into a type&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This functionality can be leveraged with minimal API's to &lt;em&gt;automatically parse a query string to a complex type&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="iparseable-request"&gt;IParseable request&lt;/h2&gt;
&lt;p&gt;In this example, the &lt;em&gt;Song&lt;/em&gt; entity implements the &lt;em&gt;IParsable&amp;lt;Song&amp;gt;&lt;/em&gt; interface (more details in the &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post about IParseable&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song : IParsable&amp;lt;Song&amp;gt;
{
    public string Name { get; set; }
    public string Artist { get; set; }
    public int LengthInSeconds { get; set; }

    private Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }

    public static Song Parse(string s, IFormatProvider? provider)
    {
        string[] songPortions = s.Split(new[] { '|' });

        if (songPortions.Length != 3) 
        { 
            throw new OverflowException("Expect format: Name|Artist|LengthInSeconds"); 
        }

        return new Song(songPortions[0], songPortions[1], Int32.Parse(songPortions[2]));
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
    {
        result = null;
        if (s == null) 
        { 
            return false; 
        }

        try
        {
            result = Parse(s, provider);
            return true;
        }
        catch { return false; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This interface implementation allows for a string value (in a specific format), to be converted to a &lt;code&gt;Song instance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Song song = "Everlong|Foo Fighters|326".Parse&amp;lt;Song&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="minimal-endpoint"&gt;Minimal endpoint&lt;/h2&gt;
&lt;h3 id="manual-parsing"&gt;Manual parsing&lt;/h3&gt;
&lt;p&gt;If we want an endpoint which accepts a &lt;em&gt;Song&lt;/em&gt; as a parameter, one option is to have the request entity &lt;code&gt;as a string&lt;/code&gt; and perform the conversion to &lt;em&gt;Song&lt;/em&gt; manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/song", ([FromQuery]string song) =&amp;gt;
{
    // perform the conversion from string
    // to Song manually, using the IParsable
    // interface
    return details.Parse&amp;lt;Song&amp;gt;();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a valid approach, but because the &lt;em&gt;Song class&lt;/em&gt; implements &lt;em&gt;IParseable&lt;/em&gt;, the conversion can be done automatically!&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="automatic-parsing"&gt;Automatic parsing&lt;/h3&gt;
&lt;p&gt;A slightly easier approach that manually doing the conversions, is allowing it to happen automatically. Changing the parameter type from &lt;em&gt;string&lt;/em&gt; to &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// parameter is Song instead of string
app.MapGet("/song", ([FromQuery] Song song) =&amp;gt;
{
    return song;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the same endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the same response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;code&gt;Song implement IParsable, the string parameter is automatically parsed to a Song instance&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small quality of life feature which makes working with the &lt;em&gt;IParsable&lt;/em&gt; interface and minimal endpoints easier and more streamline.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/5-new-mvc-features-in-dotnet-7/#1-iparseable-tryparse-for-primitive-binding"&gt;5 new MVC features in .NET 7&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;233: 12-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from</id>
		<title>SQL: IS DISTINCT FROM</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from" />
		<updated>2023-01-11T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;SQL Server 2022 introduced a new predicate &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt;, which allows for two expressions to be compared, but takes &lt;code&gt;NULL&lt;/code&gt; values into account.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="data-setup"&gt;Data setup&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Blog&lt;/em&gt; table, with a &lt;code&gt;nullable DateCreated column&lt;/code&gt; - this column &lt;em&gt;could&lt;/em&gt; have a valid &lt;em&gt;DateTime value&lt;/em&gt;, but could also contain NULL values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pre-sql-2022"&gt;Pre SQL 2022&lt;/h3&gt;
&lt;p&gt;Prior to SQL 2022, when comparing two values, &lt;code&gt;NULL&lt;/code&gt; values were, by default, not taken into account.&lt;/p&gt;
&lt;p&gt;Assume the &lt;em&gt;Blog&lt;/em&gt; table &lt;code&gt;DOES&lt;/code&gt; contain rows which have &lt;em&gt;NULL&lt;/em&gt; DateCreated values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE DateCreated = &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;0 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Even though &lt;code&gt;&amp;#64;createdDate&lt;/code&gt; is &lt;em&gt;NULL&lt;/em&gt;, and there are rows in the table with &lt;em&gt;NULL&lt;/em&gt;, &lt;code&gt;no rows are returned&lt;/code&gt; - &lt;em&gt;NULL&lt;/em&gt; values are not taken into account.&lt;/p&gt;
&lt;p&gt;To successfully return rows which do contain &lt;em&gt;NULL&lt;/em&gt; values, both expressions need to be converted to the same default value in case of a &lt;em&gt;NULL&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE ISNULL(DateCreated, '1900-01-01') = 
	ISNULL(&amp;#64;createdDate, '1900-01-01')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With this technique, &lt;em&gt;NULL&lt;/em&gt; values on either expression is converted to &lt;code&gt;'1900-01-01'&lt;/code&gt;, which is then successfully compared.&lt;/p&gt;
&lt;p&gt;With SQL Server 2022, performing this comparison becomes much easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="sql-2022"&gt;SQL 2022&lt;/h3&gt;
&lt;p&gt;SQL Server 2022 introduces the new &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate - this allows the comparison of values while taking &lt;em&gt;NULL&lt;/em&gt; values into account.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT * 
FROM Blog
WHERE DateCreated IS NOT DISTINCT FROM &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate &lt;em&gt;compares the equality of two expressions and guarantees a true or false result, even if one or both operands are NULL&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively minor update, but for a developer which writes a good amount SQL this small update definitely does make things simpler and easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.sqlservercentral.com/blogs/cool-stuff-in-sql-server-2022-is-distinct-from"&gt;Cool Stuff in SQL Server 2022 – IS DISTINCT FROM&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;232: 11-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/10-mvc-cache</id>
		<title>Caching MVC responses</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/10-mvc-cache" />
		<updated>2023-01-10T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core has out of the box &lt;code&gt;configurable response caching&lt;/code&gt; functionality which can be leveraged to improve the performance of a service using &lt;code&gt;controllers&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The functionality described in this post is only for caching responses from &lt;em&gt;an MVC controller&lt;/em&gt; - to cache responses from a &lt;em&gt;minimal API&lt;/em&gt;, have a look at &lt;a href="https://alwaysdeveloping.net/2022/09/07-output-cache"&gt;this post which details output caching on minimal APIs&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="code"&gt;Code&lt;/h2&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;The default template &lt;em&gt;Weather API&lt;/em&gt; project is used for the below example, with the &lt;code&gt;Use Controllers&lt;/code&gt; options checked.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="startup"&gt;Startup&lt;/h3&gt;
&lt;p&gt;First step, &lt;code&gt;enabling the caching functionality&lt;/code&gt; in the service - this is done in the &lt;em&gt;program.cs&lt;/em&gt;, and involves adding two lines of code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
// setup caching with the DI container
builder.Services.AddResponseCaching();

var app = builder.Build();

// setup caching in the pipeline
app.UseResponseCaching();
app.UseAuthorization();
app.MapControllers();

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This follows a fairly standard pattern when it comes to adding functionality to an ASP.NET Core application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;AddResponseCaching&lt;/code&gt; method is called to register the required services with the dependency injection container&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;UseResponseCaching&lt;/code&gt; method is called to insert the caching logic into the middleware pipeline&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next step, enabling caching on a controller.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="controller"&gt;Controller&lt;/h3&gt;
&lt;p&gt;Now that we have the base caching functionality configured in the service, the next step is to actual enable caching for a specific endpoint/controller. This is done by &lt;code&gt;adding an attribute to the relevent controller method&lt;/code&gt;. In the &lt;em&gt;WeatherForecastController.cs&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[HttpGet]
[ResponseCache(Duration = 30, Location = ResponseCacheLocation.Any)]
public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
{
    Console.WriteLine($"{nameof(Get)} method in {nameof(WeatherForecastController)} called");

    return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = Random.Shared.Next(-20, 55),
        Summary = Summaries[Random.Shared.Next(Summaries.Length)]
    })
    .ToArray();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ResponseCache&lt;/code&gt; attribute is added to the &lt;em&gt;Get&lt;/em&gt; method (the method called when the endpoint is called). In this example, the cache is set to expire every 30 seconds.&lt;/p&gt;
&lt;p&gt;And thats it! We now have basic caching functionality working on the service.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="output"&gt;Output&lt;/h3&gt;
&lt;p&gt;If we run the service and browse to the &lt;code&gt;/weatherforecast&lt;/code&gt; endpoint, the weather payload will be returned, and logging at the console, the following will be output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Get method in WeatherForecastController called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Refreshing the endpoint within 30 seconds (the duration of the cache), will yield the same payload, and cause no output to the console - the &lt;code&gt;results are returned from the cache, and the controller is never called.&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="vary"&gt;Vary&lt;/h3&gt;
&lt;p&gt;Not explicitly show in the above example, but it is also possible to &lt;code&gt;vary the cache response&lt;/code&gt; by a specific key.&lt;/p&gt;
&lt;p&gt;If the attribute parameters were changed to include the &lt;code&gt;VaryByHeader&lt;/code&gt; parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[HttpGet]
[ResponseCache(Duration = 30, Location = ResponseCacheLocation.Any, VaryByHeader = "User-Agent")]
public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
{
    Console.WriteLine($"{nameof(Get)} method in {nameof(WeatherForecastController)} called");

    return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = Random.Shared.Next(-20, 55),
        Summary = Summaries[Random.Shared.Next(Summaries.Length)]
    })
    .ToArray();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then a different cache is created for each distinct &lt;code&gt;User-Agent&lt;/code&gt; header value sent on a request, each cache independent of one another. This way, the cache of one called will operate independently from the cache of a different caller. It is also possible to vary the cache by a specific &lt;code&gt;query string key&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When simple caching is required, the built-in functionality is an easy to implement, low effort option to enhance the performance of a service.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ryansouthgate.com/asp.net-core-response-caching/"&gt;ASP.NET Core Response Caching&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;231: 10-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/09-ef-startup</id>
		<title>Database creation on startup</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/09-ef-startup" />
		<updated>2023-01-09T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When configuring an Entity Framework &lt;code&gt;DbContext&lt;/code&gt; with the &lt;em&gt;dependency injection container&lt;/em&gt;, it is possible to make use of the container to create an instance of the context on startup, to either create the database or apply database migrations.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="configuration"&gt;Configuration&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;AddDbContext&lt;/code&gt; extension method is used to configure the &lt;em&gt;Entity Framework DbContext&lt;/em&gt; on startup, registering the context with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// configure the context and add to the DI Container
builder.Services.AddDbContext&amp;lt;DemoContext&amp;gt;(options =&amp;gt;
    options.UseSqlServer(&amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFStartup;
        Integrated Security=True;TrustServerCertificate=True&amp;quot;));

var app = builder.Build();

app.MapGet(&amp;quot;/blogs&amp;quot;, (DemoContext context) =&amp;gt;
{
    return context.Blogs.ToList();
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the &lt;code&gt;/blogs&lt;/code&gt; endpoint is called and a &lt;code&gt;DemoContext&lt;/code&gt; is instantiated, the above will work &lt;code&gt;provided that the database and relevent tables have already been created&lt;/code&gt; - if not, and exception will be thrown, as the database is not automatically created.&lt;/p&gt;
&lt;p&gt;Next we'll have a look at how to ensure the database is created on startup, using the services registered with the dependency injection container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="startup"&gt;Startup&lt;/h2&gt;
&lt;p&gt;The process of ensuring the database is created, is relatively straightforward - Entity Framework does most of the heavy lifting for us:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDbContext&amp;lt;DemoContext&amp;gt;(options =&amp;gt;
    options.UseSqlServer(&amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFStartup;
        Integrated Security=True;TrustServerCertificate=True&amp;quot;));

var app = builder.Build();

// this block ensures the database is created
#if DEBUG
using (var scope = app.Services.CreateScope())
{
    var startupContext = scope.ServiceProvider
        .GetRequiredService&amp;lt;DemoContext&amp;gt;();
    startupContext.Database.EnsureCreated();
}
#endif

app.MapGet(&amp;quot;/blogs&amp;quot;, (DemoContext context) =&amp;gt;
{
    return context.Blogs.ToList();
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some notes on the above code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;#if conditional&lt;/code&gt; is used to ensure the code is only executed when debugging. It is NOT recommended to automatically create the database or apply migrations in non-development environments. The recommended approach is to use a CI/CD pipeline.&lt;/li&gt;
&lt;li&gt;a new dependency injection scope is created (as the application host is technically not running yet) and a &lt;code&gt;DbContext&lt;/code&gt; instance instantiated&lt;/li&gt;
&lt;li&gt;the &lt;em&gt;EnsureCreated&lt;/em&gt; method is called to create the database with the configured schema. This &lt;strong&gt;bypasses&lt;/strong&gt; migrations - if the migrations are required to be run, then &lt;code&gt;startupContext.Database.Migrate()&lt;/code&gt; should be called instead of &lt;code&gt;startupContext.Database.EnsureCreated()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the &lt;em&gt;EnsureCreated&lt;/em&gt; is designed to be used when doing &lt;code&gt;testing or prototyping&lt;/code&gt; where the database is dropped and recreated with each execution&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful and time-saving way to use the &lt;em&gt;already configured&lt;/em&gt; dependency injection container to instantiate the database context, and have EF do the heavy lifting to create the database with the correct schema.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodogmablog.bryanhogan.net/2022/09/dependency-injection-of-an-entity-framework-context-within-program-cs-using-top-level-statements/"&gt;Dependency Injection of an Entity Framework Context within Program.cs Using Top Level Statements&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;230: 09-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/06-linq-distinct</id>
		<title>LINQ DistinctBy</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/06-linq-distinct" />
		<updated>2023-01-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;Enumerable&lt;/em&gt; &lt;code&gt;DistinctBy&lt;/code&gt; method, introduced in .NET 6, can be used to return &lt;em&gt;distinct elements from a sequence according to the specified key selector&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Prior to .NET 6, performing this operation was a bit complex, but the introduction of the &lt;code&gt;DistinctBy&lt;/code&gt; method simplifies the process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In this example, a collection of 3 &lt;em&gt;Songs&lt;/em&gt; will be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;Song&amp;gt; songs = new List&amp;lt;Song&amp;gt;
{
    new Song
    {
        Id = 1,
        Name = &amp;quot;Everlong&amp;quot;,
        Album = &amp;quot;The Colour and the Shape&amp;quot;
    },
    new Song
    {
        Id = 2,
        Name = &amp;quot;Monkey Wrench&amp;quot;,
        Album = &amp;quot;The Colour and the Shape&amp;quot;
    }
    ,
    new Song
    {
        Id = 3,
        Name = &amp;quot;Learn to Fly&amp;quot;,
        Album = &amp;quot;There Is Nothing Left to Lose&amp;quot;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's look at how we can get a &lt;em&gt;distinct list of albums from the collection of songs&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre.net-6"&gt;Pre .NET 6&lt;/h2&gt;
&lt;p&gt;The process for doing this (using LINQ) prior to .NET 6 was as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; albums = songs
    .GroupBy(s =&amp;gt; s.Album)
    .Select(g =&amp;gt; g.First())
    .Select(a =&amp;gt; a.Album);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The steps are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;GroupBy&lt;/strong&gt; to get a collection of &lt;em&gt;Songs&lt;/em&gt;, with the &lt;em&gt;Album&lt;/em&gt; value as the key&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; and &lt;strong&gt;First&lt;/strong&gt; to get the first record in each group&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; to get the &lt;em&gt;Album&lt;/em&gt; of the first record&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the &lt;em&gt;Songs&lt;/em&gt; in each group will all contain the same &lt;em&gt;Album&lt;/em&gt; (as we are grouping by Album), selecting any record will yield the same Album.&lt;/p&gt;
&lt;p&gt;This works, but is a fairly convoluted process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-6-and-beyond"&gt;.NET 6 and beyond&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;DistinctBy&lt;/code&gt; method greatly simplifies this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; albums = songs
    .DistinctBy(s =&amp;gt; s.Album)
    .Select(a =&amp;gt; a.Album);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the steps are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;DistinctBy&lt;/strong&gt; to get a collection of &lt;em&gt;Songs&lt;/em&gt;, each one having a &lt;em&gt;unique Album value&lt;/em&gt;. In this example, after this is executed, the record with &lt;em&gt;id = 2&lt;/em&gt; is dropped from the collection as it has the same &lt;em&gt;Album&lt;/em&gt; value as thew previous record&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; to get the &lt;em&gt;Album&lt;/em&gt; of each of the remaining records&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Easier to read and less convoluted!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The addition of the new &lt;code&gt;DistinctBy&lt;/code&gt; makes a big difference to the complexity, as well as the readability of the code - instead of trying to decider some &lt;em&gt;complex&lt;/em&gt; LINQ (as was the case prior to .NET 6), the code now better describes what it is actually doing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/zpjpst/do_you_know_about_the_distinctby_method/"&gt;Do you know about the DistinctBy method?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;229: 06-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/05-new-stopwatch</id>
		<title>Efficient Stopwatch usage</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/05-new-stopwatch" />
		<updated>2023-01-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduced new &lt;code&gt;StopWatch&lt;/code&gt; functionality, which not only makes using the class easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="typical-usage"&gt;Typical usage&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;StopWatch&lt;/code&gt; class is often used to perform simple benchmarks to determine how long a piece of code executes for. The &lt;em&gt;StopWatch&lt;/em&gt; is started, the code in question is executed, and then the &lt;em&gt;StopWatch&lt;/em&gt; is stopped and the ElapsedTime is captured.&lt;/p&gt;
&lt;p&gt;Typically the &lt;code&gt;StopWatch&lt;/code&gt; class is used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// new instance of Stopwatch
Stopwatch sw = new Stopwatch();
sw.Start();

await Task.Delay(500);

sw.Stop();
Console.WriteLine($&amp;quot;Time Elapsed: {sw.Elapsed}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="improved-usage"&gt;Improved usage&lt;/h2&gt;
&lt;p&gt;The issue with the above is that memory is allocated for the &lt;em&gt;StopWatch&lt;/em&gt; instance declared. Instead, a more memory efficient approach is to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the start time (in ticks)
long startTime = Stopwatch.GetTimestamp();

await Task.Delay(500);

// get the end time (in ticks)
long endTime = Stopwatch.GetTimestamp();
// calculate the difference
TimeSpan elapsedTime = new TimeSpan(endTime - startTime);
Console.WriteLine($&amp;quot;Time Elapsed: {elapsedTime}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No memory is allocated in this example, but it is slightly more complex to code than the previous example.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-7-improvements"&gt;.NET 7 improvements&lt;/h2&gt;
&lt;p&gt;A new method, &lt;code&gt;Stopwatch.GetElapsedTime&lt;/code&gt;,  was introduced with .NET 7 which makes the above approach simpler:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the start time (in ticks)
long startTime = Stopwatch.GetTimestamp();

await Task.Delay(500);

// get the elapsed time between the startTime and the currentTime
TimeSpace elapsedTime = Stopwatch.GetElapsedTime(startTime);
Console.WriteLine($&amp;quot;Time Elapsed: {elapsedTime}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;GetElapsedTime&lt;/code&gt; method will calculate the elapsed time between the &lt;em&gt;startTime&lt;/em&gt; and the &lt;em&gt;current time&lt;/em&gt; (it is also possible to explicitly supply an &lt;em&gt;endTime&lt;/em&gt; to the method as well).&lt;/p&gt;
&lt;p&gt;Here we get the benefit of less memory allocations, and also not having to do additional calculations.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, useful new method which makes using &lt;code&gt;StopWatch&lt;/code&gt; cleaner and more efficient overall - one doesn't want diagnostic tools to be detrimental to the performance and readability of the application code.
Having said that, having a single StopWatch instance should really not impact application performance at all - however its always a good practice to be as efficient as possible, traded off with effort, and in this case, there is no additional effort required to be slightly more efficient.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=NTz99yN2urc"&gt;Are you using the Stopwatch efficiently in .NET?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;228: 05-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/04-multi-attributes</id>
		<title>Combining multiple attributes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/04-multi-attributes" />
		<updated>2023-01-04T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple attributes are applied to a program entity, the attributes can either be &lt;code&gt;specified on separate lines, or on a single line&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiline"&gt;Multiline&lt;/h2&gt;
&lt;p&gt;In this example, a &lt;em&gt;class&lt;/em&gt; is used to demonstrate an entity having multiple attributes, but the same applies to other relevent program entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Serializable]
[Obsolete]
[DebuggerDisplay(&amp;quot;Id={Id}, Name={Name}&amp;quot;)]
public class MultiAttributeClass
{
    public int Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Three attributes added to the class - the actual attributes themselves are not important, it could be been any number of any attributes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-line"&gt;Single line&lt;/h2&gt;
&lt;p&gt;The multiple attributes can also be applied as follows though:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Serializable, Obsolete, DebuggerDisplay(&amp;quot;Id={Id}, Name={Name}&amp;quot;)]
public class MultiAttributeClass
{
    public int Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Does this reduce the number of lines in code? Yes
Does it make it more difficult to read? Potentially
Is this recommended? Probably not. But you can if you want&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very small knowledge drop today, but something I was not aware was possible. As mentioned, as a general rule I would argue this make the code slightly less readable - however, some might find this code cleaner and more readable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/zk8oyj/did_you_know_you_could_combine_method_or_class/"&gt;Reddit Post&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;227: 04-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>