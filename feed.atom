<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-09-05T05:05:30Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/05-ping-programmatically</id>
		<title>Performing a ping programmatically</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/05-ping-programmatically" />
		<updated>2022-09-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Ping&lt;/code&gt; class is available in the &lt;em&gt;System.Net.NetworkInformation&lt;/em&gt; namespace - this class facilitates performing &lt;em&gt;ping&lt;/em&gt; operations (as the name suggests), on a hostname or IP address from code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage of the class is straightforward - declare an instance of &lt;code&gt;Ping&lt;/code&gt;, and call the &lt;em&gt;SendPingAsync&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.Net.NetworkInformation;

var looping = true;

// format asynchronously on a separate thread
Task.Run(async () =&amp;gt;
{
    // create an instance of the Ping class
    Ping pinger = new Ping();

    // loop until the user presses a key
    while (looping)
    {
        // ping and get the response
        PingReply response = await pinger
            .SendPingAsync(&amp;quot;alwaysdeveloping.net&amp;quot;);

        // extract response information
        Console.WriteLine($&amp;quot;Ping to '{response.Address}' took &amp;quot; +
            $&amp;quot;{response.RoundtripTime}milliseconds and the response &amp;quot; +
            $&amp;quot;was: `{response.Status}`&amp;quot;);

        // wait 250ms before pinging again
        await Task.Delay(250);
    }
});

// wait for a key press
// and then cancel the looping above
Console.ReadKey();
looping = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sample response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Ping to '192.11.119.201' took 604 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 321 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 311 milliseconds and was: 'Success'
Ping to '0.0.0.0' took 0 milliseconds and was: 'TimedOut'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 620 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 308 milliseconds and was: 'Success'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While there are better and more featureful (and more expensive) 3rd party tools available for monitoring the status and uptime of a website, with &lt;code&gt;Ping&lt;/code&gt; a simple, small application could be written to ping on an interval (as in the above example) and send out an alert if numerous timeouts are received.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1553066721702977537"&gt;Davide Bellone Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;153: 05-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation</id>
		<title>Minimal api's and cancellation tokens</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation" />
		<updated>2022-09-05T00:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; can be passed into a minimal api endpoint to be used to &lt;em&gt;cancel processing executed by the endpoint&lt;/em&gt; - the cancellation token will automatically be marked as cancelled if the caller either cancels the request or navigates away from the endpoint (if being accessed from the browser)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="process-cancellation"&gt;Process cancellation&lt;/h2&gt;
&lt;h3 id="no-token"&gt;No token&lt;/h3&gt;
&lt;p&gt;Consider the following minimal api endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/long&amp;quot;, async () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    // simulate a long running process
    await Task.Delay(5000);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the application is executed, and the endpoint called, the output would be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;02: Starting long process
07: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, it takes approximately 5 seconds for the endpoint to execute and finish.&lt;/p&gt;
&lt;p&gt;If the endpoint is called again, and during those 5 seconds of &amp;quot;processing&amp;quot;, the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button is clicked on the browser (wording may differ slightly depending on browser) we see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;52: Starting long process
57: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the &lt;code&gt;request from the browser to the endpoint is cancelled, the processing done by the endpoint is not cancelled!&lt;/code&gt;. The endpoint isn't aware of the fact the request was cancelled, which results in unnecessary CPU and memory usage, no longer required as the user has decided to cancel the request.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellationtoken"&gt;CancellationToken&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CancellationToken&lt;/code&gt; to the rescue - a &lt;em&gt;cancellation token&lt;/em&gt; can be used to convey information to the endpoint about the status of the request.&lt;/p&gt;
&lt;p&gt;Let's update the endpoint to use a cancellation token:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// add cancellation token, which is automatically populated
app.MapGet(&amp;quot;/long&amp;quot;, async (CancellationToken token) =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    //forward the token onto the method
    await Task.Delay(5000, token);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a &lt;code&gt;CancellationToken&lt;/code&gt; is specified to be passed into the endpoint - this automatically gets instantiated and is &lt;em&gt;&amp;quot;linked&amp;quot;&lt;/em&gt; to the HTTP context of the request. If the request is cancelled by the caller, the &lt;code&gt;CancellationToken&lt;/code&gt; will indicate this fact.&lt;/p&gt;
&lt;p&gt;Most &lt;em&gt;async&lt;/em&gt; methods (such as &lt;code&gt;Task.Delay&lt;/code&gt; in this instance) have an optional &lt;code&gt;CancellationToken&lt;/code&gt; parameter which can be used to pass a token all the way down the call stack to the code doing the actual work/processing, which will then in turn monitor and check if the token has been cancelled.&lt;/p&gt;
&lt;p&gt;Invoking this endpoint now, and clicking the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button on the browser while the endpoint is still processing will result in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;27: Starting long process
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]
      An unhandled exception has occurred while executing the request.
      System.Threading.Tasks.TaskCanceledException: A task was canceled.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a &lt;code&gt;CancellationToken&lt;/code&gt; is used to cancel a process, it is up to the library author to decide if cancelling means an exception be thrown (such as in the above example with &lt;em&gt;Task.Delay&lt;/em&gt;), or if processing simply just stops.&lt;/p&gt;
&lt;p&gt;While the endpoint &lt;code&gt;process is now successfully&lt;/code&gt; cancelled when the request is cancelled, not using unnecessary resources - we now have to deal with and cater for the &lt;code&gt;TaskCanceledException&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellation-middleware"&gt;Cancellation middleware&lt;/h3&gt;
&lt;p&gt;A &lt;em&gt;custom middleware&lt;/em&gt; component can be written to catch any exceptions of type &lt;code&gt;TaskCanceledException&lt;/code&gt;, log it and return a different response to the caller (which they will not care about, as they have cancelled the request):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CancellationMiddleware
{
    private readonly RequestDelegate _next;

    public CancellationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        // catch any canceled exceptions
        // TaskCanceledException inherits from OperationCanceledException
        catch (OperationCanceledException)
        {
            Console.WriteLine($&amp;quot;Cancelled request handled by {nameof(CancellationMiddleware)}&amp;quot;);
            // the called has cancelled the request
            // so doesn't care about the response
            // Totally legit HTTP response code
            context.Response.StatusCode = StatusCodes.Status418ImATeapot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware is then registered on startup:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;CancellationMiddleware&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now when invoking the endpoint and cancelling we see the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;18: Starting long process
Cancelled request handled by CancellationMiddleware
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Process successfully cancelled&lt;/code&gt; and &lt;code&gt;no more unhandled exception errors&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Adding &lt;code&gt;CancellationToken&lt;/code&gt; support to a minimal endpoint is a fairly low effort improvement, with a (depending on how the endpoint gets used) potential high reward - processing which is no longer required by the caller gets cancelled, freeing up CPU and memory usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/using-cancellationtokens-in-asp-net-core-minimal-apis/"&gt;Using CancellationTokens in ASP.NET Core minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;172: 30-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/02-enhanced-nameof</id>
		<title>nameof enhancement in C# 11</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/02-enhanced-nameof" />
		<updated>2022-09-02T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;With C# 11 (coming towards the end of this year) the scope of the &lt;code&gt;nameof&lt;/code&gt; expression is being extended, allowing it to be used inside an &lt;code&gt;attribute expression&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below examples written and tested using .NET 7-preview5, and as such may differ from the final release or subsequent preview releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;In the examples below, a simple &lt;code&gt;Attribute&lt;/code&gt; which takes a single string in the constructor is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[AttributeUsage(AttributeTargets.Method)]
public class MethodAttr : Attribute
{
    private readonly string _parameterName;

    // constructor just takes a string
    public MethodAttr(string parameterName)
    {
        _parameterName = parameterName;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we want to apply this attribute to a method, and specify the method &lt;code&gt;parameter name as the argument to the Attribute constructor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below we'll look at how this is done prior to C# 11 and how it can be improved on with C# 11.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pre-c-11"&gt;Pre C# 11&lt;/h3&gt;
&lt;p&gt;Prior to C #11 when using the attribute, the parameter name had to be &lt;em&gt;hardcoded&lt;/em&gt; into the &lt;code&gt;MethodAttr constructor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class NameOfClass
{
    public NameOfClass()
    {
        Console.WriteLine($&amp;quot;In constructor of {nameof(NameOfClass)}&amp;quot;);
    }

    public void NameOfMethod()
    {
        Console.WriteLine($&amp;quot;In method {nameof(NameOfMethod)}&amp;quot;);
    }

    // method parameter name hardcoded into the MethodAttr constructor
    [MethodAttr(&amp;quot;The parameter name is 'stringParam'&amp;quot;)]
    public void MethodWithParam(string stringParam)
    {
        // however, in the method nameof can be used to get 
        // the name of the parameter
        Console.WriteLine($&amp;quot;Value of parameter '{nameof(stringParam)}' is &amp;quot; +
            $&amp;quot;is {stringParam}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;nameof&lt;/code&gt; expression can be used successfully on the parameter name &lt;em&gt;in the method&lt;/em&gt; (&lt;code&gt;nameof(stringParam)&lt;/code&gt;), however when it comes to the attribute, the name has to be hardcoded - the &lt;code&gt;nameof&lt;/code&gt; expression cannot be used in this context.&lt;/p&gt;
&lt;p&gt;The issue with this approach, is that if the variable &lt;em&gt;stringParam&lt;/em&gt; is renamed (either with &lt;em&gt;F2&lt;/em&gt;, or &lt;em&gt;CTRL R+R&lt;/em&gt;) then all &lt;code&gt;string value representations&lt;/code&gt; of the variable name (such as in the attribute constructor) need to &lt;code&gt;manually be updated&lt;/code&gt;. With &lt;code&gt;nameof&lt;/code&gt;, a rename will ensure that all references (including the &lt;code&gt;nameof&lt;/code&gt; references) are renamed - this results in a more consistent and accurate code base.&lt;/p&gt;
&lt;p&gt;Prior to C# 11, there was no choice but to use the string value in the attribute - however this changes in C# 11.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="c-11"&gt;C# 11&lt;/h3&gt;
&lt;p&gt;With C# 11, the scope of &lt;code&gt;nameof&lt;/code&gt; has been increased, and it can now be used in attribute parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class NameOfClass
{
    public NameOfClass()
    {
        Console.WriteLine($&amp;quot;In constructor of {nameof(NameOfClass)}&amp;quot;);
    }

    public void NameOfMethod()
    {
        Console.WriteLine($&amp;quot;In method {nameof(NameOfMethod)}&amp;quot;);
    }

    // method parameter name hardcoded into the MethodAttr constructor
    [MethodAttr($&amp;quot;The parameter name is '{nameof(stringParam)}'&amp;quot;)]
    public void MethodWithParam(string stringParam)
    {
        // however, in the method nameof can be used to get 
        // the name of the parameter
        Console.WriteLine($&amp;quot;Value of parameter '{nameof(stringParam)}' is &amp;quot; +
            $&amp;quot;is {stringParam}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;nameof&lt;/code&gt; can be used in the method as well as in the attribute parameter!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, but welcome change - leveraging &lt;code&gt;nameof&lt;/code&gt; results in more consistent, more accurate and safer code. It's not possible to change the name of the variable, without changing all reference to it also being updated - otherwise a compiler error will occur. The more places &lt;code&gt;nameof&lt;/code&gt; can be utilized, the better!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1553081565613367298"&gt;Oleg Kyrylchuk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;152: 02-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/01-disposable-exceptions</id>
		<title>Dispose vs Exception handling</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/01-disposable-exceptions" />
		<updated>2022-09-01T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using a class which implements &lt;code&gt;IDisposable&lt;/code&gt; inside a &lt;code&gt;try-catch-finally&lt;/code&gt; block, if an exception is thrown in what order are the &lt;em&gt;Dispose&lt;/em&gt; and &lt;em&gt;catch&lt;/em&gt; block executed?&lt;/p&gt;
&lt;p&gt;The order is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Dispose&lt;/em&gt; method on the class implementing &lt;em&gt;IDisposable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Catch&lt;/em&gt; block&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Finally&lt;/em&gt; block&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Logically this makes sense, as the &lt;code&gt;IDisposable&lt;/code&gt; class is out of scope when the &lt;code&gt;catch&lt;/code&gt; block is being executed. The &lt;em&gt;lowered&lt;/em&gt; code can also be viewed to get an even deeper understanding of how these two features fit together.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;Consider the following class which implements &lt;em&gt;IDisposable&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DisposableClass : IDisposable
{
    public DisposableClass()
    {
        Console.WriteLine($&amp;quot;In Constructor of {nameof(DisposableClass)}&amp;quot;);
    }

    public void Dispose()
    {
        Console.WriteLine($&amp;quot;In Dispose of {nameof(DisposableClass)}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it implements &lt;em&gt;IDisposable&lt;/em&gt;, it can be used with the &lt;code&gt;using&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;try
{
    // declare instance of the disposable class
    using var disposableInstance = new DisposableClass();

    throw new Exception(&amp;quot;Exception or dispose?&amp;quot;);

}catch(Exception ex)
{
    Console.WriteLine(&amp;quot;An exception occurred&amp;quot;);
}
finally
{
    Console.WriteLine(&amp;quot;In the finally block&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In Constructor of DisposableClass
In Dispose of DisposableClass
An exception occurred
In the finally block
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Dispose&lt;/em&gt; called before the &lt;em&gt;catch block&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lowered"&gt;Lowered&lt;/h2&gt;
&lt;p&gt;Looking at the &lt;code&gt;lowered&lt;/code&gt; code (generated using &lt;a href="https://sharplab.io/"&gt;sharplab.io&lt;/a&gt;) it becomes more obvious as to why this is the sequence of events:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal static class &amp;lt;Program&amp;gt;$
{
    private static void &amp;lt;Main&amp;gt;$(string[] args)
    {
        try
        {
            DisposableClass disposableClass = new DisposableClass();
            try
            {
                throw new Exception(&amp;quot;Exception or dispose?&amp;quot;);
            }
            finally
            {
                if (disposableClass != null)
                {
                    ((IDisposable)disposableClass).Dispose();
                }
            }
        }
        catch (Exception)
        {
            Console.WriteLine(&amp;quot;An exception occurred&amp;quot;);
        }
        finally
        {
            Console.WriteLine(&amp;quot;In the finally&amp;quot;);
        }
    }
}
internal class DisposableClass : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine(&amp;quot;Disposing DisposableClass&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;using&lt;/code&gt; statement is converted into its own &lt;code&gt;try-finally&lt;/code&gt; block, with the &lt;em&gt;Dispose&lt;/em&gt; being called inside the &lt;em&gt;finally&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Looking at the above code, it make entire sense that the sequence of events is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Constructor&lt;/code&gt; of the &lt;em&gt;disposable class&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The first &lt;code&gt;finally&lt;/code&gt; block is called, and the &lt;code&gt;Dispose&lt;/code&gt; method is invoked&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;catch&lt;/code&gt; block is called, and the exception is handled&lt;/li&gt;
&lt;li&gt;The second &lt;code&gt;finally&lt;/code&gt; block is called&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The sequence of events in this scenario was not something I had considered before - but thinking through what each block of code does (as well as executing the sample code, and looking at the lowered code), the sequence of events makes sense, and is as one would probably expect. However, it is good to get confirmation and gain a better understanding of how one's code might operate under the hood.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1547993398853767170"&gt;Davide Bellone tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;151: 01-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/31-rate-limiting</id>
		<title>.NET 7 Rate limiting</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/31-rate-limiting" />
		<updated>2022-08-31T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Built in &lt;code&gt;rate limiting support&lt;/code&gt; is being introduced with .NET 7, and provides a way to protect a resource from being overwhelmed with requests.&lt;/p&gt;
&lt;p&gt;The rate limiting can be applied to an endpoint(s) to automatically control how often it can be called (API rate limiting), but in addition it can also be manually leveraged to control how often any resource in the applications gets used (such as a database connection)&lt;/p&gt;
&lt;p&gt;All below examples were written using .NET 7-preview5, and as such may differ from the final release or subsequent preview releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="rate-limiter-types"&gt;Rate limiter types&lt;/h2&gt;
&lt;p&gt;There are a number of different rate limiting algorithms available in .NET 7 to control the flow of requests. We will not go into detail in this post, but full details on each one can be found in the references link below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Concurrency&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Token bucket&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fixed window&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sliding window&lt;/code&gt; limit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the examples below, we make use of, and explore in a little more depth, the &lt;code&gt;fixed window&lt;/code&gt; and &lt;code&gt;token bucket&lt;/code&gt; limiters.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limiting-an-api"&gt;Limiting an API&lt;/h2&gt;
&lt;p&gt;The most obvious and well-known usage for rate limiting, is to apply it to an API endpoint to control how often it can get called. A few examples on why one might want to do this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To prevent API being overwhelmed with requests from any source&lt;/li&gt;
&lt;li&gt;To control how often a specific user can call the API based on account balance (or account tier)&lt;/li&gt;
&lt;li&gt;To limit the number of requests from a specific IP address (in the case of endpoint abuse)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the example below, a &lt;code&gt;fixed windows&lt;/code&gt; rate limiter will be applied to an endpoint. Two NuGet package references are required:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;System.Threading.RateLimiting&lt;/code&gt; - provides the based rate limiting functionality&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.AspNetCore.RateLimiting&lt;/code&gt; - provides functionality to integrate rate limiting into AspNetCore middleware&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two steps are involved when using rate limiting with an endpoint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defined the rate limit policy&lt;/li&gt;
&lt;li&gt;Apply the policy to an endpoint(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-policy"&gt;Define the policy&lt;/h3&gt;
&lt;p&gt;The policy is defined on startup by using the &lt;code&gt;UseRateLimiter&lt;/code&gt; extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
app.UseRateLimiter(new RateLimiterOptions()
    .AddFixedWindowLimiter(&amp;quot;getlimiter&amp;quot;, 
        new FixedWindowRateLimiterOptions(1, 
            QueueProcessingOrder.OldestFirst, 
            0, 
            TimeSpan.FromSeconds(2)))
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;FixedWindowLimiter&lt;/code&gt; is being used, with the policy name being &lt;em&gt;&amp;quot;getlimiter&amp;quot;&lt;/em&gt;. Effectively the policy states that: &lt;code&gt;During the 2 second window, only 1 request may be served, with no requests allowed to queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that the policy is defined, the next step is to apply it to an endpoint.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="apply-the-policy"&gt;Apply the policy&lt;/h3&gt;
&lt;p&gt;In the below example, we have a minimal api endpoint which returns the current datetime. Applying the rate limiter is as easy as invoking the &lt;code&gt;RequireRateLimiting&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getwithlimit&amp;quot;, () =&amp;gt;
{
    return DateTime.Now;

}).RequireRateLimiting(&amp;quot;getlimiter&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;RequireRateLimiting&lt;/em&gt; method is called with the policy name to apply specified.&lt;/p&gt;
&lt;p&gt;If the endpoint is now invoked more than once in a 2 second window, the called will receive a &lt;code&gt;503: Service unavailable&lt;/code&gt; response.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limiting-a-resource"&gt;Limiting a resource&lt;/h2&gt;
&lt;p&gt;It is also possible to control the flow of requests to any part of the code or resource using the rate limiting functionality.&lt;/p&gt;
&lt;p&gt;In the following example, we have an endpoint which can either &lt;code&gt;return data from a cache or from the database&lt;/code&gt;. We only want to &lt;em&gt;limit the number of requests which go to the database&lt;/em&gt; using a rate limiter.&lt;/p&gt;
&lt;h3 id="define-the-policy-1"&gt;Define the policy&lt;/h3&gt;
&lt;p&gt;First step again, is to define the policy.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;TokenBucketRateLimiter tokenLimiter = 
    new TokenBucketRateLimiter(
        new TokenBucketRateLimiterOptions(0, 
            QueueProcessingOrder.OldestFirst,
            0, 
            TimeSpan.FromSeconds(10), 
            5));

builder.Services.AddSingleton(tokenLimiter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;em&gt;TokenBucketRateLimiter&lt;/em&gt; is being used - it is defined and added as a singleton to the dependency injection container. Effectively the policy states that: &lt;code&gt;Every 10 second period, 5 tokens will be added to the bucket (with a max of 5 tokens in the bucket), with no requests allowed to queue&lt;/code&gt;. Once the tokens are all taken, no requests will be allowed until the bucket is replenished.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="apply-the-policy-1"&gt;Apply the policy&lt;/h3&gt;
&lt;p&gt;We can now inject the policy into a constructor, or API endpoint&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject the limiter as well as the DatabaseResource to limit
// the number of requests to
app.MapGet(&amp;quot;/limitresource&amp;quot;, (TokenBucketRateLimiter tokenLimiter, 
    DatabaseResource databaseAccess) =&amp;gt;
{
    // use Random to simulate if the database should be 
    // called or if the cache should be used
    var random = new Random();
    var shouldCallDatabase = random.Next(0, 2);

    // database should be called, rate limiting applies
    if (shouldCallDatabase == 1)
    {
        // try acquire a token
        var lease = tokenLimiter.Acquire();
        // if there was a token available
        // then we can call the database
        if (lease.IsAcquired)
        {
            return databaseAccess.GetData();
        }

        // otherwise, unable to call at this time
        return &amp;quot;Unable to retrieve data at this time&amp;quot;;
    }

    // from cache, no rate limiting
    return &amp;quot;Retrieved from cache&amp;quot;;

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The basic flow is to try &lt;em&gt;acquire&lt;/em&gt; a lease on a token from the rate limiter instance - if no token is available, the lease is not acquired and a relevent message is returned.&lt;br /&gt;
In this specific example, a &lt;code&gt;200 Success&lt;/code&gt; will still be returned in all branches of the flow, but this could be manually changed handled to change the HTTP response code based on the branch taken by the code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very useful and easy to configure feature coming with .NET 7. If already using an &lt;em&gt;API Management (APIM)&lt;/em&gt; tool, which usually has rate limiting functionality included, this feature might not be &lt;em&gt;as&lt;/em&gt; useful, but can still play its part. Often some internal traffic doesn't always go through the APIM, so the .NET rate limiting feature could be leveraged for those cases, and used in conjunction with the APIM.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-rate-limiting-for-dotnet/"&gt;Announcing Rate Limiting for .NET&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;150: 31-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/30-ef-query-enumerable</id>
		<title>Entity Framework: IQueryable vs IEnumerable</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/30-ef-query-enumerable" />
		<updated>2022-08-30T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When querying data using &lt;code&gt;Entity Framework (Core)&lt;/code&gt; the type of collection used before materializing the results drastically changes how the LINQ is translated and executed.&lt;/p&gt;
&lt;p&gt;Using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IQueryable&lt;/code&gt;: The LINQ is translated to SQL and executing on the database (SQL Server in my examples below)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IEnumerable&lt;/code&gt;: The data is retrieved, and then the LINQ applied to the full dataset in memory&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;In these examples, we have SQL database containing &lt;em&gt;Blog&lt;/em&gt; information. One of the tables, is the &lt;code&gt;Tag&lt;/code&gt; table which contains all the &lt;em&gt;tags&lt;/em&gt; which have been assigned to specific blog posts.&lt;/p&gt;
&lt;h3 id="query"&gt;Query&lt;/h3&gt;
&lt;p&gt;An important aspect to remember when using Entity Framework (Core) and LINQ, is that a call is only made to the database and the results materialized (stored in memory) when needed and explicitly asked for.&lt;/p&gt;
&lt;p&gt;To query all &lt;em&gt;Tags&lt;/em&gt; in the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// usual DbContext setup
var context = new DemoContext();

// query using the DbSet itself
DbSet&amp;lt;Tag&amp;gt; dbSetTags = context.Tags;
// materialize the results. The actual database
// call is done when ToList is called
var dbSetList = dbSetTags.ToList();

// query using IQueryable
IQueryable&amp;lt;Tag&amp;gt; queryableTags = context.Tags;
var queryList = queryableTags.ToList();

// Query using IEnumerable
IEnumerable&amp;lt;Tag&amp;gt; enumerableTags = context.Tags;
var enumerableList = enumerableTags.ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;em&gt;DbSet&lt;/em&gt; implements &lt;em&gt;IQueryable&lt;/em&gt;, which implements &lt;em&gt;IEnumerable&lt;/em&gt; - all of the above casts are valid.&lt;/p&gt;
&lt;p&gt;As mentioned above, the database is not actually queried until the data is explicitly asked for, which in the above examples, is when &lt;code&gt;ToList is called&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Executing the above code results in all three generating the same SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [t].[Id], [t].[DateCreated], [t].[Name], [t].[Used]
FROM [Tag] AS [t]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fairly straightforward and so far the results are as expected.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="filterordering"&gt;Filter/Ordering&lt;/h3&gt;
&lt;p&gt;When &lt;em&gt;filtering&lt;/em&gt; or &lt;em&gt;data ordering&lt;/em&gt; is applied however, things can go wrong if not done correctly. The same three examples as above will be used, but with a &lt;em&gt;filter&lt;/em&gt; applied using &lt;code&gt;Where&lt;/code&gt; and &lt;em&gt;ordering&lt;/em&gt; applied by using &lt;code&gt;OrderBy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// usual DbCOntext setup
var context = new DemoContext();

// query using the DbSet itself
DbSet&amp;lt;Tag&amp;gt; dbSetTagsFilter = context.Tags;
// apply filter, ordering and then materialize
var dbSetTagsFilterList = dbSetTagsFilter
    .Where(t =&amp;gt; t.Id &amp;gt; 50)
    .OrderBy(t =&amp;gt; t.DateCreated)
    .ToList();

// query using IQueryable
IQueryable&amp;lt;Tag&amp;gt; queryTagsFilter = context.Tags;
// apply filter, ordering and then materialize
var queryTagsFilterList = queryTagsFilter
    .Where(t =&amp;gt; t.Id &amp;gt; 50)
    .OrderBy(t =&amp;gt; t.DateCreated)
    .ToList();

// query using IEnumerable
IEnumerable&amp;lt;Tag&amp;gt; enumerableTagsFilter = context.Tags;
// apply filter, ordering and then materialize
var enumerableTagsFilterList = enumerableTagsFilter
    .Where(t =&amp;gt; t.Id &amp;gt; 50)
    .OrderBy(t =&amp;gt; t.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the surface, these might all look the same, however, when looking at the SQL generated there is a &lt;code&gt;fundamental difference&lt;/code&gt; between them.&lt;/p&gt;
&lt;p&gt;The first two, &lt;code&gt;DbSet&lt;/code&gt; and &lt;code&gt;IQueryable&lt;/code&gt; generate the following SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [t].[Id], [t].[DateCreated], [t].[Name], [t].[Used]
FROM [Tag] AS [t]
WHERE [t].[Id] &amp;gt; 50
ORDER BY [t].[DateCreated]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While the third method, using &lt;code&gt;IEnumerable&lt;/code&gt; generates the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [t].[Id], [t].[DateCreated], [t].[Name], [t].[Used]
FROM [Tag] AS [t]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When using &lt;code&gt;DBSet&lt;/code&gt; or &lt;code&gt;IQueryable&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The LINQ is translated into SQL and executed on the database. This limits the amount of data transferred from the database to the application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When using &lt;code&gt;IEnumerable&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First all the data is retrieved and then the filtering/ordering applied in memory. This leads to slower performance (as more data needs is transferred) and more memory usage&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When working with Entity Framework (Core) make sure to understand how the collections work, and which to use, when materialization occurs and how the LINQ gets translated - if done incorrectly, one could see a massive negative performance impact.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;149: 30-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/29-global-namespace</id>
		<title>Namespace-less types</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/29-global-namespace" />
		<updated>2022-08-29T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Types in C# &lt;code&gt;do not have to belong to a specific namespace&lt;/code&gt; - it is just standard convention that they do, however this is not a requirement. The &lt;code&gt;global&lt;/code&gt; alias, along with the namespace alias qualifier &lt;code&gt;::&lt;/code&gt; can be used to reference types without a namespace in the event of a &lt;em&gt;naming conflict&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Consider the following basic example - a simple wrapper class, &lt;em&gt;belonging to a namespace&lt;/em&gt;, which will output a string to the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public class ConsoleWrapper
{
    public static void OutputToConsole(string output)
    {
        Console.WriteLine(output);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usage is straight forward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public class Program
{
    public static void Main()
    {
        ConsoleWrapper.OutputToConsole(
            $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we reference a Nuget package in our project - it just so happens the require functionality is contained in the package, in a class also called &lt;code&gt;ConsoleWrapper&lt;/code&gt;, however, it &lt;code&gt;doesn't contain a namespace&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class ConsoleWrapper
{
    public static void Output(string output)
    {
        Console.WriteLine(output);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try reference the new class in our &lt;em&gt;Main&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public static void Main()
{
    // old class in same namespace as Main
    ConsoleWrapper.OutputToConsole(
        $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);

    // new class without a namespace
    ConsoleWrapper.Output(
        $&amp;quot;Written to console by instance of '{nameof(GlobalKeyword.ConsoleWrapper)}'&amp;quot;);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the following compile-time error occurs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'ConsoleWrapper' does not contain a definition for 'Output'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the newly introduced  &lt;em&gt;ConsoleWrapper&lt;/em&gt; has no namespace, we cannot fully qualify it to resolve the conflict. However, as it has no namespace, it gets put into the &lt;code&gt;global namespace&lt;/code&gt; which can be referenced using &lt;code&gt;global::&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public static void Main()
{
    // old class in same namespace as Main
    ConsoleWrapper.OutputToConsole(
        $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);

    // new class in no/global namespace
    global::ConsoleWrapper.Output(
        $&amp;quot;Written to console by instance of '{nameof(GlobalKeyword.ConsoleWrapper)}'&amp;quot;);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Problem solved!&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very rare issue to encounter, as it requires two unlikely scenarios to occur:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A type to not have a namespace&lt;/li&gt;
&lt;li&gt;The type without a namespace to have the same name as another type (either user defined, or reference)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The vast majority of types do have namespaces, so the chances of encountering this issue are small - however, if it is encountered, the &lt;code&gt;global&lt;/code&gt; alias can be used to resolve the conflict.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/namespace-alias-qualifier"&gt;:: operator (C# reference)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;148: 29-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/26-constructor-out</id>
		<title>Constructor out parameters</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/26-constructor-out" />
		<updated>2022-08-26T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Class constructors can contain &lt;code&gt;out or ref parameters&lt;/code&gt;, and operate just as they would on a normal method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usages"&gt;Usages&lt;/h2&gt;
&lt;p&gt;While not a very common feature to make use of in most code, below we'll look at a few use cases when an &lt;code&gt;out&lt;/code&gt; parameter on a constructor &lt;em&gt;might&lt;/em&gt; be useful. There may definitely be better ways of handling these specific use cases, but using an &lt;code&gt;out&lt;/code&gt; parameter is &lt;em&gt;a way to handle them&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dependent-entity"&gt;Dependent entity&lt;/h3&gt;
&lt;p&gt;Consider the situation when &lt;code&gt;instantiating a class, another class is created at the same time using the same information&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the below example, we have a &lt;code&gt;Product&lt;/code&gt; class to store product information (including the current price) and a &lt;code&gt;ProductPrice&lt;/code&gt; class to store the history of prices for the product.&lt;/p&gt;
&lt;p&gt;When creating a &lt;code&gt;Product&lt;/code&gt; record, &lt;code&gt;ProductPrice&lt;/code&gt; record should be created at the same time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(Guid.NewGuid(), &amp;quot;Green pants&amp;quot;, 99.99m);
var price = new ProductPrice
{
    Id = product1.Id,
    Price = product1.Price
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This could however also be done using an &lt;code&gt;out&lt;/code&gt; parameter. Consider the following &lt;em&gt;constructor&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product(Guid id, string name, decimal price, out ProductPrice productPrice)
{
    Id = id;
    Name = name;
    Price = price;

    productPrice = new ProductPrice 
    { 
        Id = id, 
        Price = price 
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which can then be called as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(Guid.NewGuid(), &amp;quot;Green pants&amp;quot;, 99.99m, out ProductPrice price);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More concise? Yes. A better solution? Debatably.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="generated-information"&gt;Generated information&lt;/h3&gt;
&lt;p&gt;Expanding on the above example, maybe the &lt;code&gt;Id of the Product is generated internally to the class&lt;/code&gt;, in the constructor. An &lt;code&gt;out&lt;/code&gt; parameter could be used to return the instance &lt;em&gt;Id&lt;/em&gt; from the constructor.&lt;/p&gt;
&lt;p&gt;Here the &lt;em&gt;Id&lt;/em&gt; is generated in the constructor, and assigned to the &lt;code&gt;out&lt;/code&gt; parameter as well as the &lt;em&gt;Id&lt;/em&gt; property of thd class itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product(string name, decimal price, out Guid id)
{
    id = Id = Guid.NewGuid();
    Name = name;
    Price = price;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usage of the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(&amp;quot;Green pants&amp;quot;, 99.99m, out Guid productId);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again - more concise than some alternatives? Yes. A better solution? Debatably.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not something I'd ever really considered, or ever required in 20 years of development - however it is an interesting feature. Maybe one day I might have a  a practical use to use it in production code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/MarusykRoman/status/1550995942576476162"&gt;Roman Marusyk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;147: 26-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/25-arraysegment</id>
		<title>Delimit an array with ArraySegment</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/25-arraysegment" />
		<updated>2022-08-25T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; structure can be used to represent only a portion of a larger array. A few use cases when &lt;code&gt;ArraySegment&lt;/code&gt; is useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when only a portion of a larger array needs to be passed as an argument to a method, &lt;code&gt;ArraySegment&lt;/code&gt; can be used to pass only the require portion of elements&lt;/li&gt;
&lt;li&gt;when wanting to perform operations on the array from multiple threads, &lt;code&gt;ArraySegment&lt;/code&gt; can be used to have each thread operation on a portion of the array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An important aspect of the &lt;code&gt;ArraySegment&lt;/code&gt; is that a &lt;code&gt;new array is not created&lt;/code&gt; - the &lt;code&gt;ArraySegment&lt;/code&gt; structure still points back to the original array.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the following examples, a line from a &lt;code&gt;csv file&lt;/code&gt; is being read into a &lt;code&gt;string array&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var artistCSVLine = &amp;quot;1,John,Mayer,1976,United States,www.johnmayer.com&amp;quot;;
var fullArtistArray = artistCSVLine.Split(&amp;quot;,&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also have a method to output each item in the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void OutputArray(string[] items)
{
    for (var i = 0; i &amp;lt; items.Length; i++)
    {
        Console.WriteLine(items[i]);
    }

    Console.WriteLine(&amp;quot;------&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the method, with the &lt;em&gt;fullArtistArray&lt;/em&gt; array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1
John
Mayer
1976
United States
www.johnmayer.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But suppose in our application we are only interested in the &lt;em&gt;artist Names and year of birth&lt;/em&gt;, how do we output only those values?&lt;/p&gt;
&lt;p&gt;(this example is very simplified for the sample, and not necessarily a production ready way of dealing with CSV records in this manner)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="without-arraysegment"&gt;Without ArraySegment&lt;/h3&gt;
&lt;p&gt;Without leveraging &lt;code&gt;ArraySegment&lt;/code&gt;, there are two common ways (in my experience) to get only a portion of an array:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Creating a separate array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define a new array
var portionArray = new string[3];
// set the values of the new array from the
// values of the original array
portionArray[0] = fullArtistArray[1];
portionArray[1] = fullArtistArray[2];
portionArray[2] = fullArtistArray[3];

// print out only the new array
OutputArray(portionArray);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, an additional array is created in memory and the information duplicated, so will use more memory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Manual checks for specific elements in the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void OutputArrayPortion(string[] items)
{
    for (var i = 0; i &amp;lt; items.Length; i++)
    {
        // only output items in specific
        // positions in the array
        if (i == 1 || i == 2 || i == 3)
        {
            Console.WriteLine(items[i]);
        }
    }
    Console.WriteLine(&amp;quot;------&amp;quot;);
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the original full array can passed to the method and a manual check is performed to only output items in specific positions in the array. While this does use no additional memory, its not sustainable. If the checks needs to be performed in multiple places in code (when outputting the data, when saving to a database etc) this approach makes the code not very maintainable.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While either of these approaches could still work, a better approach is to leverage the &lt;code&gt;ArraySegment&lt;/code&gt; class.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="with-arraysegment"&gt;With ArraySegment&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; class can be used to represent only a portion (or segment) of the original array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create a segment, from fullArtistArray, starting at position 1
// and include 3 items from the original array
var artistSegment = new ArraySegment&amp;lt;string&amp;gt;(fullArtistArray, 1, 3);
OutputArraySegment(artistSegment);

// ------

public void OutputArraySegment(ArraySegment&amp;lt;string&amp;gt; items)
{
    for (var i = 0; i &amp;lt; items.Count; i++)
    {
        Console.WriteLine(items[i]);
    }
    Console.WriteLine(&amp;quot;------&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;John
Mayer
1976
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned, an important feature of the &lt;code&gt;ArraySegment&lt;/code&gt; is that a &lt;code&gt;new array is not created&lt;/code&gt;, but the class is a &lt;code&gt;structure which points to a segment of the original array&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This can be demonstrated as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var artistCSVLine = &amp;quot;1,John,Mayer,1976,United States,www.johnmayer.com&amp;quot;;
var fullArtistArray = artistCSVLine.Split(&amp;quot;,&amp;quot;);

// create a new array segment
var artistSegment = new ArraySegment&amp;lt;string&amp;gt;(fullArtistArray, 1, 3);

// change the item at index 3 in the ORIGINAL array
fullArtistArray[3] = &amp;quot;1977&amp;quot;;

// print out the array segment
OutputArraySegment(artistSegment);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;John
Mayer
1977
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The year value output is the &lt;code&gt;updated value&lt;/code&gt;, even though it &lt;code&gt;was updated on the original array&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; provides an easy, memory efficient way of working with portions of a larger original array, and should be leveraged whenever possible of the other &lt;em&gt;non-array-segment&lt;/em&gt; techniques mentioned above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.arraysegment-1?view=net-6.0"&gt;ArraySegment Struct&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;146: 25-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/08/24-route-filter</id>
		<title>Route handler filters in .NET 7</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/08/24-route-filter" />
		<updated>2022-08-24T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with .NET 7 (most likely, .NET 7 is still in preview so its not 100% guaranteed to be included), is the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; interface, which allows for &lt;em&gt;intercepting&lt;/em&gt;  requests/response to and from a specific minimal endpoint.&lt;/p&gt;
&lt;p&gt;This enabled &lt;code&gt;cross-cutting concerns to be coded once&lt;/code&gt;, and then applied to the relevent endpoints. They operate &lt;em&gt;similar&lt;/em&gt; to the .NET &lt;code&gt;middleware&lt;/code&gt; but are applied at a specific endpoint level, and not a level higher targeting all routes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iroutehandlerfilter"&gt;IRouteHandlerFilter&lt;/h2&gt;
&lt;h3 id="definition"&gt;Definition&lt;/h3&gt;
&lt;p&gt;First, lets define the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; implementation to later be applied to a minimal api endpoint. In the below example, a router handler filter is defined to measure how long a call to the endpoint takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class RouteLogger : IRouteHandlerFilter
{
    public async ValueTask&amp;lt;object?&amp;gt; InvokeAsync(RouteHandlerInvocationContext context, 
        RouteHandlerFilterDelegate next)
    {
        // record the time before the endpoint (or next filter is called)
        Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
            $&amp;quot;RouteLogger - before endpoint called&amp;quot;);

        var result = await next.Invoke(context);

        // record the time after the endpoint (or next filter is called)
        Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
            $&amp;quot;RouteLogger - after endpoint called&amp;quot;);

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; interface only has one method to implement - &lt;em&gt;InvokeAsync&lt;/em&gt;, which takes two parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteHandlerInvocationContext&lt;/code&gt;:  this contains a reference to the &lt;em&gt;HttpContext&lt;/em&gt;, as well as a list of &lt;em&gt;Arguments&lt;/em&gt; which can be modified to be passed between filters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteHandlerFilterDelegate&lt;/code&gt;: this contains a delegate to the next &lt;em&gt;IRouteHandlerFilter&lt;/em&gt; implementation if multiple have been applied, otherwise it will route to the &lt;em&gt;actual endpoint handler&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the above sample, a message is logged when the method is entered, the &lt;em&gt;next&lt;/em&gt; delegate is invoked, and then a message logged just before the return. If &lt;em&gt;next&lt;/em&gt; is not invoked, the pipeline to the endpoint is &lt;code&gt;short-circuited&lt;/code&gt; and the &lt;code&gt;endpoint handler will never be invoked&lt;/code&gt;. This allows checks or validation to be performed (authentication checks for example), and &lt;em&gt;short-circuit&lt;/em&gt; if the checks fail.&lt;/p&gt;
&lt;h3 id="application"&gt;Application&lt;/h3&gt;
&lt;p&gt;Applying the filter to the endpoint is very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();

app.MapGet(&amp;quot;/endpoint&amp;quot;, () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Endpoint handler&amp;quot;);

    return &amp;quot;Endpoint has been called&amp;quot;;
}).AddFilter&amp;lt;RouteLogger&amp;gt;(); // add the filter

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the endpoint definition, the &lt;em&gt;AddFilter&lt;/em&gt; method is called, with the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; implementation specified. Multiple implementations can be linked together to form a pipeline to the endpoint handler.&lt;/p&gt;
&lt;?# InfoBlock ?&gt;
&lt;p&gt;The above was written using &lt;strong&gt;.NET 7 Preview 5&lt;/strong&gt;. AddFilter() has been renamed to &lt;em&gt;AddRouteHandlerFilter()&lt;/em&gt; in Preview 6 and will be renamed again to &lt;em&gt;AddEndpointFilter()&lt;/em&gt; starting in Preview 7.&lt;/p&gt;
&lt;?#/ InfoBlock ?&gt;
&lt;hr /&gt;
&lt;h2 id="middleware"&gt;Middleware&lt;/h2&gt;
&lt;p&gt;As mentioned in the introduction, &lt;em&gt;route handler filters&lt;/em&gt; act similar to the middleware. Where &lt;code&gt;route handler filters are applied to specific endpoints&lt;/code&gt;, &lt;code&gt;middleware is applied to requests coming in on any route&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below a middleware function is defined, which also performs logging:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// define the middleware
// The Func defined is called on every 
// request to any endpoints
app.Use(async (context, next) =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Middleware - before endpoint called&amp;quot;);

    await next(context);

    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Middleware - after endpoint called&amp;quot;);
});

app.MapGet(&amp;quot;/endpoint&amp;quot;, () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Endpoint handler&amp;quot;);

    return &amp;quot;Endpoint has been called&amp;quot;;
}).AddFilter&amp;lt;RouteLogger&amp;gt;();

app.Run();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The middleware has a similar structure to a &lt;em&gt;route handler filter&lt;/em&gt;, with an &lt;em&gt;HttpContext&lt;/em&gt; and a &lt;em&gt;RequestDelegate&lt;/em&gt; as arguments. The &lt;em&gt;RequestDelegate&lt;/em&gt; argument &lt;code&gt;next&lt;/code&gt; is also invoked, to call the next middleware component, or the endpoint handler. If not called, &lt;em&gt;short-circuiting&lt;/em&gt; will occur, just as with the &lt;em&gt;route handler filter&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the above example, the &lt;code&gt;middleware was defined as a lambda function&lt;/code&gt; while the &lt;code&gt;filter was defined as a concrete IRouteHandlerFilter implementation&lt;/code&gt; - either of these can also be defined the either way. Middleware could be defined as a concrete implementation, and a route handler filter could be defined as a lambda function.&lt;br /&gt;
If there are a number of middleware or route handler filter components being used, it's usually better to use the concrete implementation method to keep the startup code cleaner, and keep all pipeline logic in one place (their own folder, for example).&lt;/p&gt;
&lt;p&gt;Executing the above code and browsing to the &lt;code&gt;/endpoint&lt;/code&gt;, results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;07/27/2022 08:42:27.851: Middleware - before endpoint called
07/27/2022 08:42:27.859: RouteLogger - before endpoint called
07/27/2022 08:42:27.860: Endpoint handler
07/27/2022 08:42:27.860: RouteLogger - after endpoint called
07/27/2022 08:42:27.865: Middleware - after endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the &lt;code&gt;middleware is called first&lt;/code&gt;, before the http request is passed onto the endpoint specific &lt;code&gt;route handler filter(s)&lt;/code&gt; (if any are defined), before the &lt;code&gt;actual endpoint handler&lt;/code&gt; is called.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, &lt;code&gt;middleware&lt;/code&gt; is applied to all endpoints, so if some middleware logic is only applicable to a certain endpoint(s), then currently filter logic needs to be specific in the middleware to determine if the middleware functionality should be applied to the request or not.
Having the ability to granularly apply &lt;code&gt;route handler filter&lt;/code&gt; &amp;quot;middleware&amp;quot; on specific endpoint(s) allows for greater flexibility and is a welcome addition which brings functionality closer to being on par with that of MVC (which has ActionFilter)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/minimal-api-route-handler-filters"&gt;Minimal API Route Handler Filters&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;145: 24-08-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>