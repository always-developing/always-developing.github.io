<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-11-22T03:55:20Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/22-ef-faster-delete</id>
		<title>Efficient EF deletion</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/22-ef-faster-delete" />
		<updated>2022-11-22T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using Entity Framework to perform a delete (prior to EF7), first the record in question is required to be &lt;em&gt;selected from the table&lt;/em&gt; (so that EF change tracking has visibility of it), then is &lt;em&gt;marked as deleted&lt;/em&gt;, and then the actual database delete is performed with  &lt;em&gt;SaveChanges&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Khalid Abuhakmeh has a very interesting idea, which eliminates the need for the extra round trip to &lt;em&gt;select&lt;/em&gt; the data - manually add the item to EF change tracking (without first checking the database), &lt;em&gt;mark it as deleted&lt;/em&gt;, and &lt;em&gt;save the changes&lt;/em&gt;. If a specific exception occurs because the record is not available for deletion, handle that separately.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="use-case"&gt;Use case&lt;/h2&gt;
&lt;p&gt;In our use case, we will define a &lt;em&gt;Delete&lt;/em&gt; endpoint, which when called will delete the &lt;em&gt;Blog&lt;/em&gt; record using the supplied &lt;em&gt;Id&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="traditional-method"&gt;Traditional method&lt;/h3&gt;
&lt;p&gt;Below is a sample of the "traditional" method of handling the use case:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// context is injected from the DI container
// id is supplied as part of the url
app.MapDelete("/blog/v1/{id:int}", async (DemoContext context, int id) =&amp;gt;
{
    // first lookup the blog by the id
    var blog = await context.Blogs.FindAsync(id);

    // if the blog was found
    if(blog != null)
    {
        // mark it as deleted
        context.Remove(blog);
    }

    await context.SaveChangesAsync();

});
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;First, a query is performed against the database to ensure that a &lt;em&gt;Blog&lt;/em&gt; with the specified Id exists (with &lt;em&gt;FindAsync&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;In the case when the record does exist, the row will start being tracked by Entity Framework's change tracker&lt;/li&gt;
&lt;li&gt;The record is flagged as delete, with the &lt;em&gt;Remove&lt;/em&gt; command&lt;/li&gt;
&lt;li&gt;The changes are finally applied to the database, with &lt;em&gt;SaveChangesAsync&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With this method, there are two round trips to the database - in steps 1 and 4.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="efficient-method"&gt;Efficient Method&lt;/h3&gt;
&lt;p&gt;With the more efficient method, one database round trip can be eliminated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// context is injected from the DI container
// id is supplied as part of the url
app.MapDelete("/blog/v1/{id:int}", async (DemoContext context, int id) =&amp;gt;
{
    try
    {
        // create an instance of the object with the
        // supplied id. 
        var blog = new Blog { Id = id };
        // make the change tracker aware of this object
        var contextBlog = context.Blogs.Attach(blog);
        // mark it as deleted
        contextBlog.State = EntityState.Deleted;

        // delete
        await context.SaveChangesAsync();
    }
    catch(DbUpdateConcurrencyException ex)
    {
        Console.WriteLine("Swallowing delete exception.");
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this method:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instead of checking in the database that a record exists with the supplied &lt;em&gt;Id&lt;/em&gt;, it is &lt;em&gt;assumed a record does already exist&lt;/em&gt; with the id&lt;/li&gt;
&lt;li&gt;A record, with just the Id (the primary key value) set, is created, attached to the change tracker, and marked as deleted&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SaveChangesAsync&lt;/em&gt; is then called to perform the actual delete on the database&lt;/li&gt;
&lt;li&gt;If a record with that specific Id does in fact not exist, an exception will be thrown - which is caught and swallowed (with logging)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The outcome in both cases is the same, but an expensive database round trip has been eliminated.&lt;/p&gt;
&lt;p&gt;In the references link below, Khalid Abuhakmeh has additional ideas and code samples on how this functionality can be cleaned and wrapped into an extension method to make usage even easier.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having run into this exact issue before, this method is very interesting. Exceptions do have an overhead, but the overhead of a database round trip will almost always out-weigh the exception overhead. Definitely consider the "efficient" method if the "traditional pattern is used throughout code.
Having said that, EF7 introduces &lt;a href="https://alwaysdeveloping.net/09/23-ef-bulk-update"&gt;Bulk Update/Delete functionality&lt;/a&gt; which will allow for this nativity in the EF framework - so this method will become obsolete with time.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/more-efficient-deletes-with-entity-framework-core"&gt;More Efficient Deletes With Entity Framework Core&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;207: 22-11-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/21-list-convertall</id>
		<title>List ConvertAll</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/21-list-convertall" />
		<updated>2022-11-21T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;List&lt;/code&gt; class has a &lt;code&gt;ConvertAll&lt;/code&gt; method which allows for the conversion of items in a list from one type to another. It operates similar to the LINQ &lt;code&gt;Select&lt;/code&gt; method, but in some use cases will out-perform the LINQ counterpart.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the below example, we have a List of &lt;code&gt;TypeA&lt;/code&gt;, and would like to convert this list to a a list of &lt;code&gt;TypeB&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;The types:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class TypeA
{
    public string TypeAValue { get; set; }
}

public class TypeB
{
    public string TypeBValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Building up a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;TypeA&amp;gt; types = new()
{
  new TypeA(),
  new TypeA(),
  new TypeA(),
  new TypeA(),
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a list ot &lt;em&gt;TypeA&lt;/em&gt;, we'll look at a couple of ways to convert to a list of &lt;em&gt;TypeB&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="linq-select"&gt;LINQ Select&lt;/h3&gt;
&lt;p&gt;This is the more &amp;quot;traditional&amp;quot; way of converting a list (or IEnumerable) from one type to another:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var typeBList = types
    .Select(a =&amp;gt; new TypeB { TypeBValue = a.TypeAValue })
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;em&gt;Select&lt;/em&gt; will operate on &lt;em&gt;TypeA&lt;/em&gt; and instantiate a &lt;em&gt;TypeB&lt;/em&gt; for each &lt;em&gt;TypeA&lt;/em&gt;, setting the instance properties. The output of this is a list of &lt;em&gt;TypeB&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="list-convertall"&gt;List ConvertAll&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ConvertAll&lt;/code&gt; usage is similar to that of the &lt;em&gt;Select&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var typeBList = types
    .ConvertAll(type =&amp;gt; new TypeB { TypeBValue = type.TypeAValue });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each item in the list, a &lt;em&gt;TypeB&lt;/em&gt; instance is instantiated and the properties set with the values from the &lt;em&gt;TypeA&lt;/em&gt; instance.&lt;/p&gt;
&lt;p&gt;A note: &lt;code&gt;ConvertAll&lt;/code&gt; is only available on &lt;em&gt;List&lt;/em&gt;, so if working with an IEnumerable implementation, the &lt;em&gt;ToList&lt;/em&gt; method would need to be called to convert the collection to a list.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;h3 id="items"&gt;10 Items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;194.9 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.99 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;29.46 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;177.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0713&lt;/td&gt;
&lt;td style="text-align: right;"&gt;448 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;156.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.43 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.92 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;143.9 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.82&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.16&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0598&lt;/td&gt;
&lt;td style="text-align: right;"&gt;376 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.84&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With only 10 items in the list, the the &lt;code&gt;ConvertAll&lt;/code&gt; method is faster, and more memory performant than the LINQ &lt;code&gt;Select&lt;/code&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="items-1"&gt;10 000 Items&lt;/h3&gt;
&lt;p&gt;As the number of items in the list increases, the performance metrics of the two two methods converge:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;175.6 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.90 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;32.15 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;189.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;50.7813&lt;/td&gt;
&lt;td style="text-align: right;"&gt;25.3906&lt;/td&gt;
&lt;td style="text-align: right;"&gt;312.63 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;174.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.42 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.07 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;173.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.97&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.15&lt;/td&gt;
&lt;td style="text-align: right;"&gt;50.7813&lt;/td&gt;
&lt;td style="text-align: right;"&gt;25.3906&lt;/td&gt;
&lt;td style="text-align: right;"&gt;312.55 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With 10 000 items, the two methods effectively perform the same, and both use the same amount of memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="items-2"&gt;100 000 Items&lt;/h3&gt;
&lt;p&gt;The same results can be seen with 100 000 records, as was seen with 10 000 record:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen2&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.586 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1298 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2561 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;515.6250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;328.1250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;179.6875&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.05 MB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.236 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1199 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1970 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.05&lt;/td&gt;
&lt;td style="text-align: right;"&gt;515.6250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;320.3125&lt;/td&gt;
&lt;td style="text-align: right;"&gt;179.6875&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.05 MB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The two methods effectively perform the same, and both use the same amount of memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If currently using &lt;code&gt;Select&lt;/code&gt;, there is not much reason to update code to switch to &lt;code&gt;ConvertAll&lt;/code&gt; - except if micro performance improvements are critical to your application. However if performance is so critical for the application, LINQ is probably not even being used in the first place.&lt;/p&gt;
&lt;p&gt;Having said all that, it is interesting the &lt;code&gt;ConvertAll&lt;/code&gt; method is available and does have performance improvements over using LINQ &lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/advanced-linq/"&gt;Advanced LINQ&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;206: 21-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/18-succinct-init</id>
		<title>Succinct initialization pattern</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/18-succinct-init" />
		<updated>2022-11-18T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Sometimes objects need to be initialized &lt;em&gt;lazily&lt;/em&gt; - two newer C# features, the &lt;em&gt;null-coalescing assignment operator&lt;/em&gt; &lt;code&gt;??=&lt;/code&gt; and the &lt;em&gt;target-typed new expression&lt;/em&gt; makes the lazy initialization cleaner and more succinct.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the examples, we have a &lt;code&gt;Album&lt;/code&gt; class which contains an &lt;em&gt;optional&lt;/em&gt; list of &lt;code&gt;Song&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Album
{
    private readonly string _name;

    private readonly List&amp;lt;Song&amp;gt; _songs;

    public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
    {
        _name = name;
        _songs = songs;

        // See examples below on how to 
        // do the _songs initialization
    }
}

public class Song
{
    private readonly string _name;

    public Song(string name)
    {
        _name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If no &lt;code&gt;Song&lt;/code&gt; list is passed into the constructor, then the &lt;code&gt;_song&lt;/code&gt; variable needs to be initialized to an &lt;em&gt;empty list&lt;/em&gt;. Doing this will prevent having to have checks throughout the code to determine if the Song list is null or not. There are multiple ways to do this, but this post focuses on the &amp;quot;more traditional&amp;quot; method, and the new &amp;quot;succinct&amp;quot; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="traditional-lazy-init"&gt;Traditional lazy init&lt;/h3&gt;
&lt;p&gt;Traditionally (before any of the newer C# features were introduced), the constructor might look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
{
    _name = name;
    _songs = songs;

    // check if _songs is null
    if(_songs == null)
    {
        // initialize to an empty list
        _songs = new List&amp;lt;Song&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable is checked to determine if its &lt;em&gt;null&lt;/em&gt; or not, and if it is, then explicitly initialized to an empty list. Nothing inherently wrong with this approach - it just takes four lines of code to &lt;em&gt;lazily initialize a variable&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="succinct-lazy-init"&gt;Succinct lazy init&lt;/h3&gt;
&lt;p&gt;As mentioned, the two newer C# features allow for this code to be more succinct:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
{
    _name = name;
    _songs = songs;

    _songs ??= new();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;null-coalescing assignment operator&lt;/em&gt; &lt;code&gt;??=&lt;/code&gt; assigns the value of the right-hand side to the left-hand side, only if the left-hand side is null&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;target-typed new&lt;/code&gt; expression, &lt;code&gt;new&lt;/code&gt; allows for the inferring of the type from the declaration, instead of having to explicitly specify the type in full&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Four lines of code have been reduced to one!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very minor change, which is not a necessity or requirement when coding - however is does result in cleaner, more succinct code. Over time, it also does reduce coding time by reducing the number of key strokes required by the developer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidfowl/status/1586592671296290816"&gt;David Fowler Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;205: 18-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/17-local-attributes</id>
		<title>Local functions and attributes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/17-local-attributes" />
		<updated>2022-11-17T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;local functions&lt;/code&gt;, it is possible to decorate them, as well as their parameters, with &lt;code&gt;attributes&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="local-function"&gt;Local function&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Local functions&lt;/code&gt; are methods of a type that are nested in another member. They can only be called from their containing member:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{

    // Containing method
    public void DoProcessing()
    {
        // local function/method
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        PerformInternalLogic();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above sample, the &lt;em&gt;PerformInternalLogic&lt;/em&gt; method is a &lt;code&gt;local method&lt;/code&gt; nested in the &lt;em&gt;DoProcessing&lt;/em&gt; method, and can only be called from within the method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="attributes"&gt;Attributes&lt;/h2&gt;
&lt;h3 id="method-attribute"&gt;Method attribute&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Method targeting&lt;/em&gt; attributes can be used on local functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{
    // Containing method
    public void DoProcessing()
    {
        // local function/method
        [Obsolete(&amp;quot;This will be deprecated. Not useful for consumers of your method&amp;quot;)]
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        PerformInternalLogic();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, the &lt;code&gt;Obsolete&lt;/code&gt; attribute was used to decorate the &lt;em&gt;PerformInternalLogic&lt;/em&gt; method (as an indicator that the local method is obsolete and will be removed in future)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="parameter-attribute"&gt;Parameter attribute&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Parameter targeting&lt;/em&gt; attributes can also be used on &lt;em&gt;local function parameters&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{
    // Containing method
    public void DoProcessing()
    {
        // local function/method
        [Obsolete(&amp;quot;This will be deprecated. Not useful for consumers of your method&amp;quot;)]
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        // local function/method
        void PerformOtherInternalLogic([CallerMemberName] string memberName = &amp;quot;&amp;quot;)
        {
            Console.WriteLine($&amp;quot;Logic being performed called from {memberName}&amp;quot;);
        }

        PerformInternalLogic();

        PerformOtherInternalLogic();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;CallerMemberName&lt;/code&gt; attribute us applied to the parameter of the &lt;em&gt;PerformOtherInternalLogic&lt;/em&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A fairly niche use case, but if required, it is useful to know it is possible to add attributes to local functions.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.okyrylchuk.dev/a-comprehensive-overview-of-c-9-features#heading-8-attributes-on-local-functions"&gt;8. Attributes on Local Functions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;204: 17-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/16-implicit-builder</id>
		<title>Builder pattern implicit conversions</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/16-implicit-builder" />
		<updated>2022-11-16T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Usually when using the &lt;code&gt;builder pattern&lt;/code&gt;, a final &lt;code&gt;Build&lt;/code&gt; method (or similarly named method) is invoked to generate the &lt;em&gt;final entity&lt;/em&gt; from the &lt;em&gt;builder entity&lt;/em&gt;. Using an &lt;code&gt;implicit operator&lt;/code&gt;, this final step can be removed, and the &lt;em&gt;final entity&lt;/em&gt; can &lt;code&gt;automatically be generated&lt;/code&gt; from the &lt;em&gt;builder entity&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In these examples, there is a simple &lt;code&gt;Order&lt;/code&gt; entity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record Order(int Id, int lineItemCount, double Total);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is also an &lt;code&gt;OrderBuilder&lt;/code&gt; class, which is used to build an &lt;code&gt;Order&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class OrderBuilder
{
    // store some order information
    private int _id;
    private int _lineItemCount;
    private double _total;

    // method to give an order an id
    public OrderBuilder WithId(int Id)
    {
        _id = Id;
        return this;
    }

    // add a simple line item to the order
    public OrderBuilder WithLineItem(double lineItemAmount)
    {
        _lineItemCount++;
        _total += lineItemAmount;

        return this;
    }

    // create an Order from the OrderBuilder information
    public Order Build()
    {
        return new Order(_id, _lineItemCount, _total);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="build-method"&gt;Build method&lt;/h3&gt;
&lt;p&gt;Usage of the above &lt;em&gt;builder&lt;/em&gt; is easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var order = new OrderBuilder()
    .WithId(100) // give the order an id
    .WithLineItem(99) // add line items
    .WithLineItem(149)
    .Build(); // remember to build!

Console.WriteLine(order);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above is the typical usage of the &lt;em&gt;builder pattern&lt;/em&gt; - building up the entity using various methods, and then at the end calling a &lt;code&gt;Build&lt;/code&gt; method to create the final entity (&lt;code&gt;Order&lt;/code&gt; in this example) using the information supplied to the &lt;em&gt;builder&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The output of the order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Order { Id = 100, lineItemCount = 2, Total = 248 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing inherently wrong or incorrect with this code or approach - however an implicit operator can be added to the &lt;code&gt;OrderBuilder&lt;/code&gt; class to make the pattern and classes even easier to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="implicit"&gt;Implicit&lt;/h3&gt;
&lt;p&gt;Adding the following &lt;code&gt;implicit operator&lt;/code&gt; to the &lt;em&gt;OrderBuilder&lt;/em&gt; class, allows for the &lt;code&gt;Build&lt;/code&gt; method to &lt;em&gt;automatically be invoked&lt;/em&gt; when converting the &lt;em&gt;OrderBuilder&lt;/em&gt; instance to an &lt;em&gt;Order&lt;/em&gt; instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static implicit operator Order(OrderBuilder b) =&amp;gt; b.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the above added to the &lt;em&gt;OrderBuilder&lt;/em&gt; class, the following is now possible:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// instead of &amp;quot;var&amp;quot;, the actual type
// Order is used
Order order = new OrderBuilder()
    .WithId(101)
    .WithLineItem(100)
    .WithLineItem(29);
// No Build required!

Console.WriteLine(order);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this code snippet, as the &lt;em&gt;OrderBuilder&lt;/em&gt; is being converted to &lt;em&gt;Order&lt;/em&gt; implicitly, the &lt;code&gt;implicit operator&lt;/code&gt; is called which calls the &lt;em&gt;Build&lt;/em&gt; method to convert the &lt;em&gt;OrderBuilder&lt;/em&gt; to an &lt;em&gt;Order&lt;/em&gt; automatically. No need for the &lt;code&gt;Build&lt;/code&gt; method to be used!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small update to the code, but for the developers consuming the classes, the overall &lt;em&gt;developer experience&lt;/em&gt; is improved. This gives the developer the flexibility to use the class how they would like - either using the &lt;em&gt;Build&lt;/em&gt; method, or doing the &lt;em&gt;implicit conversion&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://josef.codes/bonus-builder-pattern-with-the-implicit-operator-using-c-sharp/"&gt;Bonus: Builder Pattern with the implicit operator using c#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;203: 16-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index</id>
		<title>Foreach loops and indexes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index" />
		<updated>2022-11-15T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Often when iterating through a list using a &lt;code&gt;foreach&lt;/code&gt; loop, an index to the item's position in the list is also required - instead of using a separate &lt;em&gt;index variable&lt;/em&gt;, a &lt;code&gt;tuple can be used to keep track of the item and it's index&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="manually-tracking-index"&gt;Manually tracking index&lt;/h2&gt;
&lt;p&gt;Sometimes while iterating, the index of the item in the list is required - usually this is done by creating a separate variable and manually increasing it in each iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// variable used to keep track of the index
int loopIndex = 0;
foreach(var item in list)
{
    // access the item and the index
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {loopIndex}&amp;quot;);

    // don't forget to increase the index
    loopIndex++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the item from the list can be accessed, as well as the index (position) of the item in the list. The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach is entirely valid, however it does require additional effort, and the developer needs to remember to increase the index variable. There is a cleaner, simpler approach (however, it &lt;em&gt;might&lt;/em&gt; come with a performance cost)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="tuple-index"&gt;Tuple index&lt;/h2&gt;
&lt;p&gt;Instead of manually creating and incrementing an index variable, this can be done automatically &lt;em&gt;with the foreach loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// instead of iterating through the list directly
// select the items of the list into a tuple, along
// with the index
foreach(var (item, index) in 
    list.Select((item, index) =&amp;gt; (item, index)))
{
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {index}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the items in the list are select into a list of &lt;em&gt;tuples&lt;/em&gt;, each tuple containing the item itself, as well as the index. Iterating over this new list gives us access to both these values.&lt;/p&gt;
&lt;p&gt;The output is the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cleaner, simpler and less prone to errors (forgetting to increment the index manually)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively simple tip, but one which does make things easier as a developer -  however depending on the list size and the list type, could result in a performance hit. If the list is generally relatively small, the performance hit shouldn't be noticeable and the code is cleaner. But still perform benchmark and use the best solution for your use case&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidpine7/status/1584553974236971008"&gt;David Pine Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;202: 15-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison</id>
		<title>String comparison with StringComparer</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison" />
		<updated>2022-11-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When comparing strings, instead of using &lt;code&gt;ToLower()&lt;/code&gt; (or &lt;code&gt;ToUpper&lt;/code&gt;) with the comparison operator &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;StringComparer.OrdinalIgnoreCase.Equals&lt;/code&gt; can be used, which is faster and uses less memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;There are a number of different ways to compare strings in C# - this post will explore a number of these methods, as well as compare their performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="section"&gt;==&lt;/h3&gt;
&lt;p&gt;The most basic method is to use the comparison operator &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using ==&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1 == value2}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1 == value3}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using ==
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with this approach is that the &lt;em&gt;case of the string is not taken into account&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tolowertoupper"&gt;ToLower/ToUpper&lt;/h3&gt;
&lt;p&gt;An often use method, is to use the comparison operator, but to &lt;code&gt;ToUpper&lt;/code&gt; or &lt;code&gt;ToLower&lt;/code&gt; the string for comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using == and ToLower&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToLower() == value2.ToLower()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToLower() == value3.ToLower()}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

Console.WriteLine(&amp;quot;Using == and ToUpper&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToUpper() == value2.ToUpper()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToUpper() == value3.ToUpper()}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using == and ToLower
value1 and value2: True
value1 and value3: False
-----
Using == and ToUpper
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both methods yield the same, accurate result.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="string.equals"&gt;string.Equals&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;string&lt;/code&gt; class has an &lt;code&gt;Equals&lt;/code&gt; method, which can also be used for comparison. One version is a &lt;em&gt;static method&lt;/em&gt;, and the other is an &lt;em&gt;instance method&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

// instance Equals method
Console.WriteLine(&amp;quot;Using instance Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.Equals(value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.Equals(value3)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

// Static Equals method
Console.WriteLine(&amp;quot;Using static Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using instance Equals
value1 and value2: False
value1 and value3: False
-----
Using static Equals
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basic version of &lt;code&gt;Equals&lt;/code&gt; does not take the string case into account - however there is an additional parameter which can be passed to the &lt;code&gt;Equals&lt;/code&gt; method to define how the comparison is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using static Equals OrdinalIgnoreCase&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using string.Equals OrdinalIgnoreCase
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="stringcomparer"&gt;StringComparer&lt;/h3&gt;
&lt;p&gt;The final method is using &lt;code&gt;StringComparer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using StringComparer&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {StringComparer.OrdinalIgnoreCase.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {StringComparer.OrdinalIgnoreCase.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using StringComparer
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Finally, we can benchmark all the different methods:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BasicComparison&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.972 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0392 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0348 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.974 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToLower&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.073 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.8145 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7619 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.187 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.34&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.61&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToUpper&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.095 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.6650 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.7548 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.910 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.74&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.32&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringInstanceEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.903 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0465 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0388 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.912 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringStaticEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.896 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0272 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0227 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.899 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringEqualOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.083 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1480 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1584 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.078 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.09&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringComparerOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.770 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0669 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0559 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.762 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.42&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, once can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In all instances where the case of the string is taken into account, performance is slower&lt;/li&gt;
&lt;li&gt;The often used &lt;code&gt;ToUpper/ToLower&lt;/code&gt; method is the slowest a large margin, and the only method to use memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringComparer&lt;/code&gt; is the most performant technique to use when a comparison needs to be done while ignoring the case&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Realistically, in most applications the performance of a string comparison is not going to have any material effect on performance. However if the application does a large number of string comparisons, the accumulative effect could be slightly noticeable and it might be worth investigating the use of &lt;code&gt;StringComparer&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/Tullo/status/1583491663577481219"&gt;&amp;#64;Tullo Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;201: 14-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/11-list-add-performance</id>
		<title>List AddRange performance</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/11-list-add-performance" />
		<updated>2022-11-11T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple items need to be added to a &lt;code&gt;List&lt;/code&gt;, using the &lt;code&gt;AddRange&lt;/code&gt; method is generally significantly more performant than using the &lt;code&gt;Add&lt;/code&gt; method - however, in some scenarios it might actually be slower!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;In all of the below examples, an initial List of 10, 1000 and 10000 items is used as a source and transferred transferer into another destination List.&lt;/p&gt;
&lt;h3 id="one-at-a-time"&gt;One at a time&lt;/h3&gt;
&lt;p&gt;In this benchmark, the &lt;code&gt;Add&lt;/code&gt; method is used to add items to a destination list, one at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void AllOneAtTime()
{
    var newList = new List&amp;lt;int&amp;gt;();

    foreach(var item in items)
    {
        newList.Add(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="filtered-one-at-a-time"&gt;Filtered one at a time&lt;/h3&gt;
&lt;p&gt;Here, only certain items are added to the destination list (this divisible by 2). A check is performed, and only if it passes is the specific item added to the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void FilteredOneAtTime()
{
    var newList = new List&amp;lt;int&amp;gt;();

    foreach (var item in items)
    {
        // only if divisible by 2
        if (item % 2 == 0)
        {
            newList.Add(item);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="add-range"&gt;Add range&lt;/h3&gt;
&lt;p&gt;In this benchmark, the entire source list is copied to the destination list using the &lt;code&gt;AddRange&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void AllOnce()
{
    var newList = new List&amp;lt;int&amp;gt;();

    newList.AddRange(items);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="filtered-add-range"&gt;Filtered add range&lt;/h3&gt;
&lt;p&gt;In the final benchmark, the entire source list is filtered using LINQ, and then &lt;code&gt;AddRange&lt;/code&gt; is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void FilteredOnce()
{
    var newList = new List&amp;lt;int&amp;gt;();

    newList.AddRange(items.Where(i =&amp;gt; i % 2 == 0).ToList());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;The full results are below, but in summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AddRange&lt;/code&gt; is 2-3 times faster than using &lt;code&gt;Add&lt;/code&gt; multiple times (depending on the list size)&lt;/li&gt;
&lt;li&gt;When required to filter the list, its quicker to iterate through each item, perform the check and use &lt;code&gt;Add&lt;/code&gt;. This is in comparison to using LINQ to filter and then &lt;code&gt;AddRange&lt;/code&gt; (the bottleneck here is LINQ, not the &lt;em&gt;AddRange&lt;/em&gt; call)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="items"&gt;10 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;59.21 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.873 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.817 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0343&lt;/td&gt;
&lt;td style="text-align: right;"&gt;216 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.12 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.738 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.690 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.68&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.01&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0204&lt;/td&gt;
&lt;td style="text-align: right;"&gt;128 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;23.10 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.458 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.450 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.39&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.01&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0153&lt;/td&gt;
&lt;td style="text-align: right;"&gt;96 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;97.60 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.395 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.305 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.65&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0446&lt;/td&gt;
&lt;td style="text-align: right;"&gt;280 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3 id="items-1"&gt;1000 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,155.3 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.86 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;43.72 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.3390&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0229&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.23 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,554.8 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;30.15 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;38.13 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.72&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6847&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0057&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.2 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;216.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.27 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.06 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6464&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0098&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.96 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,870.1 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;36.82 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.44 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.33&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.0223&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0153&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.28 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.76&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="items-2"&gt;10000 items&lt;/h3&gt;
&lt;hr /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.498 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4191 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4659 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20.8130&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.1504&lt;/td&gt;
&lt;td style="text-align: right;"&gt;128.32 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;15.165 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1404 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1172 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.71&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.4675&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.2817&lt;/td&gt;
&lt;td style="text-align: right;"&gt;64.3 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.127 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0408 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0382 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.3667&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7935&lt;/td&gt;
&lt;td style="text-align: right;"&gt;39.12 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;28.335 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3079 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2729 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.32&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.6414&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.2583&lt;/td&gt;
&lt;td style="text-align: right;"&gt;83.95 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.65&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally, &lt;code&gt;AddRange&lt;/code&gt; is much quicker than multiple iterations of &lt;code&gt;Add&lt;/code&gt; - however, if using &lt;code&gt;AddRange&lt;/code&gt; in conjunction with a slower operation (such as LINQ's &lt;em&gt;where&lt;/em&gt;), then it doesn't really matter which is used, and to improve performance the bottleneck (LINQ) should be optimized.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/SY7K9/status/1580163986347405312"&gt;Sabig Gasim Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;200: 11-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/10-awaiting-anything</id>
		<title>Awaiting anything with GetAwaiter</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/10-awaiting-anything" />
		<updated>2022-11-10T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;All that is required to &lt;code&gt;await&lt;/code&gt; a specific type, is that the type has a method called &lt;code&gt;GetAwaiter&lt;/code&gt; which returns an instance of &lt;code&gt;TaskAwaiter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;GetAwaiter&lt;/code&gt; method can be an &lt;em&gt;extension method&lt;/em&gt; - which means &lt;code&gt;any type can be extended to be awaited&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case-double-parse"&gt;Use case: double parse&lt;/h2&gt;
&lt;p&gt;In general, the below use cases are not a recommendation or proposed best technique for solving the use case - but it's interesting to discover what is possible.&lt;/p&gt;
&lt;p&gt;In this use case, we are going to attempt to &lt;em&gt;make an async version of the double.TryParse method&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tryparseasync"&gt;TryParseAsync&lt;/h3&gt;
&lt;p&gt;This solution doesn't require the usage of the &lt;code&gt;GetAwaiter&lt;/code&gt; method - in this first option we are just going to create a method which returns a &lt;code&gt;Task&lt;/code&gt; (and as such, the &lt;em&gt;Task&lt;/em&gt; is awaited):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// extension method on string
public static Task&amp;lt;bool&amp;gt; TryParseAsync(this string s, out double result)
{
    // perform the normal TryParse
    if(double.TryParse(s, out result))
    {
        // return a Task instead of the 
        // TryParse response
        return Task.FromResult(true);
    }
    
    // return a Task instead of the 
    // TryParse response
    return Task.FromResult(false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instead of doing it this OLD way
if(double.TryParse(&amp;quot;100&amp;quot;, out double result))
{
    Console.WriteLine(&amp;quot;100 is a double&amp;quot;);
}

// This is now possible:
// The TryParseAsync is called directly 
// on the string and can be awaited
if(await &amp;quot;100&amp;quot;.TryParseAsync(out double result1))
{
    Console.WriteLine(&amp;quot;100 is a double&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;TryParseAsync&lt;/code&gt; can be used on a string value directly, and as it returns a &lt;code&gt;Task&lt;/code&gt;, the call can be &lt;em&gt;awaited&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await-directly"&gt;await directly&lt;/h3&gt;
&lt;p&gt;However, what if there is a requirement to perform the same functionality as &lt;code&gt;TryParseAsync&lt;/code&gt;, but to &lt;em&gt;await&lt;/em&gt; the string directly - not call the &lt;code&gt;TryParseAsync&lt;/code&gt; method. Well, no problem!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static TaskAwaiter&amp;lt;bool&amp;gt; GetAwaiter(this string s)
{
    return s.TryParseAsync(out double _).GetAwaiter();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a &lt;code&gt;GetAwaiter&lt;/code&gt; extension method is created on &lt;code&gt;string&lt;/code&gt; - by convention, this now allows &lt;code&gt;string to be awaited directly&lt;/code&gt;. In this instance, awaiting a string will try parse it as a double (using the previously created extension method).&lt;/p&gt;
&lt;p&gt;So now this can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// just await the string
if(await &amp;quot;500&amp;quot;)
{
    Console.WriteLine(&amp;quot;500 is a double&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned - this is not really a recommended approach at all - while the code is more concise, the readability is not great, with the code making no contextual sense. However, it is what can be done.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case-timespan"&gt;Use Case: TimeSpan&lt;/h2&gt;
&lt;p&gt;A more useful use case, is to &lt;em&gt;expand the functionality of TimeSpan&lt;/em&gt; to make it easier to &lt;em&gt;wait for specific lengths of time&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="delay"&gt;Delay&lt;/h3&gt;
&lt;p&gt;Generally when a delay is required in code, a variation of the following is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await Task.Delay(TimeSpan.FromMilliseconds(100));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing wrong with this, it works. However if used often throughout code, it's it fairly verbose.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await"&gt;await&lt;/h3&gt;
&lt;p&gt;As before, a &lt;code&gt;GetAwaiter&lt;/code&gt; method could be added to &lt;code&gt;TimeSpan&lt;/code&gt; to make it &lt;em&gt;awaitable&lt;/em&gt;, eliminating the need for the Task.Delay (this will still be required, it will just be wrapped up in the extension method):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// extension method on TimeSpan
public static TaskAwaiter GetAwaiter(this TimeSpan timeSpan)
{
    return Task.Delay(timeSpan).GetAwaiter();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await TimeSpan.FromMilliseconds(100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Definitely simpler and more concise than the previous version, and I'd argue actually more readable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await-extended"&gt;await extended&lt;/h3&gt;
&lt;p&gt;This could even be taken a step further with an addition extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static TimeSpan MilliSeconds(this int i) =&amp;gt; TimeSpan.FromMilliseconds(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an extension method on an &lt;code&gt;int&lt;/code&gt;, which will convert the integer to an equivalent TimeSpan object.&lt;/p&gt;
&lt;p&gt;As we already have an existing extension method to &lt;em&gt;await&lt;/em&gt; a &lt;code&gt;TimeSpan&lt;/code&gt;, the two extensions methods can be used in conjunction - &lt;em&gt;convert an integer to a TimeSpan, which can then be awaited&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await 100.MilliSeconds();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this is a very useful and convenient technique to add the &lt;em&gt;await&lt;/em&gt; functionality to &lt;em&gt;any class&lt;/em&gt;, it doesn't mean every class &lt;em&gt;should&lt;/em&gt; have this functionality. In the case of &lt;code&gt;TryParseAsync&lt;/code&gt;, the code was made less readable, for no real benefit. In the case of &lt;code&gt;TimeSpan&lt;/code&gt;, the &lt;em&gt;await&lt;/em&gt; extension to the class did add value to the developer.  Basically, made an informed choice to use &lt;code&gt;GetAwaiter&lt;/code&gt;, and only do so where it makes sense.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/5360d1c3-89f6-4a08-9ee3-6ddbe1b44236"&gt;Cursed C# - Doing shenanigans in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;199: 10-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/09-localization-di</id>
		<title>Adding localization with dependency injection</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/09-localization-di" />
		<updated>2022-11-09T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Localization&lt;/code&gt; is the &lt;em&gt;process of translating an application's resources into localized versions for each culture that the application will support&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Enabling this multi-culture, localization support is as easy as adding a few lines of code on application startup, and leveraging the &lt;code&gt;IStringLocalizer&lt;/code&gt; implementation when working with the variable, localized values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-localized"&gt;Non-localized&lt;/h2&gt;
&lt;p&gt;Suppose we have an endpoint, which when called will return a string containing a random color:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/get&amp;quot;, () =&amp;gt;
{
    var random = new Random();
    var randomValue = random.Next(3);

    var response = randomValue switch
    {
        0 =&amp;gt; &amp;quot;Blue&amp;quot;,
        1 =&amp;gt; &amp;quot;Green&amp;quot;,
        2 =&amp;gt; &amp;quot;Yellow&amp;quot;
    };

    return $&amp;quot;The color generated is: {response}&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code will generate a random number between 1 and 3, and return a string indicating the color generated.&lt;/p&gt;
&lt;p&gt;Calling the endpoint returns the following (the colour value may change with each call):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The color generated is: Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above return message the American spelling of &amp;quot;color&amp;quot; is returned, and not the British/South African spelling, &lt;em&gt;colour&lt;/em&gt;. We are going to add support for either variation, depending on the caller's culture - this is a fairly simple innocuous change, but the steps used here can be expended to add complete support for a different language.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="localized"&gt;Localized&lt;/h2&gt;
&lt;h3 id="defining-the-variations"&gt;Defining the variations&lt;/h3&gt;
&lt;p&gt;The first step is to define the various strings which will have different versions based on the culture. In our example this would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The return message&lt;/li&gt;
&lt;li&gt;The three different colours&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this specific use case these three different colour values will not change between cultures, but if the application is to support multi-culture, its a good idea to &amp;quot;localize&amp;quot; all string values.&lt;/p&gt;
&lt;p&gt;The various culture specific strings are stored in &lt;code&gt;resx files&lt;/code&gt;, which usually reside in a &lt;code&gt;Resources&lt;/code&gt; folder. These files follow the naming standard of &lt;code&gt;{Class}.{culture}.resx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this case, two files where added to the &lt;code&gt;Resources&lt;/code&gt; folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program.en-us.resx&lt;/li&gt;
&lt;li&gt;Program.en-za.resx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As we are using minimal apis, the usage of the values will be in the &lt;code&gt;Program&lt;/code&gt; class, hence the name of the resx files is &lt;em&gt;Program&lt;/em&gt;. The cultures supported in our application will be &lt;code&gt;English-Unites States&lt;/code&gt; and &lt;code&gt;English-South African&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The resx files will both contain the &lt;code&gt;same names&lt;/code&gt; (keys), but each will have the specific localized values:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Program.en-us.resx&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ColourResponseMessage&lt;/td&gt;
&lt;td&gt;The color generated is: {0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Program.en-za.resx&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ColourResponseMessage&lt;/td&gt;
&lt;td&gt;The colour generated is: {0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As mentioned, in this example only the &lt;em&gt;ColourResponseMessage&lt;/em&gt; will differentiate between the two, with the slightly different spelling&lt;/p&gt;
&lt;p&gt;Now that we have the variable values defined, we begin by &lt;em&gt;adding localization support to the dependency injection container&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dependency-injection-configuration"&gt;Dependency injection configuration&lt;/h3&gt;
&lt;p&gt;During application startup, the following is added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// add the localization support to the dependency injection container
// which includes the path to the resx files
builder.Services.AddLocalization(options =&amp;gt; options.ResourcesPath = &amp;quot;Resources&amp;quot;);

// add the cultures which will be supported
var supportedCultures = new[]
{
    new CultureInfo(&amp;quot;en-za&amp;quot;),
    new CultureInfo(&amp;quot;en-us&amp;quot;)
};
builder.Services.Configure&amp;lt;RequestLocalizationOptions&amp;gt;(options =&amp;gt; {
    options.DefaultRequestCulture = new RequestCulture(&amp;quot;en-us&amp;quot;);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we configured the DI container with the generic localization interfaces and implementations, as well as explicitly specified which cultures will be supported.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="middleware-configuration"&gt;Middleware configuration&lt;/h3&gt;
&lt;p&gt;The next step is to configure the middleware pipeline (this is defined before any of the endpoints are defined):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseRequestLocalization(app.Services
    .GetRequiredService&amp;lt;IOptions&amp;lt;RequestLocalizationOptions&amp;gt;&amp;gt;().Value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware components will &lt;em&gt;automatically set culture information for requests based on information provided by the client&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Finally we are now able to take advantage of the localization capabilities and update the initial &lt;code&gt;/get&lt;/code&gt; endpoint defined above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="localized-endpoint"&gt;Localized endpoint&lt;/h3&gt;
&lt;p&gt;To leverage the localization functionality, the &lt;code&gt;IStringLocalizer&lt;/code&gt; interface and implementation is used - this is injected from the dependency injection container. Instead of the string value being hardcoded, &lt;code&gt;IStringLocalizer&lt;/code&gt; is used to lookup the culture specific string by name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject IStringLocalizer with the specific class
app.MapGet(&amp;quot;/get&amp;quot;, ([FromServices]IStringLocalizer&amp;lt;Program&amp;gt; localizer) =&amp;gt;
{
    var random = new Random();
    var randomValue = random.Next(3);

    // same logic as before
    var localizedResponse = randomValue switch 
    {
        // use IStringLocalizer to get the culture specific string
        // GetString also allows for arguments to be passed in and 
        // another localized string (the colour) is being passed in
        // as a parameter to format the ColourResponseMessage
        0 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Blue&amp;quot;)),
        1 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Green&amp;quot;)),
        2 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Yellow&amp;quot;)),
    };

    return localizedResponse.Value;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When &lt;em&gt;GetString&lt;/em&gt; is called on the &lt;em&gt;IStringLocalizer&lt;/em&gt; implementation, the current culture of the context is used - if no culture is explicitly supplied, then the default culture is used.&lt;/p&gt;
&lt;p&gt;Calling the endpoint as it stands returns the same result as before - the default culture is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The color generated is: Yellow
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="changing-culture"&gt;Changing culture&lt;/h3&gt;
&lt;p&gt;When the middleware pipeline was updated in a previous step using &lt;em&gt;UseRequestLocalization&lt;/em&gt;, it added the functionality to &lt;code&gt;change the culture based on a query string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Calling the endpoint with the culture specified &lt;code&gt;/get?culture=en-za&lt;/code&gt; now results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The colour generated is: Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The strings are now culture specific! Localization support has been added to the application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Adding localization support to an api is a relatively easy process, and only requires the steps mentioned above. For large api's, if the task seems daunting and over whelming, due to the nature of the updates, it can be done in a phased approach, one endpoint at a time, making it a bit more manageable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/aspnetcore-localization/"&gt;Localization in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;198: 09-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>