<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-06-14T04:32:19Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/14-indexer-arguments</id>
		<title>Indexers with multiple arguments</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/14-indexer-arguments" />
		<updated>2022-06-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Previously we have look at a method to &lt;a href="https://alwaysdeveloping.net/02/23-indexers"&gt;add an indexer and access class as an array&lt;/a&gt;. Today we explore indexers again, and how custom indexers can be written which accept not only integers, but other types as well as &lt;code&gt;multiple parameters&lt;/code&gt;, to access data in a variety of ways.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="list-example"&gt;List example&lt;/h2&gt;
&lt;p&gt;First as a benchmark, we'll have a look at the &lt;code&gt;List&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var strList = new List&amp;lt;string&amp;gt;();

strList.Add("one");
strList.Add("two");
strList.Add("three");
strList.Add("four");
strList.Add("five");

Console.WriteLine(strList[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The items added to the List can be accessed using an int indexer. In the above example &lt;em&gt;strList[3]&lt;/em&gt; will return the 4th item in the list. This is standard built-in functionality.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="enhancedlist-example"&gt;EnhancedList example&lt;/h2&gt;
&lt;p&gt;Next we'll create our own &lt;code&gt;EnhancedList&lt;/code&gt;, which inherits from the &lt;code&gt;List&lt;/code&gt; class, but provides additional functionality through custom indexers.&lt;/p&gt;
&lt;p&gt;The base &lt;code&gt;EnhancedList&lt;/code&gt; looks as follows and operates exactly the same as a normal &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="access-index"&gt;Access index&lt;/h3&gt;
&lt;p&gt;First, let's create an indexer to &lt;code&gt;get the index, based on the value&lt;/code&gt;. This is basically exactly what the &lt;code&gt;IndexOf&lt;/code&gt; method does, but as an indexer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method checks if the list contains the value passed in, and if it does will return the value's index, otherwise -1 will be returned.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// access the value based on the index
Console.WriteLine(enhancedList[3]);

// access the index based on the value
Console.WriteLine(enhancedList["two"]);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    four
    1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The built in indexer for &lt;code&gt;List&lt;/code&gt; accepts an int as a parameter, and we've created an indexer which accepts type T (the type contained in the &lt;em&gt;EnhancedList&lt;/em&gt;), in this example, a string.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="multiple-index-lookup"&gt;Multiple index lookup&lt;/h3&gt;
&lt;p&gt;As we've seen, &lt;code&gt;EnhancedList[index]&lt;/code&gt; can be used to get the value at the specified index. Let's update the &lt;code&gt;EnhancedList&lt;/code&gt; to accept &lt;code&gt;multiple indexes and return multiple values&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;

    public IEnumerable&amp;lt;T&amp;gt; this[bool rangeLookup, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; (T)this[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new indexer has been added, this time taking a bool and an array of integers as arguments. The bool parameter is required to differentiate between &lt;em&gt;EnhancedList[index]&lt;/em&gt; and &lt;em&gt;EnhancedList[params]&lt;/em&gt; - without the bool forcing a difference, there is no way of specifying which indexer is being called.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// get the value for index 2 and 4
foreach (var lookupItem in enhancedList[true, 2, 4])
{
    Console.WriteLine(lookupItem);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, we get the values at index 2 and 4. The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    three
    five
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="t-modification"&gt;T modification&lt;/h3&gt;
&lt;p&gt;The generic type T contained in the &lt;code&gt;EnhancedList&lt;/code&gt; can also be modified before being returned by the indexer. In the last example, we are going to create an indexer which returned the items in the list as a string, ready for output to the Console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;

    public IEnumerable&amp;lt;T&amp;gt; this[bool rangeLookup, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; (T)this[i]);

    public IEnumerable&amp;lt;string&amp;gt; this[string prefixMessage, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; $"{prefixMessage} {(T)this[i]}");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new indexer takes a string prefix message, and an array of indexes. Instead of returning just the values at the position of the indexes (as in the previous example), now the &lt;em&gt;prefixMessage&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt; are combined before being returned.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// return value at index 0, 2 and 4
// with the supplied message
foreach (var lookupItem in enhancedList["Printing item ...", 0, 2, 4])
{
    Console.WriteLine(lookupItem);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, we get the values at index 2 and 4. The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Printing item ... one
    Printing item ... three
    Printing item ... five
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the examples shown above are not necessarily production ready or practical, they do show how indexers can be created which accept multiple arguments, allowing for some innovative possibilities depending on your specific use case.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/maartenballiauw/status/1527280915092742144"&gt;Maarten Balliauw Tweet&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;95: 14-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/13-chaining-lambda</id>
		<title>Lambda chaining in C#</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/13-chaining-lambda" />
		<updated>2022-06-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Action lambda&lt;/code&gt; expressions (expressions which take parameters but do not return a value) can be &lt;code&gt;chained together&lt;/code&gt; and operated on with a single handle, the same as is done with delegates. This is because the &lt;code&gt;Action&lt;/code&gt; type in C# is a delegate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="action"&gt;Action&lt;/h2&gt;
&lt;p&gt;When defining a lambda as follows, the type of the variable is &lt;code&gt;delegate void Action&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var welcomeMsg = () =&amp;gt; Console.Write(&amp;quot;Good morning &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it is a delegate, multiple can be chained together:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var welcomeMsg = () =&amp;gt; Console.Write(&amp;quot;Good morning &amp;quot;);
welcomeMsg += () =&amp;gt; Console.Write(&amp;quot;Dave&amp;quot;);
welcomeMsg += () =&amp;gt; Console.WriteLine(&amp;quot;&amp;quot;);
welcomeMsg += () =&amp;gt; Console.WriteLine(&amp;quot;Have a great day.&amp;quot;);

welcomeMsg();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the Action will result in each lambda being called in order, and the output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Good morning Dave
Have a great day.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To expand on this convoluted, non-practical example, logic can be applied to chain or not chain certain lambdas to the main handle.&lt;/p&gt;
&lt;p&gt;The below will only ouput a name if its supplied, and also allows for additional custom welcome messages to be added to the end of the main welcome message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void OuputWelcomeMessage(string name =&amp;quot;&amp;quot;, Action[] extraMessages = null)
{
    var welcomeMsg = () =&amp;gt; Console.Write(&amp;quot;Good morning &amp;quot;);

    if (!string.IsNullOrEmpty(name))
    {
        welcomeMsg += () =&amp;gt; Console.Write(name);
        welcomeMsg += () =&amp;gt; Console.Write(&amp;quot;.&amp;quot;);
    }

    welcomeMsg += () =&amp;gt; Console.Write(Environment.NewLine);

    if (extraMessages != null)
    {
        foreach(var action in extraMessages)
        {
            welcomeMsg += action;
        }
    }
    welcomeMsg();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="parameter-action"&gt;Parameter Action&lt;/h2&gt;
&lt;p&gt;The same process can also be used for lambda's which take in parameters(s) - however to chain them, every lambda which is chained needs to have the same signature.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var updateDatabase = (int id) =&amp;gt; 
    Console.WriteLine($&amp;quot;Updating record with `{id}` in database 1&amp;quot;);
updateDatabase += (int id) =&amp;gt; 
    Console.WriteLine($&amp;quot;Updating record with `{id}` in database 2&amp;quot;);

updateDatabase(112);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we simulate updating two different databases, with the one integer parameter. The parameter will be passed into each lambda in order of them being added to the main handle.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Updating record with `112` in database 1
Updating record with `112` in database 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="async-action"&gt;Async Action&lt;/h2&gt;
&lt;p&gt;Again, the same process can also be used for async lambda expressions. These now become &lt;code&gt;Func&amp;lt;Task&amp;gt;&lt;/code&gt; and not &lt;code&gt;Action&lt;/code&gt;, as they DO have a return value, of type Task.&lt;/p&gt;
&lt;p&gt;The below method will accept an array of lambda's, chain them and invoke to ouput the result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task OuputMessagesAsync(Func&amp;lt;Task&amp;gt;[] extraMessages = null)
{
    var messages = () =&amp;gt; 
        { 
            Console.WriteLine(&amp;quot;Executing messages:&amp;quot;); 
            return Task.CompletedTask; 
        };

    if (extraMessages != null)
    {
        foreach(var action in extraMessages)
        {
            messages += action;
        }
    }

    await messages();

    Console.ReadLine(); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the method as follows, results in some interesting points:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await OuputMessagesAsync(
    new[] {
        async () =&amp;gt; { await Task.Delay(4); Console.WriteLine(&amp;quot;1&amp;quot;); },
        async () =&amp;gt; { await Task.Delay(3); Console.WriteLine(&amp;quot;2&amp;quot;); },
        async () =&amp;gt; { await Task.Delay(2); Console.WriteLine(&amp;quot;3&amp;quot;); },
        async () =&amp;gt; { await Task.Delay(1); Console.WriteLine(&amp;quot;4&amp;quot;); },
        async () =&amp;gt; { await Task.Delay(0); Console.WriteLine(&amp;quot;5&amp;quot;); },
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for the above is (and may differ each execution):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Executing messages:
5
2
4
3
1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Only the main handle is awaiting, not the chained lambdas. If the &lt;code&gt;Console.ReadLine()&lt;/code&gt; is removed, then only one value is output, and not all 5 - the application closes before all async methods have run to completion.&lt;/li&gt;
&lt;li&gt;This also highlights the fact that the order in which the number are output is not consistent - it can change with each execution. The lambda's are not being awaited individually before the next one in the chain is executed.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;I'm sure there is a valid, practical use case for this somewhere out there, but I can't think of a single situation in the past where I would have used the chaining ability. Perhaps (similar to in the above sample), allowing the caller of a method to supply additional &lt;code&gt;Action&lt;/code&gt;(s) to be performed in addition to core method logic?&lt;/p&gt;
&lt;p&gt;Either way though, I found this to be an interesting technique and nugget of information to know about to potential future use!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1520811273633599489"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;94: 13-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/10-xml-comments</id>
		<title>Using XML documentation comments to enrich code</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/10-xml-comments" />
		<updated>2022-06-10T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;There are a number of features as part of the C# XML documentation comments (comments prefixed with &lt;code&gt;///&lt;/code&gt;), which can use used to improved the useability of code. In additional to providing commentary on a class or method etc, there is also the ability to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;link to external URLs&lt;/li&gt;
&lt;li&gt;add general remarks to the comments&lt;/li&gt;
&lt;li&gt;share comment blocks between methods&lt;/li&gt;
&lt;li&gt;reference a parameter by name&lt;/li&gt;
&lt;li&gt;highlight language keywords&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these can be used to enhance the overall quality and usability of the code, especially if the code is part of a library to be referenced and used by external projects.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="external-urls"&gt;External Urls&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;seealso&lt;/code&gt; keyword can be used to create a clickable link.&lt;/p&gt;
&lt;p&gt;Assume we want to put a URL in a method comment section:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Does some work. See www.alwaysdeveloping.net for more information
/// &amp;lt;/summary&amp;gt;
public Task DoWorkAsync()
{
    return Task.CompletedTask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this, the URL is present in the comments, but is not clickable:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/before-seealso.png" alt="Url in comment"&gt;&lt;/p&gt;
&lt;p&gt;Updating the comments to instead used the &lt;code&gt;seealso&lt;/code&gt; keyword, makes the URL clickable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Does some work. See &amp;lt;seealso href="www.alwaysdeveloping.net" /&amp;gt; for more information
/// &amp;lt;/summary&amp;gt;
public Task DoWorkAsync()
{
    return Task.CompletedTask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/after-seealso.png" alt="Clickable URL in comment"&gt;&lt;/p&gt;
&lt;h2 id="general-remarks"&gt;General remarks&lt;/h2&gt;
&lt;p&gt;Instead of adding a general remark to the &lt;em&gt;summary&lt;/em&gt; section, it can instead be added to the &lt;code&gt;remark&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Does some work.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;remarks&amp;gt;See &amp;lt;seealso href="www.alwaysdeveloping.net" /&amp;gt; for more information&amp;lt;/remarks&amp;gt;
public Task DoWorkAsync()
{
    return Task.CompletedTask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/after-remarks.png" alt="Clickable URL in remarks"&gt;&lt;/p&gt;
&lt;h2 id="sharing-comments"&gt;Sharing comments&lt;/h2&gt;
&lt;p&gt;Comments can be shared, which is especially useful when one has a &lt;code&gt;method&lt;/code&gt; and an &lt;code&gt;async version&lt;/code&gt; of the same method. This is done using the &lt;code&gt;inheritdoc&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; keywords:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Does some work, but with parameters supplied
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name="length"&amp;gt;The length of the work&amp;lt;/param&amp;gt;
/// &amp;lt;param name="value"&amp;gt;The value of the work&amp;lt;/param&amp;gt;
/// &amp;lt;param name="extraWork"&amp;gt;An action delegate to specify 
/// any additional work which might need to be done&amp;lt;/param&amp;gt;
public void DoWorkWithParameters(int length, string value, Action extraWork) { }

/// &amp;lt;inheritdoc cref="DoWorkWithParameters(int, string, Action)"/&amp;gt;
public Task DoWorkWithParametersAsync(int length, string value, Action extraWork)
{
    return Task.CompletedTask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both methods now show the same comments:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/work-params.png" alt="Method with comments"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/work-params-async.png" alt="Method with inherited comments"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="referencing-parameters"&gt;Referencing parameters&lt;/h2&gt;
&lt;p&gt;Parameters can be referenced in the comments using the &lt;code&gt;paramref&lt;/code&gt; keyword, making it clearer how the method works and how the parameters are used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Will check if the job with &amp;lt;paramref name="jobName"/&amp;gt; is in progress or has completed
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name="jobName"&amp;gt;The name of the job to check. 
/// If set to null, a check is performed on any job&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;True if the job specified by &amp;lt;paramref name="jobName"/&amp;gt;
/// is still processing, otherwise false&amp;lt;/returns&amp;gt;
public bool IsWorkInProgress(string jobName)
{
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The parameter name is now highlighted whereever it is referenced.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/paramref.png" alt="Method using paramref"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="language-keywords"&gt;Language keywords&lt;/h2&gt;
&lt;p&gt;Language keywords can also be highlighted using &lt;code&gt;langword&lt;/code&gt;. If we take the previous example, and update all the C# keywords (true, false) to indicate they are language keywords:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;/// &amp;lt;summary&amp;gt;
/// Will check if the job with &amp;lt;paramref name="jobName"/&amp;gt; is in progress or has completed.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name="jobName"&amp;gt;The name of the job to check.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;see langword="true"/&amp;gt; if the job specified by &amp;lt;paramref name="jobName"/&amp;gt; 
/// is still processing, otherwise &amp;lt;see langword="false"/&amp;gt;&amp;lt;/returns&amp;gt;
public bool IsWorkInProgress(string jobName)
{
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The language keywords are now highlighted:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/lang-keyword.png" alt="Language keywords highlighted"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="libraries"&gt;Libraries&lt;/h2&gt;
&lt;p&gt;Updating comments with these features improves the usability of the code - however if developing a shared library (a NuGet package for example), there are some additional steps which need to be done to enable the comments being available to users of the library.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;GenerateDocumentationFile&lt;/code&gt; option needs to be enabled in the csproj:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net6.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the code is compiled, an XML file will now be generated containing all the comments - which should then be included as part of the NuGet package to make the comments available.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As a library author, for public, but mostly for internal corporate packages - I have found adding comments to be very useful in explaining and conveying to the user how a method and class works, lessening the number of questions and queries received. The additional features mentioned above will take the commentary to another level.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/Nick_Craver/status/1516050534670741505"&gt;Nick Craver Tweet&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;94: 10-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/09-parameter-binding</id>
		<title>Binding a query parameter to an object</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/09-parameter-binding" />
		<updated>2022-06-09T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming in .NET 7, endpoint query parameter can automatically me mapped to an object by adding a &lt;code&gt;TryParse&lt;/code&gt; method to the object. In this post we'll compare the traditional query parameter functionality, and compare it with the newly added functionality.&lt;/p&gt;
&lt;p&gt;This functionality is available now in the the .NET 7 preview release, and subject to change by the final .NET 7 release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case"&gt;Use case&lt;/h2&gt;
&lt;p&gt;In our use case, we have a search page on an e-commerce website. Query string parameters can be send as part of the URL to determine which &lt;em&gt;category&lt;/em&gt; to display, which &lt;em&gt;page number&lt;/em&gt; to display and &lt;em&gt;how many items per page&lt;/em&gt; to display.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="separate-parameters"&gt;Separate parameters&lt;/h3&gt;
&lt;p&gt;The above can be achieved using three separate query string parameters. A minimal endpoint can be defined with 3 parameters, matching the query string parameter names - the query string parameters will automatically be mapped to the endpoint parameters by ASPNET Core.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/api/searchpage&amp;quot;, (string category, int pageIndex, int pageSize) =&amp;gt;
{
    return $&amp;quot;Returning page '{pageIndex}' of size &amp;quot; +
        $&amp;quot;'{pageSize}' for category '{category}'&amp;quot;;

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This endpoint can be access on the URL &lt;code&gt;/api/searchpage?category=pants&amp;amp;pageIndex=3&amp;amp;pageSize=50&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This solution will work, but there is also another cleaner (although, that is subjective) way to define the endpoint and handle the query string.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="binding-to-an-object"&gt;Binding to an object&lt;/h3&gt;
&lt;p&gt;Let's update the endpoint to take an object instead of the three separate parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/api/searchpageoptions&amp;quot;, (SearchPageOptions searchOptions) =&amp;gt;
{
    return $&amp;quot;Returning page '{searchOptions.PageIndex}' of size &amp;quot; +
        $&amp;quot;'{searchOptions.PageSize}' for category '{searchOptions.Category}'&amp;quot;;
    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;SearchPageOptions&lt;/code&gt; defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SearchPageOptions
{
    public string Category { get; set; }

    public int PageIndex { get; set; }

    public int PageSize { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try run this as it, an exception will occur - this is because by &lt;code&gt;default ASPNET Core will infer and try map the body of the request to an object parameter to the endpoint&lt;/code&gt;, and GET requests do not allow body parameters.&lt;/p&gt;
&lt;p&gt;We need to instruct ASPNET Core how to map from the query string to the object - and thankfully this is very simple.&lt;/p&gt;
&lt;p&gt;We are however required to make a change to the format of the query string - only a single query string parameter can be mapped to an object, so the three query string parameters need to be converted to one parameter in &lt;code&gt;json format&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can add a &lt;code&gt;TryParse&lt;/code&gt; method to the &lt;em&gt;SearchPageOptions&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SearchPageOptions
{
    public string Category { get; set; }

    public int PageIndex { get; set; }

    public int PageSize { get; set; }

    public static bool TryParse(string value, out SearchPageOptions result)
    {
        if (value is null)
        {
            result = default;
            return false;
        }

        JsonSerializerOptions options = new()
        {
            PropertyNameCaseInsensitive = true
        };
        result = JsonSerializer.Deserialize&amp;lt;SearchPageOptions&amp;gt;(value, options);

        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ASPNET Core will look for, and call this method with the relevent query string parameter, allowing the method to try convert the parameter to the object. With the above changes to the endpoint and &lt;em&gt;SearchPageOptions&lt;/em&gt; class, the endpoint can now be called using:&lt;br /&gt;
&lt;code&gt;/api/searchpageoptions?searchOptions={&amp;quot;category&amp;quot;:&amp;quot;pants&amp;quot;,&amp;quot;pageIndex&amp;quot;:3,&amp;quot;pageSize&amp;quot;:50}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Notice the information conveyed is the same, just in a simple json parameter now, instead of three separate parameters - allowing for the conversion of the query string parameter to a &lt;em&gt;SearchPageOptions&lt;/em&gt; instance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Both methods above result in the same outcome, just using slightly different techniques - but in the end it comes down to personal preference. Personally, I prefer the binding method, with the cleaner and concise method arguments. This approach however does result in a slightly more complicated query string format - the tradeoffs of each approach should be considered, and the best one for your application chosen.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://jaliyaudagedara.blogspot.com/2022/04/aspnet-core-custom-controller-action.html"&gt;ASP.NET Core: Custom Controller Action Parameter Binding using TryParse in Minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;92: 09-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/08-ienumerable-visualizer</id>
		<title>Viewing collections with IEnumerable Visualizer</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/08-ienumerable-visualizer" />
		<updated>2022-06-08T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When coding a system which makes use of collections of data (even reasonably small collections), inspecting, debugging and discovering issues with the dataset can be very difficult and cumbersome.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IEnumerable Visualizer&lt;/code&gt;, available in Visual Studio 17.2, (Visual Studio 2022), aims to make this tedious process easier allowing for easier inspection of collections of data in Visual Studio.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="watch-window"&gt;Watch window&lt;/h2&gt;
&lt;p&gt;When debugging, the starting point for viewing the data being operated on, is the &lt;code&gt;Watch window&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/watch-window.png" alt="Watch Window"&gt;&lt;/p&gt;
&lt;p&gt;The issue with the Watch window, is when working with collections, its difficult to find a specific record. There is no useful identifying information immediately available without expanding each row one by one to find the relevant record. This is just not sustainable as the collection size grows.&lt;/p&gt;
&lt;p&gt;In addition, there is no way to export the collection of information so that it would be inspected in another tool (such as Excel, for example).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="watch-and-tostring"&gt;Watch and ToString&lt;/h2&gt;
&lt;p&gt;One method for making it easier to find the relevent record(s), is to overwrite the &lt;code&gt;ToString&lt;/code&gt; method of the object - in this example, the &lt;code&gt;Song&lt;/code&gt; object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public int Id { get; set; } 

    public string Name { get; set; }

    public string Artist { get; set; }

    public int YearReleased { get; set; }

    public int LengthInSeconds { get; set; }

    public override string ToString()
    {
        return $"Song `{Name}` by '{Artist} released " +
            $"in '{YearReleased}' and is '{LengthInSeconds}' seconds long";
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ouput of the &lt;code&gt;ToString&lt;/code&gt; method, pulls through to the &lt;code&gt;Watch window&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/watch-tostring.png" alt="Watch Window with ToString"&gt;&lt;/p&gt;
&lt;p&gt;At least now one has a visual cue as to the contents of each record without having to expand the row in the window. However, it still requires inspecting each row, which is not sustainable with thousands of rows.
Also, it might not be possible to add a &lt;code&gt;ToString&lt;/code&gt; method if the entity is owned by a third party.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="ienumerable-visualizer"&gt;IEnumerable Visualizer&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IEnumberable Visualizer&lt;/code&gt; solves many of the issues (but not all) - this window is available by clicking the magnifying glass for the collection, in the Watch window:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/visualizer-location.png" alt="IEnumberable Visualizer location"&gt;&lt;/p&gt;
&lt;p&gt;This icon will bring up the &lt;code&gt;IEnumberable Visualizer&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/visualizer.png" alt="IEnumberable Visualizer"&gt;&lt;/p&gt;
&lt;p&gt;This windows allows for the data to be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sorted by any column&lt;/li&gt;
&lt;li&gt;Exported to Excel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This will greatly increase the ability to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find the relevent record&lt;/li&gt;
&lt;li&gt;Perform additional operations on the data if required (sums, filtering) via exporting&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having worked with large collections before, this new visualizer is definitely going ease the pain and difficulty collection inspection brings! There are two future enhancements I feel would add great value to the already useful feature:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A column in the visualizer which indicates the index of the record in the underlying collection. This will make it easier to find the record in the Watch window to perform updates on the data&lt;/li&gt;
&lt;li&gt;The ability to filter data in the visualizer, making it even easier to find and search for data.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/view-net-collections-with-the-new-ienumerable-debugger-visualizer/?WT.mc_id=DOP-MVP-4025064"&gt;View .NET collections with the new IEnumerable Debugger Visualizer&lt;/a&gt;&lt;br&gt;
&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-17-2-is-now-available/#debugging-collections"&gt;Debugging collections&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;91: 08-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/07-allownull-disallownull-attributes</id>
		<title>AllowNull and DisallowNull attributes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/07-allownull-disallownull-attributes" />
		<updated>2022-06-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;AllowNull&lt;/code&gt; and &lt;code&gt;DisallowNull&lt;/code&gt; attributes can be used to set that a property can/should allow a &lt;code&gt;null&lt;/code&gt; value or not.&lt;/p&gt;
&lt;p&gt;These are used in a fairly narrow and niche use case, which won't necessarily effect the performance of code, but does eliminate compiler warnings.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="null-property"&gt;Null Property&lt;/h2&gt;
&lt;p&gt;Consider a &lt;code&gt;User&lt;/code&gt; class with a &lt;code&gt;Name&lt;/code&gt; property. Our system &lt;em&gt;requires that a user has a name, but does not require the user has to provide one&lt;/em&gt;. If none is provided, then a default is specified.&lt;/p&gt;
&lt;p&gt;In this case, the &lt;em&gt;Name&lt;/em&gt; will &lt;code&gt;never return null, but can be set to null&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class User
{
    private string _name;

    public string Name
    {
        get =&amp;gt; _name;
        set =&amp;gt; _name = value ?? &amp;quot;Anonymous&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If an instance of &lt;em&gt;User&lt;/em&gt; is declared, and &lt;code&gt;null&lt;/code&gt; assigned to &lt;em&gt;Name&lt;/em&gt;, the compiler will give the following warning:&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;Cannot convert null literal to non-nullable reference type&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Changing the property type from &lt;em&gt;string&lt;/em&gt; to &lt;em&gt;string?&lt;/em&gt; will get rid of the warning, but this is not an entirely accurate representation of the type. &lt;em&gt;Name&lt;/em&gt; can never have a value of and return &lt;code&gt;null&lt;/code&gt; - callers will never need to check &lt;em&gt;Name&lt;/em&gt; property for &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A more accurate method to get rid of the warning, is to use the &lt;code&gt;AllowNull&lt;/code&gt; attribute (in the &lt;em&gt;System.Diagnostics.CodeAnalysis&lt;/em&gt; namespace):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[AllowNull]
public string Name
{
    get =&amp;gt; _name;
    set =&amp;gt; _name = value ?? &amp;quot;Anonymous&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This attribute specified a pre-condition which &lt;code&gt;only applies to arguments&lt;/code&gt;, and since only the &lt;code&gt;set&lt;/code&gt; accessor makes use of an argument, the attribute only applies to this accessor, and not the &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-null-property"&gt;Non-null Property&lt;/h2&gt;
&lt;p&gt;Consider the opposite situation now - a property which has a &lt;code&gt;null&lt;/code&gt; default value, but if explicitly set, is not allowed to be &lt;code&gt;null&lt;/code&gt;. We would want to indicate to the caller that it is possible for the value to be &lt;code&gt;null&lt;/code&gt;, but also that it cannot explicitly be set to &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Going back to the &lt;code&gt;User&lt;/code&gt; class, consider now we to add a &lt;code&gt;Email&lt;/code&gt; property. The system &lt;em&gt;requires that if a user has an email address, it cannot be set to null&lt;/em&gt;.&lt;br /&gt;
The default value for an email is &lt;code&gt;null&lt;/code&gt;, but if it is explicitly set, it cannot be &lt;code&gt;null&lt;/code&gt; (for example, maybe a customer can create a user profile on an e-commerce site, without an email - but if they decide to checkout, an email is required.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class User
{
    private string _name;

    private string _email;

    [AllowNull]
    public string Name
    {
        get =&amp;gt; _name;
        set =&amp;gt; _name = value ?? &amp;quot;Anonymous&amp;quot;;
    }

    public string Email
    {
        get =&amp;gt; _email;
        set =&amp;gt; _email = value ?? 
            throw new ArgumentNullException(nameof(value), &amp;quot;Cannot set to null&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn't indicate that the value &lt;em&gt;could&lt;/em&gt; be &lt;code&gt;null&lt;/code&gt;. To indicate that we can make it a nullable type, &lt;code&gt;string?&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public string? Email
{
    get =&amp;gt; _email;
    set =&amp;gt; _email = value ?? 
            throw new ArgumentNullException(nameof(value), &amp;quot;Cannot set to null&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now there is a clear indication that the value &lt;em&gt;could&lt;/em&gt; be &lt;code&gt;null&lt;/code&gt;, however it is still possible to assign a &lt;code&gt;null&lt;/code&gt; value to the field without any compiler time warning. Only at runtime will the exception be thrown.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;DisallowNull&lt;/code&gt; attribute can be used to indicate that the parameter to the property cannot be &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public string? Email
{
    get =&amp;gt; _email;
    set =&amp;gt; _email = value ?? 
            throw new ArgumentNullException(nameof(value), &amp;quot;Cannot set to null&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with before, this attribute specified a pre-condition which &lt;code&gt;only applies to arguments&lt;/code&gt;, and since only the &lt;code&gt;set&lt;/code&gt; accessor makes use of an argument, the attribute only applies to this accessor, and not the &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now if &lt;code&gt;null&lt;/code&gt; is assigned to the &lt;em&gt;Email&lt;/em&gt; property, there &lt;strong&gt;will&lt;/strong&gt; be a compiler warning stating:
&lt;strong&gt;&lt;em&gt;Cannot convert null literal to non-nullable reference type&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is what we would want - an indicator that the value could be &lt;code&gt;null&lt;/code&gt; (the fact the type is a nullable type), but also an indicator if it is explicitly set to &lt;code&gt;null&lt;/code&gt; (a compiler warning)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, while this is a fairly narrow and niche use case, it a real use case especially for library authors. While neither of the attributes are &amp;quot;required&amp;quot; to make the code function, they assist in conveying the intended usage of the properties to the user of the properties, by either showing or suppressing a compiler warning.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/nullable-analysis#preconditions-allownull-and-disallownull"&gt;Preconditions: AllowNull and DisallowNull&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;90: 07-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/06-ienumerable-performance</id>
		<title>IEnumerable performance cost</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/06-ienumerable-performance" />
		<updated>2022-06-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; instead of a concrete implementation (List or an array for example) can make the code more usable and concise, but comes with a performance cost.&lt;/p&gt;
&lt;p&gt;If performance is critical, it will be worth performing a &lt;code&gt;type check&lt;/code&gt; and handling accordingly.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generic-method"&gt;Generic method&lt;/h2&gt;
&lt;p&gt;We want to create a method which takes a collection of integers, sums them up and returns the result. We are not entirely sure what this collection will be (a list, an array) so we want to make the method generic.&lt;/p&gt;
&lt;p&gt;We might end up with something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int SumItems(IEnumerable&amp;lt;int&amp;gt; enumerable)
{
    var runningSum = 0;

    foreach(var item in enumerable)
    {
        runningSum += item;
    }

    return runningSum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fairly straightforward - the method takes an &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; as a parameter, will iterate through each item keeping a running total, and then return the total at the end.&lt;/p&gt;
&lt;p&gt;Lets look at the performance of this method using various implementations of &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt; enumerableData = Enumerable.Range(0, 10000);
IEnumerable&amp;lt;int&amp;gt; listData = new List&amp;lt;int&amp;gt;(Enumerable.Range(0, 10000));
IEnumerable&amp;lt;int&amp;gt; arrayData = Enumerable.Range(0, 10000).ToArray();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here three different implementations are declared and &lt;code&gt;populated with 10000 items&lt;/code&gt;. We have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an IEnumerable&amp;lt;int&amp;gt;&lt;/li&gt;
&lt;li&gt;a List&amp;lt;int&amp;gt;&lt;/li&gt;
&lt;li&gt;an int array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As all three of these implement IEnumerable, they can all be passed to the &lt;em&gt;SumItems&lt;/em&gt; method as a parameter.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;BenchmarkDotNet&lt;/code&gt; our method is called using each of the IEnumerable types:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;IEnumerable&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.400 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4611 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4313 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57.201 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3635 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.226 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2972 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As one can see, the &lt;code&gt;IEnumerable and the int array are comparable&lt;/code&gt;, with the &lt;code&gt;List considerably slower&lt;/code&gt; (relatively).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="type-checking"&gt;Type checking&lt;/h2&gt;
&lt;p&gt;Next, let's modify the &lt;em&gt;SumItems&lt;/em&gt; method to check the type of IEnumerable, cast to that type, and then iterate on the specific type instead of IEnumerable.&lt;/p&gt;
&lt;p&gt;This could have also been done with method overloading, but with this approach all the code is kept in a single method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int SumListChecked(IEnumerable&amp;lt;int&amp;gt; enumerable)
{
    var runningSum = 0;

    // check for List
    if(enumerable is List&amp;lt;int&amp;gt; list)
    {
        foreach (var item in list)
        {
            runningSum += item;
        }
        return runningSum;
    }

    // check for array
    if (enumerable is int[] array)
    {
        foreach (var item in array)
        {
            runningSum += item;
        }
        return runningSum;
    }

    // all others
    foreach (var item in enumerable)
    {
        runningSum += item;
    }

    return runningSum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the type of IEnumerable parameter &lt;em&gt;enumerable&lt;/em&gt; is checked, if its a &lt;code&gt;List&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt;, then the IEnumerable is cast to that type, and the foreach loop is done on the &lt;code&gt;cast type&lt;/code&gt; not on the original IEnumerable.&lt;/p&gt;
&lt;p&gt;Running the benchmarks for both methods, yields the following results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;IEnumerable&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.400 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4611 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4313 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.846 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3551 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3148 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57.201 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3635 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.523 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0806 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0754 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.226 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2972 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.580 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0213 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0189 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;IEnumerable is effectively the same&lt;/code&gt;, as the code is the same between the two method, however &lt;code&gt;List and Array are considerably quicker&lt;/code&gt; when performing the iterating on the concrete type and not IEnumerable.&lt;/p&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this type of micro-optimization will probably not be required or noticeable in most use cases, its worth knowing about the trade-offs which come with each approach.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Just using IEnumerable&lt;/code&gt;: simplest, most maintainable code, but slowest in most cases&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type checking&lt;/code&gt;: less maintainable, but better performance in some cases&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method overloading&lt;/code&gt;: even less maintainable, as the same/similar code will be in multiple methods but better performance in some cases&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leveluppp.ghost.io/content/images/size/w1000/2021/07/net_virt1.png"&gt;The cost of virtualization in .NET can be surprising&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;89: 06-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/03-api-optional-param</id>
		<title>Optional parameters in minimal apis</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/03-api-optional-param" />
		<updated>2022-06-03T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using minimal apis in C#, while query string values will automatically be extracted and send to the lambda expression, they are by &amp;quot;default&amp;quot;, required values. Defaults can also not be supplied, as lambda expressions do not allow default values.&lt;/p&gt;
&lt;p&gt;Either the minimal api needs to use a method (as opposed to a lambda expression) or the parameter needs to be nullable, with the default value being set in the lambda body if not passed in.&lt;/p&gt;
&lt;p&gt;A few examples will make this clearer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lambda-endpoint"&gt;Lambda endpoint&lt;/h2&gt;
&lt;p&gt;First, lets look at a &amp;quot;default&amp;quot; minimal endpoint which uses a lambda expression. Here we expect the &lt;em&gt;count&lt;/em&gt; parameter to be supplied in a query string.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int count) =&amp;gt;
{
    return count;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the endpoint &lt;code&gt;/getdata/lambda?count=5&lt;/code&gt; is invoked, then the result return is &lt;em&gt;5&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, if no parameter is supplied and &lt;code&gt;/getdata/lambda&lt;/code&gt; is invoked, or if a the parameter is incorrectly name (for example &lt;code&gt;/getdata/lambda?counter=5&lt;/code&gt; is invoked ) an exception will be thrown:&lt;br /&gt;
&lt;em&gt;BadHttpRequestException: Required parameter &amp;quot;int count&amp;quot; was not provided from query string&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="method-endpoint"&gt;Method endpoint&lt;/h2&gt;
&lt;p&gt;If the lambda is replaced with a method, the same exception will occur if no query string parameter is supplied:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// external method
int ExtMethod(int count)
{
    return count;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking &lt;code&gt;/getdata/extmethod?count=10&lt;/code&gt;, will result in &lt;em&gt;10&lt;/em&gt; being returned, while invoking &lt;code&gt;/getdata/extmethod&lt;/code&gt; will result in the exception:&lt;br /&gt;
&lt;em&gt;BadHttpRequestException: Required parameter &amp;quot;int count&amp;quot; was not provided from query string&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="default-values"&gt;Default values&lt;/h2&gt;
&lt;p&gt;Once technique which &lt;strong&gt;partially&lt;/strong&gt; works, is to set the parameter to have a default value - however this only works when using a method, and &lt;code&gt;not when using a lambda&lt;/code&gt;.&lt;br /&gt;
This is due to the fact that &lt;code&gt;lambda parameters cannot have default values&lt;/code&gt; - this applies generally to lambda expression, and not specific to minimal api lambdas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// This is NOT VALID and will NOT compile
// The parameter count cannot have a default value
app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int count = 5) =&amp;gt;
{
    return count;
});

// ---

// This IS VALID and will WORK
int ExtMethod(int count = 5)
{
    return count;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, now if the method endpoint is invoked, &lt;code&gt;/getdata/extmethod?count=10&lt;/code&gt;, &lt;em&gt;10&lt;/em&gt; will be returned and if &lt;code&gt;/getdata/extmethod&lt;/code&gt; is invoked (with the parameter &lt;em&gt;count&lt;/em&gt; set), the default value of &lt;em&gt;5&lt;/em&gt; will be returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nullable-types"&gt;Nullable types&lt;/h2&gt;
&lt;p&gt;The solution for both cases, is to have the parameter type changed to a &lt;code&gt;nullable type&lt;/code&gt; and set it to a default value in the body, if null:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// int changed to int?
app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int? count) =&amp;gt;
{
    return count ?? 5;
});

// ---

// int changed to int?
int ExtMethod(int? count)
{
    return count ?? 5;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In both cases now, the parameter is allowed to be null, and if null, then the default value of 5 will be returned. If the parameter value is supplied, then it will be returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Thinking through the process in a general sense and comparing it to normal method invocations, it does make sense that this is how it would work - even if its not obvious initially:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of type &lt;code&gt;int&lt;/code&gt;, the value has to be explicitly supplied - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of type &lt;code&gt;int&lt;/code&gt; with a default value, the value can optionally be supplied - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When working with a lambda outside of minimal api, default values are not allowed - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of &lt;code&gt;nullable int&lt;/code&gt; (int?) - the value can optionally be supplied - just like with minimal api.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://wildermuth.com/2022/04/04/query-strings-optional-arguments-minimal-apis-aspnetcore/"&gt;How to Access Query Strings in Minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;88: 03-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/02-ef-bulk-insert</id>
		<title>EF Core INSERT vs MERGE</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/02-ef-bulk-insert" />
		<updated>2022-06-02T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When inserting data into a table using Entity Framework Core (EF Core), by default, if three or less records are being inserted, &lt;code&gt;separate SQL INSERT&lt;/code&gt; statements will be used.&lt;br /&gt;
However if four or more records are being inserted, EF Core will batch up the records and perform a &lt;code&gt;single SQL MERGE&lt;/code&gt; statement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In all of the below samples, the following methods were used.&lt;/p&gt;
&lt;p&gt;A method to retrieve a list of &lt;em&gt;Songs&lt;/em&gt; some of which will be used to insert into the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Song[] GetSongs()
{
    return new Song[]
    {
        new Song
        {
            Name = &amp;quot;Everlong&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1997,
            LengthInSeconds = 250
        },
        new Song
        {
            Name = &amp;quot;Learn to Fly&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1999,
            LengthInSeconds = 238
        },
        new Song
        {
            Name = &amp;quot;Monkey Wrench&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1997,
            LengthInSeconds = 231
        },
        new Song
        {
            Name = &amp;quot;My Hero&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1998,
            LengthInSeconds = 260
        },
        new Song
        {
            Name = &amp;quot;Clarity&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 268
        },
        new Song
        {
            Name = &amp;quot;Daughters&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 238
        },
        new Song
        {
            Name = &amp;quot;Bigger than my Body&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 266
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A minimal endpoint which will insert a variable number of records into the database, based on the &lt;em&gt;count&lt;/em&gt; parameter passed to the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/insert/{count}&amp;quot;, async (int count) =&amp;gt;
{
    using (var db = new BulkContext())
    {
        var songs = GetSongs();

        // add 1 or many songs
        for(int i = 0; i &amp;lt; count; i++)
        {
            db.Add(songs[i]);
        }

        // only call save changes once
        await db.SaveChangesAsync();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from this, the setup of the &lt;em&gt;BulkContext&lt;/em&gt; and the &lt;em&gt;Song&lt;/em&gt; entity is standard EF Core setup, nothing custom or outside the typical setup.&lt;/p&gt;
&lt;p&gt;What's important here though, is that one or more entities are added to the db context, but the &lt;code&gt;SaveChangesAsync method is only called once&lt;/code&gt;, after all entities have been added.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="insert-statement"&gt;Insert statement&lt;/h3&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 1, 2, or 3 as &lt;em&gt;count&lt;/em&gt; value, results in the following SQL executed &lt;code&gt;1, 2 or 3 separate times&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SET NOCOUNT ON;
INSERT INTO [Song] ([Artist], [LengthInSeconds], [Name], [YearReleased])
VALUES (&amp;#64;p0, &amp;#64;p1, &amp;#64;p2, &amp;#64;p3);
SELECT [Id]
FROM [Song]
WHERE &amp;#64;&amp;#64;ROWCOUNT = 1 AND [Id] = scope_identity();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core generates SQL which will insert the relevant information, and then return the Id primary key generated for the record.&lt;/p&gt;
&lt;p&gt;If full logging is enabled, EF Core will even tell you what it's doing: &lt;em&gt;Executing update commands individually as the number of batchable commands (3) is smaller than the minimum batch size (4).&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="merge-statement"&gt;Merge statement&lt;/h3&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 4 or greater as a value for &lt;em&gt;count&lt;/em&gt; results in the following SQL executed &lt;code&gt;just once&lt;/code&gt; (the below example inserts 5 records):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SET NOCOUNT ON;
DECLARE &amp;#64;inserted0 TABLE ([Id] int, [_Position] [int]);
MERGE [Song] USING (
VALUES (&amp;#64;p0, &amp;#64;p1, &amp;#64;p2, &amp;#64;p3, 0),
(&amp;#64;p4, &amp;#64;p5, &amp;#64;p6, &amp;#64;p7, 1),
(&amp;#64;p8, &amp;#64;p9, &amp;#64;p10, &amp;#64;p11, 2),
(&amp;#64;p12, &amp;#64;p13, &amp;#64;p14, &amp;#64;p15, 3),
(&amp;#64;p16, &amp;#64;p17, &amp;#64;p18, &amp;#64;p19, 4)) AS i ([Artist], [LengthInSeconds], 
        [Name], [YearReleased], _Position) ON 1=0
WHEN NOT MATCHED THEN
INSERT ([Artist], [LengthInSeconds], [Name], [YearReleased])
VALUES (i.[Artist], i.[LengthInSeconds], i.[Name], i.[YearReleased])
OUTPUT INSERTED.[Id], i._Position
INTO &amp;#64;inserted0;

SELECT [i].[Id] FROM &amp;#64;inserted0 i
ORDER BY [i].[_Position];

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, EF Core has changed the strategy from multiple INSERT statements to a single MERGE statement.&lt;/p&gt;
&lt;p&gt;Again, with full logging turned on EF Core will inform you what it's doing: &lt;em&gt;Executing 5 update commands as a batch.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="custom-batch-size"&gt;Custom batch size&lt;/h3&gt;
&lt;p&gt;The default for when EF Core switches from multiple INSERTS to a MERGE statement is 4 records - this however can be overwritten.&lt;/p&gt;
&lt;p&gt;When configuring the connection, the min amd max batch size can be explicitly set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(
        &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=BulkInsert;Integrated Security=True&amp;quot;, options =&amp;gt;
        {
            options.MaxBatchSize(1);
        });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the max batch size is to 1, which means a single INSERT will be used for every statement, with no batching taking place at all (generally, this would &lt;em&gt;not&lt;/em&gt; be advisable).&lt;/p&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 4 or greater will now result in multiple INSERTS and &lt;em&gt;not&lt;/em&gt; a MERGE statement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;In most cases, this is not something to worry about - the presumption being that the EF Core team have benchmarked and determined in &lt;em&gt;most&lt;/em&gt; cases, 4 is the threshold where doing a MERGE is more efficient that doing multiple INSERTS.&lt;/p&gt;
&lt;p&gt;However, if one determines that 4 is too high (or too low) for a specific use case, one can adjust the value up or down and benchmark how the performance of the code is impacted.&lt;/p&gt;
&lt;?# DailyDrop ?&gt;87: 02-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/06/01-endpoint-data-source</id>
		<title>Listing all ASP.NET Core routes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/06/01-endpoint-data-source" />
		<updated>2022-06-01T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core has a build in class, &lt;code&gt;EndpointDataSource&lt;/code&gt;, which contains information about a route, while the &lt;code&gt;IEnumerable&amp;lt;EndpointDataSource&amp;gt;&lt;/code&gt; collection, available through dependency injection contains information about all endpoints of an application.&lt;/p&gt;
&lt;p&gt;Information about a specific endpoint can also be retrieved from the &lt;code&gt;HttpContext&lt;/code&gt; for a specific request.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="listing-routes"&gt;Listing routes&lt;/h2&gt;
&lt;p&gt;First, lets look at getting all the routes (endpoints) for an application - this can be done by injecting &lt;code&gt;IEnumerable&amp;lt;EndpointDataSource&amp;gt;&lt;/code&gt; into the relevant constructor (or endpoint delegate in the below example):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routes&amp;quot;, (IEnumerable&amp;lt;EndpointDataSource&amp;gt; routes) =&amp;gt;
        string.Join(Environment.NewLine, routes.SelectMany(es =&amp;gt; es.Endpoints)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/routes&lt;/code&gt; endpoint, the following is returned (the 4 endpoints which make up the sample api):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    HTTP: GET /routes
    HTTP: GET /user/{userId}
    HTTP: GET /routewithid/{id}
    HTTP: GET /routes/info
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="additional-route-data"&gt;Additional route data&lt;/h2&gt;
&lt;p&gt;Additional route metadata can also be retrieved from &lt;code&gt;EndpointDataSource&lt;/code&gt;. The below &lt;code&gt;/routes/info&lt;/code&gt; endpoint extends on the above basic endpoint adding additional data for each endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routes/info&amp;quot;, (IEnumerable&amp;lt;EndpointDataSource&amp;gt; endpointSources) =&amp;gt;
{
    var sb = new StringBuilder();
    var endpoints = endpointSources.SelectMany(es =&amp;gt; es.Endpoints);

    // iterate through each endpoint
    foreach (var endpoint in endpoints)
    {
        // get the display name
        sb.AppendLine($&amp;quot;Endpoint: {endpoint.DisplayName}&amp;quot;);

        // check if the endpoint is a RouteEndpoint
        if (endpoint is RouteEndpoint routeEndpoint)
        {
            // output route pattern information
            sb.AppendLine($&amp;quot;        - Segment Count: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.PathSegments.Count}&amp;quot;);
            
            sb.AppendLine($&amp;quot;        - Parameters: &amp;quot;);
            foreach(var param in routeEndpoint.RoutePattern.Parameters)
            {
                sb.AppendLine($&amp;quot;            - {param.Name}&amp;quot;);
            }
            
            sb.AppendLine($&amp;quot;        - Inbound Precedence: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.InboundPrecedence}&amp;quot;);
            sb.AppendLine($&amp;quot;        - Outbound Precedence: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.OutboundPrecedence}&amp;quot;);
        }

        // output meta data
        sb.AppendLine($&amp;quot;        - Meta Count: {endpoint.Metadata.Count()}&amp;quot;);
        foreach (var meta in endpoint.Metadata)
        {
            sb.AppendLine($&amp;quot;            - Meta Type: {meta}&amp;quot;);
        }
    }

    return sb.ToString();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/routes/info&lt;/code&gt; endpoint, one can see the additional information:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Endpoint: HTTP: GET /routes
            - Segment Count: 1
            - Parameters: 
            - Inbound Precedence: 1
            - Outbound Precedence: 5
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_0(System.Collections.Generic.IEnumerable`1[Microsoft.AspNetCore.Routing.EndpointDataSource])
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /user/{userId}
            - Segment Count: 2
            - Parameters: 
                - userId
            - Inbound Precedence: 1,3
            - Outbound Precedence: 5,3
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_1(System.String)
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /routewithid/{id}
            - Segment Count: 2
            - Parameters: 
                - id
            - Inbound Precedence: 1,3
            - Outbound Precedence: 5,3
            - Meta Count: 3
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_2(Microsoft.AspNetCore.Http.HttpContext, System.String)
                - Meta Type: System.Runtime.CompilerServices.NullableContextAttribute
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /routes/info
            - Segment Count: 2
            - Parameters: 
            - Inbound Precedence: 1,1
            - Outbound Precedence: 5,5
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_3(System.Collections.Generic.IEnumerable`1[Microsoft.AspNetCore.Routing.EndpointDataSource])
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some examples of the type of information available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The count and type of each segment making up the endpoint url (e.g. lines 2 and 10)&lt;/li&gt;
&lt;li&gt;The list of parameters for an endpoint (e.g. line 12)&lt;/li&gt;
&lt;li&gt;The lambda delegate for each endpoint (e.g lines 7 and 16)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The metadata information would need to be checked and cast to the specific type to retrieve additional information - but additional information is available.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="httpcontext-route-information"&gt;HttpContext route information&lt;/h2&gt;
&lt;p&gt;Information can also be received from the &lt;code&gt;HttpContext&lt;/code&gt; of a specific request, for the endpoint being called. The information is the same as is contained in the &lt;code&gt;EndpointDataSource.Endpoints&lt;/code&gt; collection used in the above examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routewithid/{id}&amp;quot;, (HttpContext context, string id) =&amp;gt; 
        $&amp;quot;Route `{context.GetEndpoint()?.DisplayName}` with id = '{id}'&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling this endpoint with an &lt;em&gt;id&lt;/em&gt; of &lt;em&gt;&amp;quot;sampleId&amp;quot;&lt;/em&gt; (&lt;code&gt;/routewithid/sampleId&lt;/code&gt;) results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Route `HTTP: GET /routewithid/{id}` with id = 'sampleid'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;There are a number of useful outputs which could be done using this metadata information, such as outputting the information to be consumed into external api documentation, or &lt;a href="https://andrewlock.net/adding-an-endpoint-graph-to-your-aspnetcore-application/"&gt;adding an endpoint graph to the application&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/list-all-routes-in-an-asp-net-core-application.htm"&gt;How to list all routes in an ASP.NET Core application&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0"&gt;Routing in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;86: 01-06-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>