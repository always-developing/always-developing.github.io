<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-10-10T05:06:09Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages</id>
		<title>Automatic redirect on http status code</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages" />
		<updated>2022-10-10T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UseStatusCodePagesWithRedirects&lt;/code&gt; method can be used to redirect the client to an error page in the case of a non-successful request (400-599 range)&lt;/p&gt;
&lt;p&gt;This method returns a &lt;em&gt;301-Found&lt;/em&gt; to the client, and then redirects to the &lt;em&gt;redirect endpoint&lt;/em&gt; which will return a status code of &lt;em&gt;200-Success&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is often used when the app:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should redirect the client to a different endpoint, perhaps to have a different application process the error. In the browser, the redirect endpoint will be reflected&lt;/li&gt;
&lt;li&gt;Doesn't need to preserve and return the original status code with the initial redirect response back to the client&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="middleware-setup"&gt;Middleware setup&lt;/h2&gt;
&lt;p&gt;First step is to enable the automatic redirect functionality - this step is very straight-froward, and entails adding a single middleware components:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = builder.Build();

// other middleware setup goes here
app.UseStatusCodePagesWithRedirects("/error?status={0}");
// other middleware setup goes here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the middleware is instructed to redirect any responses (which are not successful) to the &lt;code&gt;/error&lt;/code&gt; endpoint. The endpoint can include a &lt;code&gt;{0}&lt;/code&gt; placeholder which will contain the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="error-endpoint"&gt;Error endpoint&lt;/h2&gt;
&lt;p&gt;Next, up the &lt;code&gt;/error&lt;/code&gt; endpoint is defined.&lt;/p&gt;
&lt;p&gt;Here the &lt;em&gt;Map&lt;/em&gt; method is used - this takes an &lt;em&gt;IApplicationBuilder&lt;/em&gt; as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.Map("/error", errorApp =&amp;gt;
{
    errorApp.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync($"This is a redirected " +
            $"error message status {context.Request.Query["status"]}");
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For all &lt;em&gt;error&lt;/em&gt; responses, the message will be output along with the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="execution"&gt;Execution&lt;/h2&gt;
&lt;p&gt;A number of other endpoints were also defined to simulate different status code responses:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/500response", context =&amp;gt;
{
    context.Response.StatusCode = 500;
    return Task.CompletedTask;
});

app.MapGet("/401response", context =&amp;gt;
{
    context.Response.StatusCode = 401;
    return Task.CompletedTask;
});

app.MapGet("/200response", context =&amp;gt;
{
    context.Response.StatusCode = 200;
    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/500response&lt;/code&gt; from a browser, for example, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a redirected error message status 500
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And looking at the &lt;em&gt;Network&lt;/em&gt; tab of the browse, one can see that the initial status code returned is &lt;code&gt;302&lt;/code&gt;, followed by the &lt;code&gt;200 on redirect&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/statuscode.png" alt="HTTP Status code"&gt;&lt;/p&gt;
&lt;p&gt;Now, on error (500 status code), the caller is routed to a generic error page, with a &lt;em&gt;200&lt;/em&gt; response, and the actual error in the content of the page.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;For a lot of situations this might not be especially useful, as the return message and status code is not especially useful to the calling application to act on.&lt;/p&gt;
&lt;p&gt;For a customer facing application this could be useful (providing the actual error is logged and recorded somewhere) as the customer doesn't care about the details of the eror, but for a backend api-to-api call, the string response is not especially useful.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/diagnostics/diagnostics-5"&gt;Status Pages&lt;/a&gt;&lt;br&gt;
&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-6.0#usestatuscodepageswithredirects"&gt;UseStatusCodePages&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;178: 10-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/07-linq-type-performance</id>
		<title>Performant LINQ type checks</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/07-linq-type-performance" />
		<updated>2022-10-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In a previous post, we had a look at &lt;a href="https://alwaysdeveloping.net/08/19-linq-oftype"&gt;LINQ's OfType&lt;/a&gt; method - while personally this is still my preferred method (for readability) to do &lt;em&gt;type comparisons&lt;/em&gt; using LINQ, it is not the most performant.&lt;/p&gt;
&lt;p&gt;If performing &lt;em&gt;type checks&lt;/em&gt; using LINQ, a &lt;code&gt;GetType() == typeof&lt;/code&gt; check is the most performant.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="type-checks"&gt;Type checks&lt;/h2&gt;
&lt;p&gt;First, we'll have a look at the various methods for doing &lt;em&gt;type comparisons&lt;/em&gt; in LINQ which will be benchmarked.&lt;/p&gt;
&lt;p&gt;In all of the below example, as well as the benchmarks, a &lt;code&gt;List&amp;lt;object&amp;gt;&lt;/code&gt; is used, which contains &lt;code&gt;100 items&lt;/code&gt; either a &lt;em&gt;TypeA&lt;/em&gt; class, or a &lt;em&gt;TypeB&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// sample of the items - in the actual benchmark, _items
// contained 100 items
private List&amp;lt;object&amp;gt; _items = new List&amp;lt;object&amp;gt; {
    new TypeA(), new TypeA(), new TypeB(), new TypeA(), new TypeB()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where applicable,  different variations on the techniques, one using &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt; the cast, and the other using the &lt;code&gt;Cast&lt;/code&gt; method, were also benchmarked.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="oftype"&gt;OfType&lt;/h3&gt;
&lt;p&gt;The first method is by using the &lt;code&gt;OfType&lt;/code&gt; method, explored in a &lt;a href="https://alwaysdeveloping.net/08/19-linq-oftype"&gt;previous post&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
            .OfType&amp;lt;TypeA&amp;gt;()
            .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I still find this to be the cleanest and easiest to read method.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="cast-with-is"&gt;Cast with is&lt;/h3&gt;
&lt;p&gt;The next approach is to use the &lt;code&gt;is&lt;/code&gt; keyword to check the &lt;em&gt;type&lt;/em&gt; and then use the &lt;code&gt;Cast&lt;/code&gt; method to cast the filtered items to the desired type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t is TypeA)
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Where&lt;/code&gt; method filters down the list to items of only &lt;em&gt;TypeA&lt;/em&gt; however, the filtered list is still of type &lt;em&gt;object&lt;/em&gt;, and hence the &lt;code&gt;Cast&lt;/code&gt; method needs to be used to convert to the correct type.&lt;/p&gt;
&lt;p&gt;The variation is the same as the above, but instead using the &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t is TypeA)
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="cast-with-is-1"&gt;Cast with is&lt;/h3&gt;
&lt;p&gt;Next up we use the &lt;code&gt;as&lt;/code&gt; keyword to check the &lt;em&gt;type&lt;/em&gt;. This casts the object to &lt;em&gt;TypeA&lt;/em&gt;, and checks that the result is not null (the cast is possible). Then like the previous example, the &lt;code&gt;Cast&lt;/code&gt; method to cast the filtered items to the desired type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t as TypeA is not null)
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As before, the &lt;code&gt;Where&lt;/code&gt; method filters down the list to items of only &lt;em&gt;TypeA&lt;/em&gt; however, the filtered list is still of type &lt;em&gt;object&lt;/em&gt;, and hence the &lt;code&gt;Cast&lt;/code&gt; method needs to be used to convert to the correct type.&lt;/p&gt;
&lt;p&gt;As above, variation is the same as the above technique, but instead using the &lt;code&gt;Select&lt;/code&gt; method to &lt;em&gt;cast&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="gettype-with-typeof"&gt;GetType with typeof&lt;/h3&gt;
&lt;p&gt;The last method is the most &lt;em&gt;raw&lt;/em&gt; method - manually get the type of the item in the list, and check if its of the same type we desire. Then as before, perform the &lt;code&gt;Cast&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Cast&amp;lt;TypeA&amp;gt;()
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    var filter = _items
        .Where(t =&amp;gt; t.GetType() == typeof(TypeA))
        .Select(t =&amp;gt; (TypeA)t)
        .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="performance-results"&gt;Performance Results&lt;/h2&gt;
&lt;p&gt;Running the above queries against a list of 100 items, the result are:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IsType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.759 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0334 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0279 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.749 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsTypeSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.430 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0275 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0609 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.416 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AsType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.862 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0570 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1071 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.844 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AsTypeSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.265 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0298 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0846 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.296 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OfType&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.873 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0320 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0284 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.870 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.23 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GetTypeTypeOf&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.520 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0495 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0463 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.510 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.27 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GetTypeTypeOfSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.121 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0100 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0093 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.124 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.29 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the result, using &lt;code&gt;GetType == typeof&lt;/code&gt; is the &lt;code&gt;fastest method&lt;/code&gt; (while also very slightly using the most memory), while using &lt;code&gt;OfType&lt;/code&gt; is the &lt;code&gt;slowest method&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using &lt;em&gt;Select&lt;/em&gt; to cast is also approximately &lt;code&gt;twice as fast&lt;/code&gt; as using &lt;em&gt;Cast&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the &lt;em&gt;GetTypeTypeOfSelect&lt;/em&gt; method was my far the fastest method, when performing a single LINQ command, the difference is not going to be noticeable (nano-seconds scale) - however if the collections are larger, and the time frames start moving into the milliseconds or seconds realm, then the method used starts to make a difference. However as usual, benchmark your specific use case and result may vary based on the type of entity, as well as the collection size.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=dIu5EisoB_s"&gt;The fastest way to cast objects in C# is not so obvious&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;177: 07-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/06-string-create</id>
		<title>Culture specific strings with String.Create</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/06-string-create" />
		<updated>2022-10-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Introduced in C# 10 (.NET 6), the &lt;code&gt;String.Create&lt;/code&gt; method can be used to evaluate an &lt;em&gt;interpolated string&lt;/em&gt; to a specific culture (including the invariant culture). This method is faster, and uses less resources than the previously available method of using &lt;code&gt;FormattableString&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="formattablestring"&gt;FormattableString&lt;/h2&gt;
&lt;h3 id="invariant"&gt;Invariant&lt;/h3&gt;
&lt;p&gt;Prior to C# 10 &lt;code&gt;FormattableString&lt;/code&gt; was the method used, and evaluating an &lt;em&gt;interpolated string&lt;/em&gt; to &lt;em&gt;invariant culture&lt;/em&gt; was fairly straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output the string formatted to &amp;quot;invariant culture&amp;quot;
Console.WriteLine(FormattableString.Invariant(
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 03:49:41
Decimal: 1.99 | Date: 09/12/2022 03:49:41
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="culture-specific"&gt;Culture specific&lt;/h3&gt;
&lt;p&gt;Evaluating an &lt;em&gt;interpolated string&lt;/em&gt; to &lt;em&gt;a specific culture&lt;/em&gt; is slightly more complicated when using &lt;code&gt;FormattableString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output the string formatted in the specific culture
// first declare the FormattableString
FormattableString formattable = $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;;
// ToString specifying the culture
Console.Write(formattable.ToString(CultureInfo.GetCultureInfo(&amp;quot;en-US&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:00:47
Decimal: 1.99 | Date: 9/12/2022 4:00:47 AM
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="string.create"&gt;String.Create&lt;/h2&gt;
&lt;h3 id="invariant-1"&gt;Invariant&lt;/h3&gt;
&lt;p&gt;The new &lt;code&gt;String.Create&lt;/code&gt; method introduced in .NET6 with C# 10, simplifies the evaluation of a interpolated string to a specific culture:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output string with the specific culture (invariant)
Console.WriteLine(String.Create(CultureInfo.InvariantCulture,
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above (which is the same as when using &lt;em&gt;FormattableString.Invariant&lt;/em&gt; above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:02:59
Decimal: 1.99 | Date: 09/12/2022 04:02:59
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="culture-specific-1"&gt;Culture specific&lt;/h3&gt;
&lt;p&gt;Specifying a &lt;em&gt;specific culture&lt;/em&gt; with &lt;code&gt;String.Create&lt;/code&gt; is just as simple as specifying &lt;em&gt;InvariantCulture&lt;/em&gt;, and definitely simpler than the &lt;em&gt;FormattableString&lt;/em&gt; equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private decimal decValue = 1.99m;
private DateTime dateValue = DateTime.UtcNow;

// output the default interpolated string
Console.WriteLine($&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;);

// output string with the specific culture (en-US)
Console.WriteLine(String.Create(CultureInfo.GetCultureInfo(&amp;quot;en-US&amp;quot;),
    $&amp;quot;Decimal: {decValue} | Date: {dateValue}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above (which is the same as when using &lt;em&gt;FormattableString&lt;/em&gt; with the specific culture above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Decimal: 1,99 | Date: 2022/09/12 04:05:15
Decimal: 1.99 | Date: 9/12/2022 4:05:15 AM
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;BenchmarkDotNet&lt;/code&gt; to compare the speed and memory usage of the above 4 methods, we can see that in all cases, using the &lt;em&gt;String.Create&lt;/em&gt; version is &lt;code&gt;faster, and uses less memory&lt;/code&gt; than the &lt;em&gt;FormattableString versions&lt;/em&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;StringFormatterInvariant&lt;/td&gt;
&lt;td style="text-align: right;"&gt;342.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.92 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.60 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0367&lt;/td&gt;
&lt;td style="text-align: right;"&gt;232 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringFormatterCulture&lt;/td&gt;
&lt;td style="text-align: right;"&gt;400.2 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.81 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.87 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0429&lt;/td&gt;
&lt;td style="text-align: right;"&gt;272 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringCreateInvariant&lt;/td&gt;
&lt;td style="text-align: right;"&gt;272.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.86 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.42 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0162&lt;/td&gt;
&lt;td style="text-align: right;"&gt;104 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringCreateCulture&lt;/td&gt;
&lt;td style="text-align: right;"&gt;326.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.41 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.91 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0229&lt;/td&gt;
&lt;td style="text-align: right;"&gt;144 B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Even though the performance and memory improvements are slight (nano-seconds and bytes), if your application is making &lt;code&gt;heavy use of FormattableString&lt;/code&gt; to format strings to specific cultures, then there are gains to be had by converting to using &lt;code&gt;String.Create&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/performance-string-create-vs-formattablestring.htm"&gt;Performance: string.Create vs FormattableString&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;176: 06-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter</id>
		<title>Manually passing parameters to a middleware component</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter" />
		<updated>2022-10-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;It is possible to &lt;code&gt;manually pass parameters to a middleware component&lt;/code&gt; when configuring the component and middleware pipeline on startup. &lt;em&gt;Manually passed parameters&lt;/em&gt; can be used in conjunction with parameters provided by the &lt;em&gt;dependency injection&lt;/em&gt; container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="middleware-configuration"&gt;Middleware configuration&lt;/h2&gt;
&lt;p&gt;In the below examples, to demonstrate a parameter provided by the DI container, a simple &lt;em&gt;ApplicationConfiguration&lt;/em&gt; class has been configured with the dependency injection container as &lt;em&gt;transient&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient(typeof(ApplicationConfiguration));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="distinct-parameters"&gt;Distinct parameters&lt;/h3&gt;
&lt;p&gt;If a middleware component has &lt;code&gt;parameters which are of distinct types&lt;/code&gt; then when adding the component to the middleware pipeline, the parameters can be specified in &lt;code&gt;any order&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below, the &lt;em&gt;DistinctParamMiddleware&lt;/em&gt; constructor has distinct types as parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DistinctParamMiddleware 
{
    private readonly int _version;
    private readonly string _name;
    private readonly ApplicationConfiguration _setup;
    private readonly RequestDelegate _next;

    // all distinct parameters
    public DistinctParamMiddleware(RequestDelegate next, string name, 
        int version, ApplicationConfiguration setup)
    {
        _version = version;
        _name = name;
        _setup = setup;
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        Console.WriteLine($&amp;quot;In {nameof(DistinctParamMiddleware)} with&amp;quot; +
            $&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

        await _next(context);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parameters can manually be passed in when using the &lt;code&gt;UseMiddleware&lt;/code&gt; method on startup, and because the parameter types are distinct, the manually supplied parameters can be passed in any order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;DistinctParamMiddleware&amp;gt;( 1, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, &lt;code&gt;RequestDelegate&lt;/code&gt; and &lt;code&gt;ApplicationConfiguration&lt;/code&gt; are supplied from the &lt;em&gt;dependency injection container&lt;/em&gt;, while the &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; parameters are supplied &lt;code&gt;manually&lt;/code&gt;. Even though the constructor has the &lt;em&gt;string parameter&lt;/em&gt; specified first, and then the &lt;em&gt;int parameter&lt;/em&gt;, when invoking the &lt;em&gt;UseMiddleware&lt;/em&gt; method, the values are not supplied in that order.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="non-distinct-parameters"&gt;Non-distinct parameters&lt;/h3&gt;
&lt;p&gt;When dealing with a middleware component which does &lt;code&gt;not have parameters which are of distinct types&lt;/code&gt;, then the parameter values need to be supplied in order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DuplicateTypeParamMiddleware
{
	private readonly ApplicationConfiguration _setup;
	private readonly RequestDelegate _next;
	private readonly string _name;
	private readonly string _version;

    // two string parameters
	public DuplicateTypeParamMiddleware(RequestDelegate next, string name, 
        string version, ApplicationConfiguration setup)
	{
		_setup = setup;
		_next = next;
		_name = name;
		_version = version;
	}

	public async Task Invoke(HttpContext context)
	{
		Console.WriteLine($&amp;quot;In {nameof(DuplicateTypeParamMiddleware)} with&amp;quot; +
			$&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

		await _next(context);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As there are two &lt;code&gt;string parameters&lt;/code&gt;, the first string value supplied is assigned to the &lt;em&gt;name&lt;/em&gt; parameter, and the second string value supplied is assigned to the &lt;em&gt;version&lt;/em&gt; parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Correct
app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;MiddlewareParamDemo&amp;quot;, &amp;quot;2&amp;quot;);

// Incorrect
// app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;2&amp;quot;, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This functionality is especially useful in cases when a value determined at runtime (for example, &lt;em&gt;application startup datetime&lt;/em&gt;) needs to be passed into middleware - having the ability to manually pass the value in instead of creating new entities to hold the values, and registering them with the dependency injection container, can save time and simplify code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/middleware/middleware-8/Program.cs"&gt;Inject dependency to your middleware class manually&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;175: 05-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run</id>
		<title>Map all urls with IApplicationBuilder.Run</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run" />
		<updated>2022-10-04T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method on the &lt;code&gt;WebApplication&lt;/code&gt; (which implements &lt;em&gt;IApplicationBuilder&lt;/em&gt;) can be used to map &lt;strong&gt;any and all&lt;/strong&gt; urls to the specific delegate.&lt;/p&gt;
&lt;p&gt;This can be leveraged in the case where the api doesn't expose any functional endpoints (such as with a &lt;em&gt;Background Service&lt;/em&gt;) to always display a consistent message to the caller.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="root-endpoint"&gt;Root endpoint&lt;/h2&gt;
&lt;p&gt;Usually when a web application doesn't expose any endpoints, the root endpoint might be mapped so when browsing to the url, a message is returned to at least inform the caller that the service is up and running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;/&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to &lt;code&gt;/&lt;/code&gt; will display:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The downside of this approach, is that if the user browses to any URL other than &lt;code&gt;/&lt;/code&gt;, nothing will be returned. For example, browsing to &lt;code&gt;/api&lt;/code&gt; just returns a blank page.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="run-method"&gt;Run method&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method can be leveraged to map a &lt;em&gt;delegate&lt;/em&gt; to &lt;strong&gt;all&lt;/strong&gt; endpoints:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.Run(async context =&amp;gt;
{
   await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, browsing to &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/api&lt;/code&gt; or &lt;strong&gt;any&lt;/strong&gt; other url, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, no matter the endpoint called - the &lt;code&gt;same message&lt;/code&gt; is returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="endpoint-override"&gt;Endpoint override&lt;/h2&gt;
&lt;p&gt;A word of warning - using the &lt;code&gt;Run&lt;/code&gt; method will cause the specific delegate to be called on all endpoints - even if another endpoint has specifically been defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;hello&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;World&amp;quot;);
});

app.Run(async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, browsing to &lt;code&gt;/hello&lt;/code&gt; will return &lt;code&gt;Sample application - no endpoints exposed&lt;/code&gt; and &lt;strong&gt;NOT&lt;/strong&gt; &lt;code&gt;World&lt;/code&gt; - the &lt;em&gt;Run&lt;/em&gt; method delegate overrides all over endpoint delegates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not a technique to be used for every application, but in the cases where the application is running as a background service (for example) which doesn't expose any specific endpoints, this technique can be leveraged to always display &lt;em&gt;something&lt;/em&gt; to the user.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/application-environment/Program.cs"&gt;Application Environment&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;174: 04-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses</id>
		<title>Obtaining a list of app URLs</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses" />
		<updated>2022-10-03T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IServerAddressesFeature&lt;/code&gt; or &lt;code&gt;IServer&lt;/code&gt; implementations can be used to get a list of URLs your application is responding to. In a landscape with a large number of applications which serve on multiple URLs, this could be leveraged to easily self-document all URLs currently in use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-urls"&gt;Multiple urls&lt;/h2&gt;
&lt;p&gt;For the samples below, the application has been configured to use multiple urls using the &lt;code&gt;UseUrls&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.WebHost.UseUrls(&amp;quot;http://*:5096;http://*:5097;http://localhost:5098&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we had a &lt;em&gt;&amp;quot;hello&amp;quot;&lt;/em&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/hello&amp;quot;, () =&amp;gt;
{
    return &amp;quot;world&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would get a &lt;em&gt;&amp;quot;world&amp;quot;&lt;/em&gt; response by browsing to any of the below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://localhost:5096/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5097/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5098/hello&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="address-list"&gt;Address list&lt;/h2&gt;
&lt;h3 id="iserveraddressesfeature"&gt;IServerAddressesFeature&lt;/h3&gt;
&lt;p&gt;The first method to get a list of addresses is by casting the &lt;code&gt;WebApplication&lt;/code&gt; instance to &lt;code&gt;IApplicationBuilder&lt;/code&gt; and leveraging the &lt;em&gt;ServerFeatures&lt;/em&gt; method available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// app is obtained from var app = builder.Build();
// in this example, serverAddress is a free variable
var serverAddress = (app as IApplicationBuilder)
    .ServerFeatures.Get&amp;lt;IServerAddressesFeature&amp;gt;();

app.MapGet(&amp;quot;/addresses&amp;quot;, (context) =&amp;gt;
{
    // get all addresses and output
    foreach(var address in serverAddress.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="iserver"&gt;IServer&lt;/h3&gt;
&lt;p&gt;When &lt;code&gt;IApplicationBuilder&lt;/code&gt; is not available (outside of application startup), the information is also available by injecting &lt;code&gt;IServer&lt;/code&gt; into the required constructor or delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/iserver&amp;quot;, (HttpContext context, IServer server) =&amp;gt;
{
    // get the address from IServer instead of IApplicationBuilder
    // otherwise everything else is the same
    var addressFeature = server.Features.Get&amp;lt;IServerAddressesFeature&amp;gt;();

    foreach (var address in addressFeature.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;We've looked at two different ways to get a list of addresses the application is serving on. For most applications, this might never be useful as most applications serve on a single address. However in the case where there &lt;em&gt;are&lt;/em&gt; multiple addresses, this could be used to self document and easily keep track of application's addresses.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/features/features-server-addresses"&gt;Server Addresses Feature&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/features/features-server-addresses-2"&gt;Server Addresses Feature - 2&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;173: 03-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation</id>
		<title>Minimal api's and cancellation tokens</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation" />
		<updated>2022-09-30T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; can be passed into a minimal api endpoint to be used to &lt;em&gt;cancel processing executed by the endpoint&lt;/em&gt; - the cancellation token will automatically be marked as cancelled if the caller either cancels the request or navigates away from the endpoint (if being accessed from the browser)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="process-cancellation"&gt;Process cancellation&lt;/h2&gt;
&lt;h3 id="no-token"&gt;No token&lt;/h3&gt;
&lt;p&gt;Consider the following minimal api endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/long&amp;quot;, async () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    // simulate a long running process
    await Task.Delay(5000);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the application is executed, and the endpoint called, the output would be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;02: Starting long process
07: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, it takes approximately 5 seconds for the endpoint to execute and finish.&lt;/p&gt;
&lt;p&gt;If the endpoint is called again, and during those 5 seconds of &amp;quot;processing&amp;quot;, the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button is clicked on the browser (wording may differ slightly depending on browser) we see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;52: Starting long process
57: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the &lt;code&gt;request from the browser to the endpoint is cancelled, the processing done by the endpoint is not cancelled!&lt;/code&gt;. The endpoint isn't aware of the fact the request was cancelled, which results in unnecessary CPU and memory usage, no longer required as the user has decided to cancel the request.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellationtoken"&gt;CancellationToken&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CancellationToken&lt;/code&gt; to the rescue - a &lt;em&gt;cancellation token&lt;/em&gt; can be used to convey information to the endpoint about the status of the request.&lt;/p&gt;
&lt;p&gt;Let's update the endpoint to use a cancellation token:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// add cancellation token, which is automatically populated
app.MapGet(&amp;quot;/long&amp;quot;, async (CancellationToken token) =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    //forward the token onto the method
    await Task.Delay(5000, token);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a &lt;code&gt;CancellationToken&lt;/code&gt; is specified to be passed into the endpoint - this automatically gets instantiated and is &lt;em&gt;&amp;quot;linked&amp;quot;&lt;/em&gt; to the HTTP context of the request. If the request is cancelled by the caller, the &lt;code&gt;CancellationToken&lt;/code&gt; will indicate this fact.&lt;/p&gt;
&lt;p&gt;Most &lt;em&gt;async&lt;/em&gt; methods (such as &lt;code&gt;Task.Delay&lt;/code&gt; in this instance) have an optional &lt;code&gt;CancellationToken&lt;/code&gt; parameter which can be used to pass a token all the way down the call stack to the code doing the actual work/processing, which will then in turn monitor and check if the token has been cancelled.&lt;/p&gt;
&lt;p&gt;Invoking this endpoint now, and clicking the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button on the browser while the endpoint is still processing will result in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;27: Starting long process
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]
      An unhandled exception has occurred while executing the request.
      System.Threading.Tasks.TaskCanceledException: A task was canceled.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a &lt;code&gt;CancellationToken&lt;/code&gt; is used to cancel a process, it is up to the library author to decide if cancelling means an exception be thrown (such as in the above example with &lt;em&gt;Task.Delay&lt;/em&gt;), or if processing simply just stops.&lt;/p&gt;
&lt;p&gt;While the endpoint &lt;code&gt;process is now successfully&lt;/code&gt; cancelled when the request is cancelled, not using unnecessary resources - we now have to deal with and cater for the &lt;code&gt;TaskCanceledException&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellation-middleware"&gt;Cancellation middleware&lt;/h3&gt;
&lt;p&gt;A &lt;em&gt;custom middleware&lt;/em&gt; component can be written to catch any exceptions of type &lt;code&gt;TaskCanceledException&lt;/code&gt;, log it and return a different response to the caller (which they will not care about, as they have cancelled the request):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CancellationMiddleware
{
    private readonly RequestDelegate _next;

    public CancellationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        // catch any canceled exceptions
        // TaskCanceledException inherits from OperationCanceledException
        catch (OperationCanceledException)
        {
            Console.WriteLine($&amp;quot;Cancelled request handled by {nameof(CancellationMiddleware)}&amp;quot;);
            // the called has cancelled the request
            // so doesn't care about the response
            // Totally legit HTTP response code
            context.Response.StatusCode = StatusCodes.Status418ImATeapot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware is then registered on startup:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;CancellationMiddleware&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now when invoking the endpoint and cancelling we see the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;18: Starting long process
Cancelled request handled by CancellationMiddleware
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Process successfully cancelled&lt;/code&gt; and &lt;code&gt;no more unhandled exception errors&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Adding &lt;code&gt;CancellationToken&lt;/code&gt; support to a minimal endpoint is a fairly low effort improvement, with a (depending on how the endpoint gets used) potential high reward - processing which is no longer required by the caller gets cancelled, freeing up CPU and memory usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/using-cancellationtokens-in-asp-net-core-minimal-apis/"&gt;Using CancellationTokens in ASP.NET Core minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;172: 30-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/29-aot-improvements</id>
		<title>Native AOT compilation with .NET 7</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/29-aot-improvements" />
		<updated>2022-09-29T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;New functionality is being introduced with .NET 7 adds the ability to do &lt;code&gt;native ahead-of-time (AOT)&lt;/code&gt; compilation - this results in the application starting up faster, and using less memory than the traditional non-AOT alternative.&lt;/p&gt;
&lt;p&gt;While native AOT is supported in .NET 7, only a limited number of libraries are fully compatible and the functionality is currently targeted towards console-type applications, not web applications.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="aot"&gt;AOT&lt;/h2&gt;
&lt;p&gt;Publishing an application with native AOT compilation produces an app that is self-contained and that has been ahead-of-time (AOT) compiled to the native code of the architecture specified.&lt;br /&gt;
When an application is not using AOT, then &lt;em&gt;just-in-time&lt;/em&gt; compilation is used, where the code is compiled into native machine code on the fly as it is being used.&lt;/p&gt;
&lt;p&gt;From the official documentation:&lt;br /&gt;
&lt;em&gt;The benefit of native AOT is most significant for workloads with a high number of deployed instances, such as cloud infrastructure and hyper-scale services. It is currently not supported with ASP.NET Core, but only console apps.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;AOT in the broader sense is entirely not new to .NET, which currently makes use of &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/ready-to-run"&gt;ReadyToRun Compilation&lt;/a&gt; which is a form of AOT.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="publish"&gt;Publish&lt;/h2&gt;
&lt;p&gt;Let's test the AOT functionality on a simple .NET 7 console application which writes a message to the console, and then waits for a key to be pressed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the entire application
Console.WriteLine(&amp;quot;Learning about Native AOT with alwaysdeveloping.net&amp;quot;);
Console.ReadKey();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="non-aot"&gt;Non AOT&lt;/h3&gt;
&lt;p&gt;To start, we'll get a base benchmark, without using AOT:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is a &lt;code&gt;149 KB&lt;/code&gt; &lt;em&gt;AlwaysDeveloping.exe&lt;/em&gt; which took &lt;code&gt;3 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="runtime-specified"&gt;Runtime specified&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Native AOT&lt;/em&gt; requires a specific runtime architecture be specified, so let's add that into the publish command to get a better comparison. When specifying the &lt;em&gt;runtime&lt;/em&gt; architecture, &lt;em&gt;self-contained&lt;/em&gt; or &lt;em&gt;no-self-contained&lt;/em&gt; argument needs to also be specified. AOT compiled code will be self contained, so we can specify the publish as &lt;em&gt;self-contained&lt;/em&gt; as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 --self-contained
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is a &lt;code&gt;67 MB folder&lt;/code&gt;, containing &lt;em&gt;AlwaysDeveloping.exe, as well as all other dependencies&lt;/em&gt; required to run the application, and took &lt;code&gt;1.5 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="single-file"&gt;Single file&lt;/h4&gt;
&lt;p&gt;When using &lt;em&gt;Native AOT&lt;/em&gt;, the output will be a single file, so next we include that:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;62 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;3.3 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="trimming"&gt;Trimming&lt;/h4&gt;
&lt;p&gt;Next up, &lt;em&gt;Native AOT&lt;/em&gt;, will perform &lt;em&gt;trimming&lt;/em&gt; (removal of specific portions of code never called):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;11 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;5 seconds to compile.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="readytorun"&gt;ReadyToRun&lt;/h4&gt;
&lt;p&gt;The final step before comparing to &lt;em&gt;Native AOT&lt;/em&gt; is to specify the existing form of AOT, &lt;code&gt;ReadyToRun&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true -p:PublishTrimmed=true -p:PublishReadyToRun=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;14 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;10 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="aot-1"&gt;AOT&lt;/h3&gt;
&lt;p&gt;FInally let's compile using &lt;em&gt;Native AOT&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishAot=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;3.6 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;3-12 seconds to compile&lt;/code&gt; (I ran this a few times, and the compile time was variable between 3 and 12 seconds)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limitations"&gt;Limitations&lt;/h2&gt;
&lt;p&gt;There are &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot#limitations-of-native-aot-deployment"&gt;limitations&lt;/a&gt; when working with &lt;em&gt;native AOT&lt;/em&gt; which need to be kept in mind, and may limit the ability to leverage the &lt;em&gt;native AOT&lt;/em&gt; functionality:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No dynamic loading&lt;/li&gt;
&lt;li&gt;No runtime code generation&lt;/li&gt;
&lt;li&gt;Trimming is required (quick has its own limitations)&lt;/li&gt;
&lt;li&gt;Single file is required (which has known incompatibilities)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;Native AOT&lt;/code&gt; compilation results in a &lt;strong&gt;much&lt;/strong&gt; smaller output compared with the equivalent (as much as possible) configuration using non-AOT (3.6MB vs 14MB). With the improved startup performance and memory usage, if the limitations allow it, &lt;em&gt;Native AOT&lt;/em&gt; should definitely be considered. This is just the start, and I am sure there will be more improvements to come with future releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot"&gt;Native AOT Deployment&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://code.soundaranbu.com/trying-out-native-aot-in-net-7-preview-7/"&gt;Trying out Native AOT in .NET 7 Preview 7&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;171: 29-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/28-typed-middleware</id>
		<title>Strongly typed middleware with IMiddleware</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/28-typed-middleware" />
		<updated>2022-09-28T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;To create &lt;code&gt;custom ASP.NET Core middleware&lt;/code&gt;, all that is required is a class with an &lt;code&gt;Invoke or InvokeAsync method&lt;/code&gt;. However, if configured incorrectly, the error will not be apparent until &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IMiddleware&lt;/code&gt; interface can be used to ensure custom middleware contains the correct method, through the implementation of the interface, ensuring any configuration errors are apparent at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="weakly-typed"&gt;Weakly typed&lt;/h2&gt;
&lt;p&gt;To define a &lt;em&gt;working&lt;/em&gt; middleware component, a class with an &lt;code&gt;Invoke&lt;/code&gt; or &lt;code&gt;InvokeAsync&lt;/code&gt; method needs to be defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class WeakTypeMiddleware
{
    private readonly RequestDelegate _next;

    public WeakTypeMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(WeakTypeMiddleware)}&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the components must be added to the middleware pipeline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;WeakTypeMiddleware&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, &lt;code&gt;nothing is preventing the middleware component from accidentally being configured incorrectly&lt;/code&gt; - in the below example the class doesn't contain a method with the correct name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class WeakTypeMiddleware
{
    private readonly RequestDelegate _next;

    public WeakTypeMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    // incorrect method name used
    public async Task InvokePipeline(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(WeakTypeMiddleware)}&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above class is a &lt;em&gt;valid class&lt;/em&gt;, but not a valid &lt;em&gt;middleware component&lt;/em&gt;. The above code will compile, but an exception will occur when trying to call an endpoint which makes use of the component:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;System.InvalidOperationException: 'No public 'Invoke' or 'InvokeAsync' 
    method found for middleware of type 'WeakTypeMiddleware'.'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception tells us exactly what the problem is, and how to resolve it - it is easily fixed. However a better and cleaner approach is to &lt;em&gt;never encounter the exception in the first place&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="strongly-typed"&gt;Strongly typed&lt;/h2&gt;
&lt;p&gt;A middleware component can be strongly typed by using the &lt;code&gt;IMiddleware&lt;/code&gt; interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class StrongTypeMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(StrongTypeMiddleware)}&amp;quot;);

        await next.Invoke(context);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interface enforces the &lt;code&gt;InvokeAsync&lt;/code&gt; method on the implementation, ensuring it will be configured correctly.&lt;/p&gt;
&lt;p&gt;A slight difference between the two,is that with the &lt;em&gt;weakly typed&lt;/em&gt; implementation, the &lt;code&gt;next delegate is passed into the constructor&lt;/code&gt;, however with the &lt;em&gt;strongly typed&lt;/em&gt; implementation, the &lt;code&gt;next delegate is passed into the InvokeAsync method&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Implementing &lt;em&gt;strongly typed&lt;/em&gt; middleware using &lt;code&gt;IMiddleware&lt;/code&gt; instead of having the components &lt;em&gt;weakly typed&lt;/em&gt; is a minor code change, and may not offer any immediately obvious benefits - however, using the interface will ensure code uniformity across all middleware components, as well as make it easier to find and identify middleware components in a large code base.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mikesdotnetting.com/article/359/strongly-typed-middleware-in-asp-net-core"&gt;Strongly Typed Middleware in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;170: 28-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/09/27-expando-property-change</id>
		<title>dynamic, ExpandoObject and INotifyPropertyChanged</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/09/27-expando-property-change" />
		<updated>2022-09-27T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExpandoObject&lt;/code&gt; implements &lt;em&gt;INotifyPropertyChanged&lt;/em&gt; - a callback delegate can be added to be invoked when a property value on the &lt;code&gt;ExpandoObject&lt;/code&gt; instances changes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="expandoobject"&gt;ExpandoObject&lt;/h2&gt;
&lt;p&gt;A quick overview of &lt;code&gt;ExpandoObject&lt;/code&gt; - it represents an object whose members can be dynamically added and removed at run time.&lt;/p&gt;
&lt;p&gt;In the examples below, it is being used to represent a &lt;em&gt;product&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic product = new ExpandoObject();
product.Name = &amp;quot;Green Shirt&amp;quot;;
product.Rating = 4.3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The properties &lt;em&gt;Name&lt;/em&gt; and &lt;em&gt;Rating&lt;/em&gt; are added at runtime. The properties can then be accessed as if they were traditional class properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(product.Name);
Console.WriteLine(product.Rating);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="calculation"&gt;Calculation&lt;/h2&gt;
&lt;p&gt;In the examples below, we have a collection of &lt;em&gt;Products&lt;/em&gt;, each with a customer rating:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public dynamic[] GetProducts()
{
    dynamic prod1 = new ExpandoObject();
    prod1.Name = &amp;quot;Green Shirt&amp;quot;;
    prod1.Rating = 4.3;

    dynamic prod2 = new ExpandoObject();
    prod2.Name = &amp;quot;Blue Shirt&amp;quot;;
    prod2.Rating = 4.9;

    dynamic prod3 = new ExpandoObject();
    prod3.Name = &amp;quot;Shoes&amp;quot;;
    prod3.Rating = 3.8;

    dynamic prod4 = new ExpandoObject();
    prod4.Name = &amp;quot;Jeans&amp;quot;;
    prod4.Rating = 5.0;

    dynamic prod5 = new ExpandoObject();
    prod5.Name = &amp;quot;Peak cap&amp;quot;;
    prod5.Rating = 1.7;

    return new dynamic[] { prod1, prod2, prod3, prod4, prod5 };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to find the &lt;code&gt;average rating for all products&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ComputeAverageRating()
{
    avgRating = products.Average(p =&amp;gt; (double)p.Rating);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-invocation"&gt;Manual invocation&lt;/h3&gt;
&lt;p&gt;Getting the average for all products is straight forward - call the &lt;code&gt;ComputeAverageRating&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();

var avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, every time a rating on one of the &lt;em&gt;Products&lt;/em&gt; changes, the method needs to manually be called again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();

var avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);

// the product rating changed from 5 to 4.5
products[3].Rating = 4.5;

avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Average product rating is: 3,94
Average product rating is: 3,84
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this method works without issue, as mentioned, it requires manually recalculating the average every time one of the &lt;em&gt;Rating&lt;/em&gt; property values changes.&lt;/p&gt;
&lt;p&gt;A different method, requiring less manual work - is to leverage the &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; functionality of &lt;code&gt;ExpandoObject&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="inotifypropertychanged"&gt;INotifyPropertyChanged&lt;/h3&gt;
&lt;p&gt;With this method, once we have the list of &lt;em&gt;Products&lt;/em&gt; we can &lt;code&gt;register a method to be called whenever a property on the Product changes&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void RegisterPropertyChange(dynamic[] products)
{
    foreach(var product in products)
    {
        // cast each product to INotifyPropertyChanged
        // and register a callback method to be called
        // every time a property changes.
        // The cast is valid as ExpandoObject implements
        // INotifyPropertyChanged
        ((INotifyPropertyChanged)product).PropertyChanged += 
            new PropertyChangedEventHandler(
                (sender, e) =&amp;gt;
                {
                    // when a property changes, call this method
                    ComputeAverageRating();
                }
            );
    }

    // calculate the average for the first time once 
    // the callbacks have all been registered
    ComputeAverageRating();
}

public void ComputeAverageRating()
{
    // avgRating is defined on the parent class
    avgRating = products.Average(p =&amp;gt; (double)p.Rating);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can now be utilized as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();
RegisterPropertyChange(products);

Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);

products[3].Rating = 4.5;

Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the average rating calculation doesn't have to be called manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Average product rating is: 3,94
Average product rating is: 3,84
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the &lt;code&gt;ExpandoObject&lt;/code&gt; is a very useful class, it does have it's drawbacks, performance being a big one. However, when it is required it can prove to be invaluable - with the bonus advantage of being able to leverage the &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; functionality if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/create-class-dynamically-csharp/"&gt;How to Create a Class Dynamically in C#?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;169: 27-09-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>