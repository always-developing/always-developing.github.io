<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-12-07T03:42:02Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception</id>
		<title>Unreachable code and UnreachableException</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception" />
		<updated>2022-12-07T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; was introduced in .NET 7, which is used in situations &lt;em&gt;when the application executes code thought to be unreachable&lt;/em&gt;. If this exception does occur, then there is an error in the flow or data of the application causing the, previous thought, unreachable code to be executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unreachable-code-setup"&gt;Unreachable code setup&lt;/h2&gt;
&lt;p&gt;Consider the follow example of example - we have an &lt;code&gt;enum&lt;/code&gt; of &lt;em&gt;OrderStatus&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum OrderStatus
{
    New = 0,
    Processing = 1,
    Fulfilled = 2,
    OutOnDelivery = 3,
    Delivered = 4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As well as a switch expression to convert the &lt;code&gt;enum&lt;/code&gt; value to a &lt;code&gt;string description&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; is used if the code tries to convert an &lt;code&gt;OrderStatus which does not exist&lt;/code&gt; to a string - in theory a situation which should never occur.&lt;/p&gt;
&lt;p&gt;We also have a method to retrieve the order status, &lt;code&gt;stored as an int&lt;/code&gt;, from the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public OrderStatus GetOrderStatusFromDatabase()
{
    // simulate getting the value from the database
    return (OrderStatus)2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="executing-unreachable-code"&gt;Executing unreachable code&lt;/h2&gt;
&lt;p&gt;If the database stores a valid &lt;em&gt;OrderStatus&lt;/em&gt; int value, everything will execute as expected.&lt;/p&gt;
&lt;p&gt;In this example, the database &lt;code&gt;stores an OrderStatus value of 2&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 2
OrderStatus currentStatus = GetOrderStatusFromDatabase();

var currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException()
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Order: Processing Order
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if the &lt;em&gt;OrderStatus&lt;/em&gt; was manually, incorrectly &lt;code&gt;updated to be 5&lt;/code&gt; in the database - this is a situation which &lt;em&gt;should never happen, but in reality it could&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 5
OrderStatus currentStatus = GetOrderStatusFromDatabase();

string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The C# code &lt;code&gt;allows the currentStatus variable to be set to a value of 5, an enum value which doesn't exist&lt;/code&gt; - and only when it comes time to convert to a string (in the  switch expression), will there be no match to any of the options and the &lt;code&gt;UnreachableException&lt;/code&gt; be thrown.&lt;/p&gt;
&lt;p&gt;Monitoring tools or logs can now be checked for the presence of &lt;code&gt;UnreachableException&lt;/code&gt; and if such an exception occurs, something has gone wrong.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful tool at a developers disposal to assist in tracking down completely unexpected issues which may arise - but a tool which should hopefully never actually be reached to be used!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=s_NrqRI7Gnc&amp;amp;t=308s"&gt;The new .NET Exception that should NEVER be thrown&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 07-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes</id>
		<title>Determining bytes of memory allocated</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes" />
		<updated>2022-12-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;em&gt;Garbage Collector&lt;/em&gt; class &lt;code&gt;GC&lt;/code&gt; contains a &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; method which can be used to &lt;em&gt;get the number of bytes allocated&lt;/em&gt; in the current thread (as the name implies).&lt;/p&gt;
&lt;p&gt;This can be leveraged to discover some interesting facts about how the application is allocated &lt;em&gt;unessacary memory&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getallocatedbytes-usage"&gt;GetAllocatedBytes usage&lt;/h2&gt;
&lt;p&gt;The usage of &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; is very simple and straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the bytes allocated at the start of the process
long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declare a string and use it
string strValue = &amp;quot;This is a string&amp;quot;;
Console.WriteLine(strValue);

// get the bytes allocated after
long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

// output the results
Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A snapshot of the bytes used is taken before the work, and then again after.&lt;/p&gt;
&lt;p&gt;The result of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a string
Before allocation: 1761952 | After allocation: 1764552
Bytes used: 2600
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="interesting-findings"&gt;Interesting findings&lt;/h2&gt;
&lt;h3 id="unused-variable"&gt;Unused variable&lt;/h3&gt;
&lt;p&gt;In some instances, if a variable is defined, but never used, the compiler will remove it and no memory will be allocated.&lt;/p&gt;
&lt;p&gt;Below is the same example as above, but &lt;em&gt;without the variable &amp;quot;strValue&amp;quot; ever being used&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declared, but never used
string strValue = &amp;quot;This is a string&amp;quot;;

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output here:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768144 | After allocation: 1768144
Bytes used: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler is performing optimizations to remove unused code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="empty-array"&gt;Empty array&lt;/h3&gt;
&lt;p&gt;Declaring an empty array, will still allocated memory - this is because the array itself is of type &lt;code&gt;Array&lt;/code&gt; and contains information about what the array itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768112
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Declaring multiple empty arrays, will use memory in multiples of 24 bytes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];
int[] list1 = new int[0];
int[] list2 = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this, 24 bytes x 3:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768160
Bytes used: 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use less memory, the static &lt;code&gt;Array.Empty&lt;/code&gt; method is used. This will assign the same empty static array to each instance, thus not allocated additional memory each time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// use Array.Empty instead of new []
int[] list = Array.Empty&amp;lt;int&amp;gt;();
int[] list1 = Array.Empty&amp;lt;int&amp;gt;();
int[] list2 = Array.Empty&amp;lt;int&amp;gt;();

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output, only 24 bytes used in total:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1761896 | After allocation: 1761920
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful method which can help benchmark memory usage in an application, as well as just provide an insight into interesting aspects of how the compiler allocates (or doesn't allocated) memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/db43d6f4-4b93-415f-be03-600ee358cdfd"&gt;How to get allocations in .NET? And how big is an empty array?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;217: 06-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/05-iparseable</id>
		<title>Parse a string to anything</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/05-iparseable" />
		<updated>2022-12-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# 11 introduced the ability to define &lt;code&gt;static abstract member&lt;/code&gt; (read more about those &lt;a href="https://blog.ndepend.com/c-11-static-abstract-members/"&gt;here&lt;/a&gt;) - this allowed for the introduction of the &lt;code&gt;IParseable&amp;lt;TSelf&amp;gt;&lt;/code&gt;, which allows for a &lt;code&gt;string to be parsed into any type&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iparseable-interface"&gt;IParseable interface&lt;/h2&gt;
&lt;p&gt;A quick look at the interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IParsable&amp;lt;TSelf&amp;gt; where TSelf : IParsable&amp;lt;TSelf&amp;gt;?
{
    static abstract TSelf Parse(string s, IFormatProvider? provider);
    static abstract bool TryParse([NotNullWhen(true)] string? s, 
        IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the interface defines two &lt;code&gt;Parse&lt;/code&gt; methods - both for &lt;em&gt;parsing a string&lt;/em&gt; into the &lt;code&gt;TSelf&lt;/code&gt; type. To leverage this functionality, as with other interfaces, the class which is to be &lt;em&gt;converted from a string needs to implement IParsable&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iparseable-implementation"&gt;IParseable implementation&lt;/h2&gt;
&lt;p&gt;In this example we have a simple &lt;code&gt;Song&lt;/code&gt; class which implements &lt;code&gt;IParsable&amp;lt;Song&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song : IParsable&amp;lt;Song&amp;gt;
{
    public string Name { get; set; }
    public string Artist { get; set; }
    public int LengthInSeconds { get; set; }

    private Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }

    public static Song Parse(string s, IFormatProvider? provider)
    {
        // implementation detailed below
    }

    public static bool TryParse([NotNullWhen(true)] string? s, 
        IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
    {
        // implementation detailed below
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we'll write the methods to do the parsing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="parse-implementation"&gt;Parse implementation&lt;/h3&gt;
&lt;p&gt;The simple &lt;code&gt;Parse&lt;/code&gt; method implementation will perform the conversion from &lt;em&gt;string to song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static Song Parse(string s, IFormatProvider? provider)
{
    string[] songPortions = s.Split(new[] { '|' });

    // make sure the string is in the correct format
    if (songPortions.Length != 3) 
    { 
        throw new OverflowException(&amp;quot;Expect format: Name|Artist|LengthInSeconds&amp;quot;); 
    }

    return new Song(songPortions[0], songPortions[1], Int32.Parse(songPortions[2]));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is straight-forward - the string representation is expected in a specific format, and once it is confirmed all information is present, a new &lt;code&gt;Song&lt;/code&gt; instance is declared and returned based on this information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tryparse-implementation"&gt;TryParse implementation&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;TryParse&lt;/code&gt; implementation leveraged the &lt;code&gt;Parse&lt;/code&gt; method to &lt;em&gt;try&lt;/em&gt; parse the string, and returns &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt; indicating if the parsing was successful or not, as well as a &lt;code&gt;Song&lt;/code&gt; instance if the string was able to be parsed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static bool TryParse([NotNullWhen(true)] string? s, 
    IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
{
    // do some checks
    result = null;
    if (s == null) 
    { 
        return false; 
    }

    // parse the string 
    try
    {
        result = Parse(s, provider);
        return true;
    }
    catch { return false; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IParsable&amp;lt;TSelf&amp;gt;&lt;/code&gt; interface allows for any class to use a generic interface to define how it can be instantiated from a string. Leveraging the interface and functionality is simple and easy to implement (the parsing logic might not always be though).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This may seem like a relatively small enhancement (and it is) - but it provides a very convenient way to parse string information. The new C# 11 &lt;code&gt;static abstract member&lt;/code&gt; functionality also opens the door for new techniques and coding possibilities.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/the-new-net-7-0-iparsable-interface/"&gt;The new .NET 7.0 IParsable&lt;TSelf&gt; interface&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://blog.ndepend.com/c-11-static-abstract-members/"&gt;C# 11 static abstract members&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;216: 05-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/02-compiler-warning</id>
		<title>Compiler Warning CS8981</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/02-compiler-warning" />
		<updated>2022-12-02T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# 11 introduced a new compiler warning CS8981, which is raised when a type is declared &lt;code&gt;consisting of only lowercase letters&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="the-warning"&gt;The warning&lt;/h2&gt;
&lt;p&gt;Considering the following class declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class myclass
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When using C# 11, this will raise the following warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The type name 'myclass' only contains lower-cased ascii characters. 
    Such names may become reserved for the language.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code will still compiled and execute, but the compiler is &lt;em&gt;warning&lt;/em&gt; the developer about potential future issues.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-reason"&gt;The reason&lt;/h2&gt;
&lt;p&gt;There are a couple of reasons for the warning (and I am sure other's I have not mentioned here):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Encourages best practices for class declarations, which should be declared using &lt;em&gt;PascalCase&lt;/em&gt; as a default&lt;/li&gt;
&lt;li&gt;As explicitly mentioned in the warning, it prevents potential future conflicts with potential reserved language names - this allows future versions of the language to include new keywords, limiting the impact on existing applications&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, almost inconsequential language feature - but personally I am big fan of these kinds of initiatives, and hope to see more in future versions. They help guide developers down the &amp;quot;pit of success&amp;quot; path (which not forcing it outright), and they also allow the developers of the language to enhance and grow it, with limited naming conflicts.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://newdevsguide.com/2022/11/13/the-best-csharp-11-feature/"&gt;The Best C# 11 Feature You Don’t Need&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;215: 02-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/01-context-feature</id>
		<title>Custom feature filters</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/01-context-feature" />
		<updated>2022-12-01T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Microsoft.FeatureManagement&lt;/code&gt; library, allows for a custom &lt;code&gt;context&lt;/code&gt; to be defined, and evaluated to &lt;code&gt;determine if specific functionality should be enabled or not&lt;/code&gt;, &lt;em&gt;for the specific context&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This functionality has no dependency on ASP.NET or &lt;em&gt;HttpContext&lt;/em&gt;, and as such can be used in any application type (such as console app).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;There are a number of moving pieces to the setup, which requires some classes be defined and some configuration specified to leverage the &lt;em&gt;custom feature filter management&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="define-the-context"&gt;Define the context&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;code&gt;context&lt;/code&gt; - this is a simple class which will contain all the information which will be evaluated to determine if the feature or functionality should be enabled or not.&lt;/p&gt;
&lt;p&gt;In this example, the context will just contain the user's email address:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class User
{
    public string Email { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In short - a &lt;code&gt;context&lt;/code&gt; will be created containing the supplied email address, which will be evaluated against &lt;em&gt;settings&lt;/em&gt; to determine if &lt;em&gt;normal&lt;/em&gt; or &lt;em&gt;enhanced&lt;/em&gt; processing is to occur.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-settings"&gt;Define the settings&lt;/h3&gt;
&lt;p&gt;The next step is to define a &lt;em&gt;settings&lt;/em&gt; class, which will contain properties against which the &lt;code&gt;context&lt;/code&gt; values will be evaluated.&lt;/p&gt;
&lt;p&gt;In this example, we want the &lt;em&gt;user email address domain&lt;/em&gt;, defined in the &lt;code&gt;User&lt;/code&gt; context, to be compared with a &lt;em&gt;company domain&lt;/em&gt;, defined in the settings class, &lt;code&gt;EnhancedUserSettings&lt;/code&gt;, to determine if the user should be processed using the &lt;em&gt;enhanced/preview feature&lt;/em&gt;, or the &lt;em&gt;standard existing feature&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedUserSettings
{
    public string EmailDomain { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essentially what it comes down to, is evaluating if the &lt;code&gt;email address defined in the User context has the same domain defined in the settings EnhancedUserSettings&lt;/code&gt;. If so, then the &lt;em&gt;feature&lt;/em&gt; is enabled, otherwise the feature is not enabled.&lt;/p&gt;
&lt;p&gt;The usage of this and how each class fits together will become apparent in the steps below.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-filter"&gt;Define the filter&lt;/h3&gt;
&lt;p&gt;Next, we have to define the &lt;code&gt;filter&lt;/code&gt; - this piece of code will do the actual logic to evaluate and determine if the feature should be enabled or not, based on the &lt;code&gt;context&lt;/code&gt; and &lt;code&gt;settings&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EmailDomainFilter : IContextualFeatureFilter&amp;lt;User&amp;gt;
{
    public Task&amp;lt;bool&amp;gt; EvaluateAsync(FeatureFilterEvaluationContext featureFilterContext, 
        User appContext)
    {
        // get the value from the parameters configured
        var settings = featureFilterContext.Parameters.Get&amp;lt;EnhancedUserSettings&amp;gt;();

        // perform the check
        return Task.FromResult(appContext.Email?.Split(&amp;quot;&amp;#64;&amp;quot;).Last() == 
            settings.EmailDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter implements &lt;code&gt;IContextualFeatureFilter&amp;lt;Context&amp;gt;&lt;/code&gt;, which contains one method &lt;em&gt;EvaluateAsync&lt;/em&gt;. &lt;em&gt;EvaluateAsync&lt;/em&gt; takes a generic &lt;em&gt;FeatureFilterEvaluationContext&lt;/em&gt; context, as well as the specific &lt;em&gt;User&lt;/em&gt; context defined for this filter.&lt;/p&gt;
&lt;p&gt;In the above, the &lt;code&gt;EnhancedUserSettings&lt;/code&gt; instance is obtained from the generic &lt;em&gt;FeatureFilterEvaluationContext&lt;/em&gt; context - this retrieves the values based on the configuration defined in the next section.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-configuration"&gt;Define the configuration&lt;/h3&gt;
&lt;p&gt;In the &lt;code&gt;appsettings.json&lt;/code&gt; the filter feature functionality needs to be configured:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;&amp;quot;FeatureManagement&amp;quot;: {
    &amp;quot;EnhancedUserProcessing&amp;quot;: {
      &amp;quot;EnabledFor&amp;quot;: [
        {
          &amp;quot;Name&amp;quot;: &amp;quot;EmailDomain&amp;quot;,
          &amp;quot;Parameters&amp;quot;: {
            &amp;quot;EmailDomain&amp;quot;: &amp;quot;mycompany.co.za&amp;quot;
          }
        }
      ]
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The configuration defines the filter and how it should be used:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There is a feature called &lt;code&gt;EnhancedUserProcessing&lt;/code&gt; (the name of this is important, which we will see when it comes time to use the functionality)&lt;/li&gt;
&lt;li&gt;This feature uses a filter called &lt;code&gt;EmailDomain&lt;/code&gt; - the name of the class which implements &lt;code&gt;IContextualFeatureFilter&lt;/code&gt;, &lt;em&gt;EmailDomainFilter&lt;/em&gt; in this example (the name of the class plus &lt;em&gt;Filter&lt;/em&gt; as a suffix to the class name),&lt;/li&gt;
&lt;li&gt;The parameters for this filter, &lt;code&gt;EnhancedUserSettings&lt;/code&gt;, will have a property called &lt;em&gt;EmailDomain&lt;/em&gt; which will have a value set to &lt;code&gt;mycompany.co.za&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id="setup-recap"&gt;Setup Recap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Define the &lt;code&gt;context&lt;/code&gt; - this will be the information which is dynamic (each user/request/etc will have different context values) and which is compared to the &lt;code&gt;settings&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;settings&lt;/code&gt; - this is the class which will contain the information the &lt;code&gt;context&lt;/code&gt; is compared against, to determine if the feature is enabled or not. This is static information, and is the same for all evaluations&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;filter&lt;/code&gt; - this specified exactly &lt;em&gt;how&lt;/em&gt;, the &lt;code&gt;context&lt;/code&gt; values are compared with the &lt;code&gt;settings&lt;/code&gt; values&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;configuration&lt;/code&gt; - gives the filter a name, and specifies the &lt;code&gt;settings&lt;/code&gt; values&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Finally, let's look at the usage of the &lt;code&gt;filter feature&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below a minimal API endpoint is defined to demonstrate the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// add feature management to DI container
// and add the specific filter
builder.Services.AddFeatureManagement()
       .AddFeatureFilter&amp;lt;EmailDomainFilter&amp;gt;();

var app = builder.Build();

// inject IFeatureManager implementation from the DI container
// get the email from the URL route 
app.MapGet(&amp;quot;/process/{email}&amp;quot;, async ([FromServices]IFeatureManager featureManager,
    [FromRoute]string email) =&amp;gt;
{
    // check if the feature with the name `EnhancedUserProcessing` is enabled
    // or not for the specific context (the user email)
    if(await featureManager.IsEnabledAsync(&amp;quot;EnhancedUserProcessing&amp;quot;, 
        new User { Email = email }))
    {
        return &amp;quot;Processed using ENHANCED features&amp;quot;;
    }

    return &amp;quot;Processed using NORMAL features&amp;quot;;
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IFeatureManager&lt;/code&gt; is injected into the relevent class/method, and the &lt;em&gt;IsEnabledAsync&lt;/em&gt; method is called. The specific feature to use (specified by name) is supplied along  with the relevent &lt;code&gt;context&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Browsing to the endpoint &lt;code&gt;/process/alwaysdevelpoping&amp;#64;mycompany.co.za&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processed using ENHANCED features
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While using an email with any other domain will result in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processed using NORMAL features
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a simple example, but the library does offer more sophisticated functionality around the configuration and options available to evaluate the filter (see the links available under references)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The ability to turn off/on specific features for a specific subset of users/records is a valuable tool when trying to roll out useful, experimental or preview functionality quickly to get &amp;quot;real world&amp;quot; feedback before it gets rolled out completely.
There are other more sophisticated 3rd party feature management tool available (LaunchDarkly for example), but the &lt;code&gt;Microsoft.FeatureManagement&lt;/code&gt; library is entirely adequate, especially as a starting point.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://coderethinked.com/contextual-feature-filters-in-asp-net-core/"&gt;Contextual Feature Filters in ASP.NET Core&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/use-feature-flags-dotnet-core?tabs=core5x"&gt;Tutorial: Use feature flags in an ASP.NET Core app&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;214: 01-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/30-short-support</id>
		<title>Short and arithmetic operations</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/30-short-support" />
		<updated>2022-11-30T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When performing arithmetic operations on &lt;code&gt;short&lt;/code&gt; data types, their values are converted to the &lt;code&gt;int&lt;/code&gt; types, which is also the type of the result of the operation.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;When working with integral types which could be an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;short&lt;/code&gt;, the compiler will infer &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the compiler will infer than intValue is 
// an int (even though it could be a short)
// in this specific example
var intValue = 32 / 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when specifying the variable type explicitly, the compiler will infer the value as a &lt;code&gt;short&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;short shortValue = 32 / 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the value &lt;em&gt;32&lt;/em&gt; is inferred as a &lt;code&gt;short&lt;/code&gt;, and the output of the operator is explicitly declared as a &lt;code&gt;short&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All good so far - but now is where the are a bit unexpected.&lt;/p&gt;
&lt;p&gt;Operations on an &lt;em&gt;explicitly defined&lt;/em&gt; short value, will result in a &lt;code&gt;int result&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// short value is definitely a short
short shortValue = 32 / 2;

// int response, all good
int intOutput = shortValue / 2;

// ERROR: this gives a compiler error
//short shortOutput = (shortValue / 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the last operation, even though it is being performed on a short value, the result is an &lt;code&gt;int&lt;/code&gt; and the above results in the error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot implicitly convert type 'int' to 'short'. An explicit conversion exists (are you missing a cast?)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thankfully, the error is very easy to resolve - as the error states, an explicit conversion needs to be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// All good!
short shortOutput = (short)(shortValue / 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small quirk of the language, which if encountered just needs to be managed and handled. Before being aware of this knowledge, I would have assumed that a &lt;code&gt;short&lt;/code&gt; would be returned from an operation where the operands were defined as &lt;code&gt;short&lt;/code&gt; - this assumption would be incorrect though!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/ysm6lx/why_am_i_being_forced_to_cast_to_shorts_when_i_am/"&gt;Reddit Post&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;213: 30-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/29-dyanmic-linq</id>
		<title>Dynamic LINQ with System.Linq.Dynamic.Core</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/29-dyanmic-linq" />
		<updated>2022-11-29T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The third-party, &lt;em&gt;open source&lt;/em&gt; library &lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; extends LINQ functionality allowing &lt;em&gt;dynamic, string based LINQ queries&lt;/em&gt; to be parsed, resulting in operations identical to regular LINQ.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In all of the below examples, the following snippet of code is used to get a sample collection of &lt;em&gt;Song&lt;/em&gt; entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;Song&amp;gt; GetSongs()
{
    return new[]
    {
        new Song(&amp;quot;Learn to Fly&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 245),
        new Song(&amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 312),
        new Song(&amp;quot;Bigger than my Body&amp;quot;, &amp;quot;John Mayer&amp;quot;, 281),
    };
};

public record Song(string Name, string Artist, int LengthInSeconds);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The extension methods &lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; offer are available on the &lt;em&gt;IQueryable&lt;/em&gt; interface. As such in the examples the &lt;em&gt;IEnumerable&amp;lt;Song&amp;gt;&lt;/em&gt; returned from the &lt;code&gt;GetSongs&lt;/code&gt; method is required to be converted to &lt;em&gt;IQueryable&amp;lt;Song&amp;gt;&lt;/em&gt; using the &lt;code&gt;AsQueryable&lt;/code&gt; method before the extension methods are available.&lt;/p&gt;
&lt;p&gt;Below come common use cases are shown, but the library does offer a lot more functionality - see the references links below for more information on the library.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="select"&gt;Select&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; can be used to dynamically &lt;em&gt;Select&lt;/em&gt; a property value from a collection of entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// using traditional LINQ
List&amp;lt;string&amp;gt; namesLinq = songs
  .Select(s =&amp;gt; s.Name)
  .ToList();

// dynamically specifying the property to be returned
List&amp;lt;string&amp;gt; nameDynamic = songs
  .AsQueryable()
  .Select(&amp;quot;Name&amp;quot;)
  .ToDynamicList&amp;lt;string&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;em&gt;anonymous or dynamic&lt;/em&gt; entity can also be &lt;em&gt;Selected&lt;/em&gt; out of the collection dynamically:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional
var nameArtistLinq = songs
  .Select(s =&amp;gt; new { s.Name, s.Artist })
  .ToList();

// dynamic
List&amp;lt;dynamic&amp;gt; nameArtistDynamic = songs
  .AsQueryable()
  .Select(&amp;quot;new { Name, Artist}&amp;quot;)
  .ToDynamicList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very powerful, allowing the columns to be selected to be determined &lt;em&gt;at runtime&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="filtering"&gt;Filtering&lt;/h3&gt;
&lt;p&gt;The library also provides the ability to dynamically filter a collection of records:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional
List&amp;lt;Song&amp;gt; filterLinq = songs
  .Where(x =&amp;gt; x.Artist == &amp;quot;Foo Fighters&amp;quot;)
  .ToList();

// dynamic
string column = &amp;quot;Artist&amp;quot;;
string value = &amp;quot;Foo Fighters&amp;quot;;
List&amp;lt;Song&amp;gt; filterDynamic = songs
  .AsQueryable()
  .Where($&amp;quot;{column} == \&amp;quot;{value}\&amp;quot;&amp;quot;)
  .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, very powerful as it allows the filter criteria to be be generated &lt;em&gt;at runtime&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Outputting the result of the filtering for each technique yields the same result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(filterLinq.Count());
Console.WriteLine(filterDynamic.Count());

// ouput:
// 2
// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="ordering"&gt;Ordering&lt;/h3&gt;
&lt;p&gt;The library also offers the ability to dynamically order a collection:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional LINQ ordering
List&amp;lt;Song&amp;gt; orderLinq = songs
  .OrderBy(s =&amp;gt; s.LengthInSeconds)
  .ToList();
  
List&amp;lt;Song&amp;gt; orderDescLinq = songs
  .OrderByDescending(s =&amp;gt; s.LengthInSeconds)
  .ToList();

// dynamic ordering
List&amp;lt;Song&amp;gt; orderDynamic = songs
  .AsQueryable()
  .OrderBy(&amp;quot;LengthInSeconds&amp;quot;)
  .ToList();

List&amp;lt;Song&amp;gt; orderDescDynamic = songs
  .AsQueryable()
  .OrderBy(&amp;quot;LengthInSeconds desc&amp;quot;)
  .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The functionality the library offers is very easy and intuitive to use, as one can see from the above examples.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very powerful library, and more functionality than described here. If dynamic LINQ is not required, I do not recommend replacing traditional strongly-typed LINQ with this as a based, however in cases where flexibility to change the LINQ at runtime is required, this library is incredibly powerful.&lt;/p&gt;
&lt;p&gt;If this is of interest it is definitely recommended to check out the &lt;em&gt;Dynamic LInq&lt;/em&gt; reference link below for more information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/using-dynamic-linq/"&gt;Using Dynamic LINQ With System.Linq.Dynamic.Core Library&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://dynamic-linq.net/"&gt;Dynamic LINQ&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;212: 29-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/28-null-coalescing-assoc</id>
		<title>Null-coalescing operator and associativity</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/28-null-coalescing-assoc" />
		<updated>2022-11-28T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;null-coalescing operator&lt;/code&gt; (&lt;code&gt;??&lt;/code&gt;) is right-associative, and can be chained together to check multiple values, in order, to eventually arrive at a non-null value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;The example for this situation is fairly simple - the operator &lt;code&gt;??&lt;/code&gt; can be used in a chain to check (and return) the &lt;em&gt;first non-null value&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int? GetValue(int? value1, int? value2, int? value3, int defaultValue)
{
  // chain the operator and return the first non-null value
    return value1 ?? value2 ?? value3 ?? defaultValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The values are evaluated left to right to check if they are &lt;code&gt;null&lt;/code&gt;, and the first non-null value is returned. In this example &lt;em&gt;defaultValue&lt;/em&gt; is an &lt;code&gt;int&lt;/code&gt; and as such cannot be null, so the method will always return a value.&lt;/p&gt;
&lt;p&gt;Invoking this with a variety of permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(GetValue(null, null, 0, 0));
Console.WriteLine(GetValue(null, 1, 2, 0));
Console.WriteLine(GetValue(2, 5, null, 0));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results in the following, expected output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;0
1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each each case the first non-null value is returned. If all &lt;em&gt;nullable&lt;/em&gt; values are null, then the default is returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This small, but useful piece of information for today might seem obvious, and it is once you think about it - personally I've just never encountered the technique or the need to chain together multiple null checks using the &lt;code&gt;null-coalescing&lt;/code&gt; operator. However, if I ever do, I now know that chaining is possible.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/null-coalescing-operator-null-coalescing-assignment-operator-csharp/"&gt;Null-Coalescing Operators’ Associativity&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;211: 28-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/25-preview-attribute</id>
		<title>Opting into experimental functionality</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/25-preview-attribute" />
		<updated>2022-11-25T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;RequiresPreviewFeatures&lt;/code&gt; attribute can be used to flag a specific piece of code as &lt;em&gt;experimental&lt;/em&gt; or &lt;em&gt;in preview&lt;/em&gt; - this code cannot be used unless the consumer specifically opts into &lt;em&gt;enabling preview features&lt;/em&gt;, preventing the preview, potentially unstable code, from being used unwittingly.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="preview-feature"&gt;Preview feature&lt;/h2&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;p&gt;To mark a &lt;em&gt;method&lt;/em&gt; (or class, property etc) as &lt;em&gt;in preview&lt;/em&gt;, it is decorated with the &lt;code&gt;RequiresPreviewFeatures&lt;/code&gt; attribute. Here the &lt;em&gt;DoWorkNew&lt;/em&gt; method is flagged as &lt;em&gt;in preview&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Worker
{
    public void DoWork()
    {
        // do some work the old way
    }

    [RequiresPreviewFeatures()]
    public void DoWorkNew() 
    { 
        // do some work the new one
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it stands, trying to use this method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var worker = new Worker();

worker.DoWorkNew();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will result in the following compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using 'DoWorkNew' requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To to able to use code marked with the attribute, one specifically needs to opt into &lt;em&gt;preview features&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="project"&gt;Project&lt;/h3&gt;
&lt;p&gt;To opt into &lt;em&gt;preview features&lt;/em&gt;, in the &lt;em&gt;csproj&lt;/em&gt; file ensure the &lt;code&gt;EnablePreviewFeatures&lt;/code&gt; setting is set to true:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net7.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;EnablePreviewFeatures&amp;gt;true&amp;lt;/EnablePreviewFeatures&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this the code will now compile successfully and be able to leverage preview/experimental features.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As a library author this is a very useful tool - allowing new experimental functionality to be introduced &amp;quot;safely&amp;quot;. Usage of the functionality is semi-controlled, and the consumers are required to make an informed choice to manually opt into using potentially unstable code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/1d97ea56-9a32-4067-9919-10b9af5623a6"&gt;Marking API's as obsolete or as experimental&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;210: 25-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/11/24-distributed-cache</id>
		<title>Distributed caching int ASP.NET Core</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/11/24-distributed-cache" />
		<updated>2022-11-24T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core comes with the &lt;code&gt;IDistributedCache&lt;/code&gt; interface, and a number of implementations to support &lt;code&gt;distributed caching&lt;/code&gt;. The out of the box implementaions include &lt;em&gt;In Memory&lt;/em&gt;, &lt;em&gt;SQL Server&lt;/em&gt;, &lt;em&gt;Redis&lt;/em&gt; and &lt;em&gt;NCache&lt;/em&gt; - however if another implementation is required, a custom provider can also be fairly easily be written.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-need-for-distributed-cache"&gt;The need for distributed cache&lt;/h2&gt;
&lt;p&gt;Before getting to &lt;em&gt;distributed cache&lt;/em&gt; we'll have a quick look at the &lt;em&gt;non-distributed in memory cache&lt;/em&gt; implementation which also comes out of the box with ASP.NET Core. Configuring and leveraging this functionality is incredibly easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// configure dependency injection with the in-memory cache
builder.Services.AddMemoryCache();

var app = builder.Build();

app.MapGet(&amp;quot;/cache&amp;quot;, (IMemoryCache cache) =&amp;gt;
{
    // try get a value with the key &amp;quot;hello&amp;quot; out the cache
    if(cache.TryGetValue(&amp;quot;hello&amp;quot;, out string result))
    {
        Console.WriteLine(&amp;quot;Retrieved from cache&amp;quot;);

        return result;
    }

    // if the value was not found in the cache
    // add it to the cache
    cache.Set(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);

    return &amp;quot;world&amp;quot;;
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;em&gt;IMemoryCache TryGetValue&lt;/em&gt; method is called to get get a value out of the cache by key. If no value is found, then the item is put into the cache and returned. This is a very simple example, with no cache expiry specified.&lt;/p&gt;
&lt;p&gt;The in-memory cache will be entirely suitable if &lt;code&gt;only one instance of an application is running&lt;/code&gt; - the cache is stored in the memory of that one instance of the application. However, if multiple instance of the application are running (in the cloud, or in containers) the &lt;em&gt;in-memory cache is not shared across instances&lt;/em&gt; - each instance will have its own cached. This is where a &lt;code&gt;distributed cache&lt;/code&gt; can be leveraged, with each application instance sharing the cache, and benefiting from the caching done by other instances.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="distributed-cache"&gt;Distributed cache&lt;/h2&gt;
&lt;p&gt;Configuring and using a &lt;code&gt;distributed cache&lt;/code&gt; in ASP.NET Core is &lt;em&gt;almost&lt;/em&gt; as easy as configuring a normal in-memory cache.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// configure in-memory distributed cache
// which is good for testing, but is not truly 
// distributed
builder.Services.AddDistributedMemoryCache();

var app = builder.Build();

// inject IDistributedCache and not IMemoryCache
app.MapGet(&amp;quot;/distributedcache&amp;quot;, async (IDistributedCache cache) =&amp;gt;
{
    string result;

    // (Try) get the byte array value from the cache
    byte[] encodedResult = await cache.GetAsync(&amp;quot;hello&amp;quot;);
    // if a value was returned
    if(encodedResult != null)
    {
        Console.WriteLine(&amp;quot;Retrieved from cache&amp;quot;);

        // convert byte array to string and return
        result = Encoding.UTF8.GetString(encodedResult);
        return result;
    }

    // convert string to byte array 
    encodedResult = Encoding.UTF8.GetBytes(&amp;quot;world&amp;quot;);
    // and configure the cache options
    DistributedCacheEntryOptions options = new DistributedCacheEntryOptions()
        .SetSlidingExpiration(TimeSpan.FromSeconds(10));

    // add the value to the cache
    await cache.SetAsync(&amp;quot;hello&amp;quot;, encodedResult, options);

    return &amp;quot;world&amp;quot;;

});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;While &lt;code&gt;IMemoryCache&lt;/code&gt; can store a &lt;em&gt;string&lt;/em&gt; or &lt;em&gt;object&lt;/em&gt;, &lt;code&gt;IDistributedCache&lt;/code&gt; will only store a &lt;em&gt;byte array&lt;/em&gt;. Additional processing has to be done to convert to and from a byte array when inserting and retrieving values from the cache.
The &lt;code&gt;IDistributedCache&lt;/code&gt; also doesn't have a &lt;em&gt;TryGet&lt;/em&gt; method, only a &lt;em&gt;Get&lt;/em&gt; method, which will return &lt;code&gt;null&lt;/code&gt; if no value for the supplied key is found.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="configuration"&gt;Configuration&lt;/h3&gt;
&lt;p&gt;The configuration of the &lt;code&gt;in-memory distributed cache&lt;/code&gt; cache was simple (as seen above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDistributedMemoryCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the configuration of the other implementations is not much more complicated. The SQL Server provider for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDistributedSqlServerCache(act =&amp;gt;
{
   act.SchemaName = &amp;quot;dbo&amp;quot;;
   act.TableName = &amp;quot;AppCache&amp;quot;;
   act.ConnectionString = builder.Configuration.GetConnectionString(&amp;quot;DefaultDatabase&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The actual logic (the endpoint delegate method in the above example) can remain exactly as is.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having a distributed cache is a key feature in many scalable applications, and the easy to configure and use, out of the box functionality provided by ASP.NET Core will be suitable for most application's needs.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mitchelsellers.com/blog/article/understanding-implementing-caching-in-asp-net-core"&gt;Understanding &amp;amp; Implementing Caching in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;209: 24-11-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>