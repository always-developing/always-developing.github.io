<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-10-24T05:15:48Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/24-data-protection</id>
		<title>Protecting sensitive data with data protection api</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/24-data-protection" />
		<updated>2022-10-24T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET has built in methods to &lt;code&gt;protect and unprotected&lt;/code&gt; sensitive data.&lt;/p&gt;
&lt;p&gt;These methods are typically used to protect sensitive data, but could be used to protect any data. It could also be used to expose information for a &lt;em&gt;given period of time&lt;/em&gt; only, after which trying unprotecting the data will not work.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="configuration"&gt;Configuration&lt;/h2&gt;
&lt;p&gt;There are effectively three steps to using the data protection apis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create the &lt;code&gt;protector&lt;/code&gt; from a data protection provider&lt;/li&gt;
&lt;li&gt;Invoke the &lt;code&gt;Protect&lt;/code&gt; method to protect the data specified&lt;/li&gt;
&lt;li&gt;Invoke the &lt;code&gt;Unprotect&lt;/code&gt; method to convert the specified protected value to plain text&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the startup of the application, the protector is configured as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// register base data protection
// with DI container
builder.Services
    .AddDataProtection()
    .SetDefaultKeyLifetime(TimeSpan.FromDays(7));

// register the protector with DI
builder.Services
    .AddTransient&amp;lt;ITimeLimitedDataProtector&amp;gt;(sp =&amp;gt;
    {
        // specify where the provider key information will be stored
        IDataProtectionProvider? provider = DataProtectionProvider
            .Create(new DirectoryInfo(&amp;#64;&amp;quot;secrets&amp;quot;));

        // specify the purpose string for the creator
        IDataProtector? protector = provider
            .CreateProtector(&amp;quot;customerdata&amp;quot;);

        return protector.ToTimeLimitedDataProtector();
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some notes on the above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The key information is stored in a &lt;code&gt;secrets&lt;/code&gt; folder on the host machine. As such, the key information is only available to that one machine. If multiple machines need to access the key information, there are other storage providers available (Azure KeyVault, DbContext)&lt;/li&gt;
&lt;li&gt;The protector is created with a specific &lt;em&gt;purpose&lt;/em&gt;, &lt;code&gt;customerdata&lt;/code&gt; above. A value protected using a specific purpose, cannot be unprotected using a different purpose value.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="protect"&gt;Protect&lt;/h2&gt;
&lt;p&gt;To &lt;em&gt;protect&lt;/em&gt; a string, the &lt;code&gt;Protect&lt;/code&gt; method is called. Below, an endpoint has been defined which has the &lt;em&gt;ITimeLimitedDataProtector&lt;/em&gt; protector implementation (configured in the previous step) injected:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the value to protect from the route
app.MapGet(&amp;quot;/protect/{protectValue}&amp;quot;, (
    [FromRoute]string protectValue, 
    ITimeLimitedDataProtector protector) =&amp;gt;
{
    // return the protected value
    return protector.Protect(protectValue);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the endpoint &lt;code&gt;/protect/abc123&lt;/code&gt; results in the following protected value being returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;CfDJ8BdtcMmju6ZKiKJtRHvTt2BidaZbPEirTP_KEi4-_2xVBYbs58hqVxWGQmTQBjQaO_tXTiFRAxGUPGSqXkvlfIzhd80r3AavXi0m3PiCXYfuaRhmnrzCXk6apOIqXOCvHA
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="unprotect"&gt;Unprotect&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Unprotecting&lt;/em&gt; is as simple as protecting a value - the &lt;code&gt;Unprotect&lt;/code&gt; method is called, with the previously protected value supplied:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/unprotect/{unprotectValue}&amp;quot;, (
    [FromRoute] string unprotectValue, 
    ITimeLimitedDataProtector protector) =&amp;gt;
{
    return protector.Unprotect(unprotectValue);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the endpoint &lt;code&gt;/unprotect/CfDJ8BdtcMmju6ZKiKJtRHvTt2BidaZbPEirTP_KEi4-_2xVBYbs58hqVxWGQmTQBjQaO_tXTiFRAxGUPGSqXkvlfIzhd80r3AavXi0m3PiCXYfuaRhmnrzCXk6apOIqXOCvHA&lt;/code&gt; results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;abc123
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When needing to protect sensitive data (for example, &lt;em&gt;authentication cookie&lt;/em&gt; or &lt;em&gt;bearer token&lt;/em&gt;) this set of classes and functionality provides an easy, simple and effective way to protect the data.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/ppenza/status/1573676247812653058"&gt;Piotr Penza&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction?view=aspnetcore-6.0"&gt;ASP.NET Core Data Protection Overview&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/configuration/overview?view=aspnetcore-6.0"&gt;Configure ASP.NET Core Data Protection&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;188: 24-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/21-math-update</id>
		<title>Using math functions on numeric types</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/21-math-update" />
		<updated>2022-10-21T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduces the ability to &lt;code&gt;call math methods on numeric types&lt;/code&gt; and not have to use the static &lt;em&gt;Math&lt;/em&gt; class.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre.net-7"&gt;Pre .NET 7&lt;/h2&gt;
&lt;p&gt;Prior to .NET 7, the static &lt;code&gt;Math&lt;/code&gt; class was used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;double value = 100.33;

// get the absolute value
double mathAbs = Math.Abs(value);

// get the cube root
double mathCbrt = Math.Cbrt(125);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="net-7"&gt;.NET 7&lt;/h2&gt;
&lt;p&gt;In .NET 7, these methods are now available on the numeric type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;double value = 100.33;

double doubleAbs = double.Abs(value);
double doubleCbrt = double.Cbrt(125);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Under the hood, these methods are still using the &lt;code&gt;Math&lt;/code&gt; static class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// source code for the double Abs method
public static double Abs(double value) =&amp;gt; Math.Abs(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The two techniques effectively use the same code, and perform the same operation - so which one to use comes down to preference and readability. Personally, I find using the numeric types is more informative, because at a glance one can see the return type of the calculation (the &lt;em&gt;Abs&lt;/em&gt; method on &lt;em&gt;double&lt;/em&gt;, will return a &lt;em&gt;double&lt;/em&gt;) - but this will not be the preference for everyone.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/fonssonnemans/status/1573274358910525442"&gt;Fons Sonnemans Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;187: 21-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/20-http-headers</id>
		<title>Built in HTTP header properties</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/20-http-headers" />
		<updated>2022-10-20T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core has &lt;code&gt;built in properties for common HTTP headers&lt;/code&gt;, which are &lt;em&gt;faster and better&lt;/em&gt; than using an indexer manually.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="manual-indexers"&gt;Manual indexers&lt;/h2&gt;
&lt;p&gt;In this example, the &lt;em&gt;ContextType&lt;/em&gt;, &lt;em&gt;Date&lt;/em&gt; and &lt;em&gt;Link&lt;/em&gt; headers are manually set using indexers on the endpoint response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/getheadersmanual", async context =&amp;gt;
{
    context.Response.Headers.ContentType = MediaTypeNames.Application.Json;
    context.Response.Headers.Date = DateTime.UtcNow.ToString();
    context.Response.Headers.Link = "/getheadersmanual";

    await context.Response.WriteAsync(@"{""Message"" : ""Look at the headers""}");
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works without issue, and calling the endpoint will result in the following response and headers:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;{"Message" : "Look at the headers"}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/manualheaders.png" alt="Response Headers"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="built-in-properties"&gt;Built-in properties&lt;/h2&gt;
&lt;p&gt;The other option is to use the built-in header properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/getheaders", async context =&amp;gt;
{
    context.Response.Headers.ContentType = MediaTypeNames.Application.Json;
    context.Response.Headers.Date = DateTime.UtcNow.ToString();
    context.Response.Headers.Link = "/getheaders";

    await context.Response.WriteAsync(@"{""Message"" : ""Look at the headers""}");
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This version will same response and headers as the above technique:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;{"Message" : "Look at the headers"}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/autoheaders.png" alt="Response Headers"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the output from both techniques are effectively the same - in addition to the property method being faster than using indexers (although probably not effectively noticeable), using the property method will results in less errors and safer code, as the HTTP header name cannot be misspelt.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/JamesNK/status/1572876608553517056"&gt;James Newton-King Tweet&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;186: 20-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/19-query-array</id>
		<title>Binding query string values to an array</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/19-query-array" />
		<updated>2022-10-19T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduces the ability to automatically &lt;code&gt;bind a query string value to an array&lt;/code&gt; (or &lt;em&gt;StringValues&lt;/em&gt; class).&lt;/p&gt;
&lt;p&gt;When the query string value is of variable length and can contain one or more different items - this automatic binding can save time and facilitates cleaner code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre.net7"&gt;Pre .NET7&lt;/h2&gt;
&lt;p&gt;Prior to .NET 7, a query string parameter with multiple values would manually need to be converted to an array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getsongs&amp;quot;, async ([FromQuery] string artists) =&amp;gt;
{
    async IAsyncEnumerable&amp;lt;string&amp;gt; GetSongs(string[] artists)
    {
        foreach (var name in artists)
        {
            /// simulate looking up all the 
            // songs for the artist
            yield return $&amp;quot;Retrieving songs for '{name}'&amp;quot;;
        }
    }

    // the artist parameter value would be
    // comma separated of all the values supplied
    return GetSongs(artists.Split(&amp;quot;,&amp;quot;));
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the endpoint with &lt;code&gt;/getsongs?artists=foofighters&amp;amp;artists=johnmayer&lt;/code&gt;, will result in the &lt;em&gt;artists&lt;/em&gt; parameter having a value of &lt;code&gt;foofighters,johnmayer&lt;/code&gt; (all values supplied in a comma separated string). The return value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[&amp;quot;Retrieving songs for 'foofighters'&amp;quot;,&amp;quot;Retrieving songs for 'johnmayer'&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="net7"&gt;.NET7&lt;/h2&gt;
&lt;h3 id="array-binding"&gt;Array binding&lt;/h3&gt;
&lt;p&gt;Leveraging this new array binding functionality is very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Automatically bind the query string value &amp;quot;artists&amp;quot; to the 
// endpoint array parameter &amp;quot;artists&amp;quot;
app.MapGet(&amp;quot;/getsongs&amp;quot;, async ([FromQuery] string[] artists) =&amp;gt;
{
    // create a local function to be able to yield return
    // from the endpoint
    async IAsyncEnumerable&amp;lt;string&amp;gt; GetSongs(string[] artists)
    {
        foreach (var name in artists)
        {
            /// simulate looking up all the 
            // songs for the artist
            yield return $&amp;quot;Retrieving songs for '{name}'&amp;quot;;
        }
    }

    // no conversion required
    return GetSongs(artists);

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the endpoint with a single value, by browsing to the endpoint &lt;code&gt;/getsongs?artists=foofighters&lt;/code&gt;, gives the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[&amp;quot;Retrieving songs for 'foofighters'&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While calling the endpoint with multiple values, &lt;code&gt;/getsongs?artists=foofighters&amp;amp;artists=johnmayer&lt;/code&gt;, results in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[&amp;quot;Retrieving songs for 'foofighters'&amp;quot;,&amp;quot;Retrieving songs for 'johnmayer'&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="stringvalues-binding"&gt;StringValues binding&lt;/h3&gt;
&lt;p&gt;The query string parameter can also be bound to a &lt;code&gt;StringValues&lt;/code&gt; instance if required. This operates the same as the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Automatically bind the query string value &amp;quot;artists&amp;quot; to the 
// endpoint StringValues parameter &amp;quot;artists&amp;quot;
app.MapGet(&amp;quot;/getsongs&amp;quot;, async ([FromQuery] StringValues[] artists) =&amp;gt;
{
    // create a local function to be able to yield return
    // from the endpoint
    async IAsyncEnumerable&amp;lt;string&amp;gt; GetSongs(StringValues artists)
    {
        foreach (var name in artists)
        {
            /// simulate looking up all the 
            // songs for the artist
            yield return $&amp;quot;Retrieving songs for '{name}'&amp;quot;;
        }
    }

    return GetSongs(artists);

});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This approach is significantly simpler and cleaner than having to split the query string into an array manually. While this enhancement will not drastically change the performance of an application or add significant new functionality, it does facilitate cleaner, more readable code, which day to day, is probably more important for the vast majority of application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dev.to/bytehide/net-7-microsoft-reveals-new-aspnet-core-features-24f3"&gt;.NET 7: Microsoft Reveals New ASP.NET Core Features&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;185: 19-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/18-utf8jsonreader</id>
		<title>Performant deserialization with Utf8JsonReader</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/18-utf8jsonreader" />
		<updated>2022-10-18T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When deserializing a string to a class, if only limited fields on the entity are required or used after the deserialization process, then it might be faster and more performant to use the &lt;code&gt;Utf8JsonReader&lt;/code&gt; class read te values.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Utf8JsonReader&lt;/code&gt; is a &lt;em&gt;high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="serialization"&gt;Serialization&lt;/h2&gt;
&lt;p&gt;First, let's set the stage and get a serialized JSON string. In the examples a &lt;code&gt;Song&lt;/code&gt; class will be used for &lt;em&gt;serialization&lt;/em&gt; and &lt;em&gt;deserialization&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public int Id { get; set; }

    public string Name { get; set; }

    public string Artist { get; set; }

    public int YearReleased { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To serialize a &lt;em&gt;Song&lt;/em&gt; instance, &lt;code&gt;System.Text.Json.JsonSerializer&lt;/code&gt; is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Id = 1,
    Name = &amp;quot;Everlong&amp;quot;,
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    YearReleased = 1997,
    DateCreated = DateTime.Now
};

var jsonSong = JsonSerializer.Serialize(song);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now have a &lt;em&gt;json string representation&lt;/em&gt; of the a Song instance to be used in the below deserialization examples.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="deserialization"&gt;Deserialization&lt;/h2&gt;
&lt;p&gt;In the use cases below, a JSON string is sent to the application (maybe via an API call, or a message broker) but the application is only interested in the &lt;code&gt;Name&lt;/code&gt; field in the serialized &lt;em&gt;Song&lt;/em&gt; instance. We are going to look at the various ways to deserialize the data to get access to that specific field.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="system.text.json"&gt;System.Text.Json&lt;/h3&gt;
&lt;p&gt;The first method is to deserialize the entire string into the class, and then access the field - this is usually the &lt;em&gt;default&lt;/em&gt; method most developers might use:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var options = new JsonSerializerOptions
{
    AllowTrailingCommas = true
};

var song = JsonSerializer.Deserialize&amp;lt;Song&amp;gt;(strSong, options);
var name = song.Name;

Console.WriteLine(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, is straight forward - but requires that all fields be deserialized (impacting performance), when only one field is required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="system.text.json-trimmed"&gt;System.Text.Json trimmed&lt;/h3&gt;
&lt;p&gt;Another method is to create a new &lt;em&gt;Song&lt;/em&gt; class, which only contains the interested fields, and deserialize to that class.&lt;/p&gt;
&lt;p&gt;First, and &lt;em&gt;TrimmedSong&lt;/em&gt; class is created, trimmed of all the fields not required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class TrimmedSong
{
    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The deserialization process is exactly the same as the previous method, only the new &lt;em&gt;TrimmedSong&lt;/em&gt; class is used instead of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var options = new JsonSerializerOptions
{
    AllowTrailingCommas = true
};

// TrimmedSong used here
var song = JsonSerializer.Deserialize&amp;lt;TrimmedSong&amp;gt;(strSong, options);
var name = song.Name;

Console.WriteLine(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The benefit of this approach is that only the required fields are deserialized, using less memory for fields which are never used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="utf8jsonreader"&gt;Utf8JsonReader&lt;/h3&gt;
&lt;p&gt;The final option we'll look is using the &lt;code&gt;Utf8JsonReader&lt;/code&gt; class - as mentioned, this is a high-performance, low allocation, forward-only reader.&lt;/p&gt;
&lt;p&gt;Using this is a little more complex than a straight deserialization, but not overly so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// convert the json string, to a byte array
var jsonBytes = Encoding.UTF8.GetBytes(jsonSong);

// setup some optional options
var options = new JsonReaderOptions
{
    AllowTrailingCommas = true,
    CommentHandling = JsonCommentHandling.Skip
};

// instantiate the reader with the byte array
// and the options
var reader = new Utf8JsonReader(jsonBytes, options);

var songName = string.Empty;

// read each token in the json from front to back
// (forward only)
while (reader.Read() &amp;amp;&amp;amp; songName == String.Empty)
{
    // switch on the token type read
    switch (reader.TokenType)
    {
        // if its a property
        case JsonTokenType.PropertyName:
            {
                // if its the property we care about
                // (which is the song name)
                if (reader.GetString() == nameof(Song.Name))
                {
                    // get the next token, which is the 
                    // property value
                    reader.Read();
                    // get the token value
                    songName = reader.GetString();
                }
                break;
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reader will read each token in the json start to finish, while there are tokens to read. During this process, the token type (&lt;em&gt;PropertyName&lt;/em&gt;) is checked and the token string value (&lt;em&gt;Name&lt;/em&gt;) is checked until the required property is reached - the value of the property is then read, and the read loop is exited.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;So, how do the methods compare - &lt;code&gt;BenchmarkDotNet&lt;/code&gt; was used to benchmark each of the above three scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deserialization using &lt;code&gt;System.Text.Json&lt;/code&gt; into a full class&lt;/li&gt;
&lt;li&gt;Deserialization using &lt;code&gt;System.Text.Json&lt;/code&gt; into a class with only the require fields&lt;/li&gt;
&lt;li&gt;Reading the json byte array using &lt;code&gt;Utf8JsonReader&lt;/code&gt; until the required field is found&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the same snippets of code as above, to get the &lt;em&gt;Song Name&lt;/em&gt; from the json string - the results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FullJson&lt;/td&gt;
&lt;td style="text-align: right;"&gt;517,707.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8,451.42 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7,905.46 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.9297&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.9766&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20471 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TrimmedJson&lt;/td&gt;
&lt;td style="text-align: right;"&gt;149,723.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,904.13 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,982.33 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.290&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.2207&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4883&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8787 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.429&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JsonReader&lt;/td&gt;
&lt;td style="text-align: right;"&gt;188.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.28 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.07 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0165&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;104 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.005&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results one can see that the &lt;code&gt;Utf8JsonReader&lt;/code&gt; is orders of magnitude quicker than the &lt;code&gt;System.Text.Json&lt;/code&gt; method, while using a fraction of the memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the entire JSON string is not required to be deserialized, consider using &lt;code&gt;Utf8JsonReader&lt;/code&gt;. Benchmark its performance against &lt;code&gt;System.Text.Json&lt;/code&gt; (or _NewtonSoft.Json, or which ever deserialization library is being used) to determine which is more beneficial for the specific use case, as potentially massive performance gains can be had.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-use-dom-utf8jsonreader-utf8jsonwriter?pivots=dotnet-6-0#use-utf8jsonreader"&gt;Use Utf8JsonReader&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;184: 18-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/17-cache-stats</id>
		<title>Access cache stats with MemoryCacheStatistics</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/17-cache-stats" />
		<updated>2022-10-17T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with .NET 7, the &lt;code&gt;MemoryCacheStatistics&lt;/code&gt; class, accessed through &lt;code&gt;IMemoryCache.GetCurrentStatistics&lt;/code&gt; can provider useful statistics regarding the state of the memory cache. These include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how many items are currently in the cache&lt;/li&gt;
&lt;li&gt;the current estimate size of the cache&lt;/li&gt;
&lt;li&gt;the number of times the cache has been queried for a value, and the value was not present (misses)&lt;/li&gt;
&lt;li&gt;the number of times the cache has been queried for a value, and the value was present (hits)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These stats can be leveraged to better understand how/if the cache mechanism is correctly configured and being used optimally.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="cache-configuration"&gt;Cache configuration&lt;/h2&gt;
&lt;p&gt;The first step is to register the require cache implementation instances with the dependency injection container. This is done using the &lt;em&gt;AddMemoryCache&lt;/em&gt; extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services
    .AddMemoryCache(memCacheOptions =&amp;gt; 
        { 
            memCacheOptions.TrackStatistics = true; 
            memCacheOptions.SizeLimit = 1024; 
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;For stats to be tracked, the &lt;code&gt;MemoryCacheOptions.TrackStatistics&lt;/code&gt; value (&lt;em&gt;memCacheOptions.TrackStatistics&lt;/em&gt; in the above example) needs to be set to &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For the &lt;code&gt;EstimateSize&lt;/code&gt; property of the statistics to be tracked, the cache needs to have a &lt;em&gt;SizeLimit&lt;/em&gt; specified. The &lt;em&gt;SizeLimit&lt;/em&gt; does not represent memory size, but &lt;em&gt;number of units&lt;/em&gt; - in the above example, the limit has been set to &lt;em&gt;1024 units&lt;/em&gt;, and when items are added to the cache &lt;em&gt;one byte will be treated as a unit&lt;/em&gt; (this is not a required, its up to the developer to decide how many &amp;quot;units&amp;quot; each item added to the cache is worth)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="cache-usage"&gt;Cache usage&lt;/h2&gt;
&lt;h3 id="set-values"&gt;Set values&lt;/h3&gt;
&lt;p&gt;Now that the cache is configured, the next step is to start using it to store values. A simple &lt;code&gt;getnumber&lt;/code&gt; endpoint is defined, which will &lt;em&gt;return the number passed in&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if the number does not exist in the cache, it will be added to the cache and returned&lt;/li&gt;
&lt;li&gt;if the number already exists in the cache, it will be returned from the cache&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the number from the route
// get the IMemoryCache from the DI container
app.MapGet(&amp;quot;/getnumber/{number}&amp;quot;, ([FromRoute]int number, 
    [FromServices] IMemoryCache cache) =&amp;gt;
{
    // first check the cache to see if the number
    // exists there
    if(cache.TryGetValue(number, out var value))
    {
        return $&amp;quot;'{value}' retrieved from cache&amp;quot;;
    }

    // if it didn't exist, add it to the cache
    cache.Set(number, number, new MemoryCacheEntryOptions { Size = sizeof(int)});

    // return
    return $&amp;quot;'{number}' added to cache&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the endpoint with a number for the first time &lt;code&gt;/getnumber/1&lt;/code&gt;, will result in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'1' added to cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While invoking subsequent times with the same number will result in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'1' retrieved from cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The cache has been configured and the &lt;em&gt;endpoint called a number of times, with unique and duplicate numbers&lt;/em&gt;, so next let's have a look at the stats.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="get-statistics"&gt;Get statistics&lt;/h3&gt;
&lt;p&gt;To get a &lt;em&gt;snapshot of the IMemoryCache statistics&lt;/em&gt;, the &lt;code&gt;GetCurrentStatistics&lt;/code&gt; method is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getstats&amp;quot;, ([FromServices] IMemoryCache cache) =&amp;gt;
{
    return cache.GetCurrentStatistics();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sample return snapshot:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;currentEntryCount&amp;quot;:6,
    &amp;quot;currentEstimatedSize&amp;quot;:24,
    &amp;quot;totalMisses&amp;quot;:6,
    &amp;quot;totalHits&amp;quot;:2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;6 items have been added&lt;/code&gt; to the cache&lt;/li&gt;
&lt;li&gt;the 6 items take up &lt;code&gt;24 of the available 1024 units&lt;/code&gt; available (6 x 4 bytes)&lt;/li&gt;
&lt;li&gt;the cache has been checked and did &lt;code&gt;not contain the queried value 6 times&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the cache has been checked and &lt;code&gt;did contain the queried value twice&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This information is very valuable and can be leveraged to confirm if the cache configured for an application is successfully being used - over time, one would want to see a high number of hits and relatively low number of misses. This information can be used to determine if the cache strategy needs to be modified (cache based on a different key) or maybe increase or decrease the cache size.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache.getcurrentstatistics?view=dotnet-plat-ext-7.0"&gt;IMemoryCache.GetCurrentStatistics Method&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;183: 17-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/14-newtonsoft-jsonconverter</id>
		<title>Deserializing incompatible types using JsonConverter</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/14-newtonsoft-jsonconverter" />
		<updated>2022-10-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;Newtonsoft.Json&lt;/code&gt; to perform deserialization, the &lt;code&gt;JsonConverter&lt;/code&gt; class can be used to customize how the data of a specific type is deserialized - this allows to perform custom logic, allowing seemingly incompatible types to be &lt;em&gt;&amp;quot;compatible&amp;quot;&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="real-world-scenario"&gt;Real world scenario&lt;/h2&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;
&lt;p&gt;In this use case, &lt;code&gt;Newtonsoft.Json&lt;/code&gt; is being used to serialize a simplified &lt;em&gt;source entity&lt;/em&gt; which looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SourceEntity
{
    public int Id { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The json string is then being deserialized into a separate &lt;em&gt;destination entity&lt;/em&gt; which looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DestinationEntity
{
    public int Id { get; set; }

    public DateTimeOffset DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;DateCreated&lt;/em&gt; property is defined as &lt;code&gt;DateTime&lt;/code&gt; in the source and &lt;code&gt;DateTimeOffset&lt;/code&gt; in the destination - &lt;code&gt;aren't those two types compatible&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Generally yes, those two types are compatible and the deserialization/serialization will occur without issue - that is unless the &lt;code&gt;SourceEntity DateCreated field contains DateTime.MinValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sourceDate = new SourceEntity
{
    Id = 100,
    // set to minimum value possible
    DateCreated = DateTime.MinValue
};

// serialize the source entity with a DateCreated value
// of DateTime.MinValue
string jsonEntity = 
    Newtonsoft.Json.JsonConvert.SerializeObject(sourceDate);

// this will cause an exception to occur
DestinationEntity destinationDate = Newtonsoft.Json.JsonConvert
    .DeserializeObject&amp;lt;DestinationEntity&amp;gt;(jsonEntity);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this happens, then the deserialization fails with the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;An unhandled exception of type 'Newtonsoft.Json.JsonReaderException' occurred in Newtonsoft.Json.dll
Could not convert string to DateTimeOffset: 0001-01-01T00:00:00. Path 'DateCreated', line 1, position 45.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To solve this issue, a custom &lt;code&gt;JsonConvert&lt;/code&gt; implementation can be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="jsonconvert"&gt;JsonConvert&lt;/h3&gt;
&lt;p&gt;To implement a custom converter one needs to inherit from the  the &lt;em&gt;abstract&lt;/em&gt; &lt;code&gt;JsonConverter&lt;/code&gt; class. There are a number of methods to override and implement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DateTimeConverter : JsonConverter
{
    public override bool CanRead =&amp;gt; true;
    public override bool CanWrite =&amp;gt; false;

    // this converter should only apply when the 
    // destination type being converted is a
    // datetimeoffset    
    public override bool CanConvert(Type objectType) 
        =&amp;gt; objectType == typeof(DateTimeOffset);

    // method is called when reading the json
    // this method is only called when the destination 
    // type is DateTimeOffset (as defined by the 
    // CanConvert method)
    public override object ReadJson(JsonReader reader, 
        Type objectType, object existingValue, 
        JsonSerializer serializer)
    {
        // try convert the value to a datetime offset
        if (DateTimeOffset.TryParse(reader.Value.ToString(), 
            out DateTimeOffset result))
        {
            // if it was converted successfully
            return result;
        }

        // return min value if it cannot
        return DateTimeOffset.MinValue;
    }

    // converter should not be used on serialization
    // so don't need to implement this method
    public override void WriteJson(JsonWriter writer, 
        object value, JsonSerializer serializer)
    {
        throw new NotImplementedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="deserialization"&gt;Deserialization&lt;/h3&gt;
&lt;p&gt;When deserializing, none or many converters can be passed into the &lt;em&gt;DeserializeObject&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sourceDate = new SourceEntity
{
    Id = 100,
    DateCreated = DateTime.MinValue
};

string jsonEntity = 
    Newtonsoft.Json.JsonConvert.SerializeObject(sourceDate);

// pass in the DateTimeConverter when deserializing
DestinationEntity destinationDate = Newtonsoft.Json.JsonConvert
        .DeserializeObject&amp;lt;DestinationEntity&amp;gt;(jsonEntity, new DateTimeConverter());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the additional of &lt;code&gt;DateTimeConverter&lt;/code&gt;, the conversion is now performed without any issue.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While Newtonsoft.Json should, in &lt;em&gt;most&lt;/em&gt; cases, be replaced with &lt;code&gt;System.Text.Json&lt;/code&gt; due to its performance improvements, Newtonsoft.Json still gets &lt;em&gt;a lot&lt;/em&gt; of usage due to the depth of functionality and flexibility it offers (although in this specific use case, System.Text.Json does offer the ability to implement custom converters as well).
It is beneficial to be aware of Newtonsoft.Json and how it can be leveraged when System.Text.Json doesn't provide the required functionality.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;182: 14-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/13-objectpool</id>
		<title>ObjectPool for resource management</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/13-objectpool" />
		<updated>2022-10-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Th &lt;code&gt;ObjectPool&lt;/code&gt; class can be leveraged to keep a &lt;em&gt;group of objects in memory for reuse&lt;/em&gt; rather than allowing the objects to be garbage collected and having to be reinitialized every time required.&lt;/p&gt;
&lt;p&gt;This is especially useful if the object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is expensive to allocate/initialize.&lt;/li&gt;
&lt;li&gt;represent some limited resource.&lt;/li&gt;
&lt;li&gt;is used predictably and frequently.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Usage of the &lt;code&gt;ObjectPool&lt;/code&gt; consists of a few steps:&lt;/p&gt;
&lt;h3 id="objectpoolprovider"&gt;ObjectPoolProvider&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ObjectPoolProvider&lt;/code&gt; is used to ultimately &lt;em&gt;create the ObjectPool&lt;/em&gt; based on a &lt;em&gt;policy&lt;/em&gt;. The below code snippet uses the &lt;code&gt;DefaultObjectPoolProvider&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The dependency injection container is configured as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.TryAddSingleton&amp;lt;ObjectPoolProvider, DefaultObjectPoolProvider&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the &lt;code&gt;DefaultObjectPoolProvider&lt;/code&gt; is used and the item stored in the pool (&lt;em&gt;StringBuilder&lt;/em&gt; in the following examples) implements IDisposable, Then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;items that are not returned to the pool will be disposed&lt;/li&gt;
&lt;li&gt;when the pool gets disposed by the dependency injection container, all items in the pool are disposed&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="objectpool"&gt;ObjectPool&lt;/h3&gt;
&lt;p&gt;The next step is to register the &lt;code&gt;ObjectPool&lt;/code&gt; itself with the dependency injection container, in this case using an implementation factory:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.TryAddSingleton&amp;lt;ObjectPool&amp;lt;StringBuilder&amp;gt;&amp;gt;(serviceProvider =&amp;gt;
{
    // get the provider registered in the previous step
    var provider = serviceProvider.GetRequiredService&amp;lt;ObjectPoolProvider&amp;gt;();
    // create a policy, using the built in string builder policy
    var policy = new StringBuilderPooledObjectPolicy();
    // return an ObjectPool&amp;lt;StringBuilder&amp;gt; instance created using the policy
    return provider.Create(policy);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="injection"&gt;Injection&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ObjectPool&amp;lt;StringBuilder&amp;gt;&lt;/code&gt; can now be injected into the relevent method/delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/buildstring&amp;quot;, (ObjectPool&amp;lt;StringBuilder&amp;gt; pool) =&amp;gt;
{
    // get a StringBuilder instance from the pool
    var sBuilder = pool.Get();

    try
    {
        // use the string builder
        sBuilder.Append(&amp;quot;This string has been built up using &amp;quot;);
        sBuilder.Append(&amp;quot;a StringBuilder instance from an &amp;quot;);
        sBuilder.Append(&amp;quot;ObjectPool&amp;lt;StringBuilder&amp;gt; instance&amp;quot;);

        return sBuilder.ToString();
    }
    finally
    {
        // return it to the pool
        pool.Return(sBuilder);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Get&lt;/code&gt; method on &lt;code&gt;ObjectPool&lt;/code&gt; is used to get an instance of the class from the pool (&lt;em&gt;StringBuilder&lt;/em&gt; in this example)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Return&lt;/code&gt; method is used to return the instance back to the &lt;code&gt;ObjectPool&lt;/code&gt;, making it available for reused in the future&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;While using the &lt;code&gt;ObjectPool&lt;/code&gt; can definitely increase performance, it does not always guarantee it. Object pooling usually won't improve performance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unless the initialization cost of an object is high, it's usually slower to get the object from the pool.&lt;/li&gt;
&lt;li&gt;objects managed by the pool aren't de-allocated until the pool is de-allocated.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Under the right use-case object pool can definitely make a difference to the performance of an application. However, if used incorrect it can be detrimental - so if performance is a concern, benchmark and make an informed decision for the specific use case.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-6.0"&gt;Object reuse with ObjectPool in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;181: 13-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/12-list-sort-performance</id>
		<title>Primitive collection performance</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/12-list-sort-performance" />
		<updated>2022-10-12T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduces a small update when using LINQ to perform &lt;code&gt;sorting on a collection&lt;/code&gt; to slightly &lt;code&gt;simplifying the code&lt;/code&gt; - however, when working with arrays, the &lt;code&gt;Array.Sort&lt;/code&gt; method is the most performant method to use to perform the sort.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-7-updates"&gt;.NET 7 updates&lt;/h2&gt;
&lt;p&gt;Prior to .NET 7, when performing a &lt;em&gt;sort&lt;/em&gt; on a collection of items, the &lt;code&gt;OrderBy&lt;/code&gt; or &lt;code&gt;OrderByDescending&lt;/code&gt; method is generally used to sort the items (&lt;em&gt;OrderBy&lt;/em&gt; and &lt;em&gt;OrderByDescending&lt;/em&gt; are extension methods on IEnumerable):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// generate a random list of 500 entities into an item array
var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine(items[0]);
// sort the items
var sortedItems = items.OrderBy(item =&amp;gt; item).ToArray();
Console.WriteLine(sortedItems[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When working with primitives, in the &lt;em&gt;OrderBy&lt;/em&gt; method the &lt;code&gt;keySelector&lt;/code&gt; (&lt;em&gt;item&lt;/em&gt; in the above example) is required to be specified, even though there is only one selector - the item in the collection. This is versus a collection of &lt;em&gt;classes&lt;/em&gt;, where the &lt;code&gt;keySelector&lt;/code&gt; could be any property on the class.&lt;/p&gt;
&lt;p&gt;With .Net 7, the &lt;code&gt;keySelector&lt;/code&gt; is no longer required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine($&amp;quot;First item before sort: {items[0]}&amp;quot;);
// sort the items, NO SELECTOR
var newSortedItems = items.Order().ToArray();
Console.WriteLine($&amp;quot;First item after sort: {newSortedItems[0]}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same output, however &lt;code&gt;slightly more readable and concise code&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="array.sort"&gt;Array.Sort&lt;/h2&gt;
&lt;p&gt;Using the LINQ &lt;code&gt;OrderBy&lt;/code&gt; or &lt;code&gt;OrderByDescending&lt;/code&gt; methods is the default go-to when wanting to sort a collection - however there is another option when &lt;em&gt;working with arrays&lt;/em&gt; - the static &lt;code&gt;Array.Sort&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;The method usage is straight forward - it takes an array as a parameter, and will &lt;code&gt;sort the supplied array, NOT return a sorted copy&lt;/code&gt;, as with the LINQ methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var rando = new Random(1001);
var items = Enumerable.Range(1, 500).Select(i =&amp;gt; rando.Next()).ToArray();

Console.WriteLine($&amp;quot;First item before sort: {items[0]}&amp;quot;);
// Perform the sort
Array.Sort(items);
// use the SAME array
Console.WriteLine($&amp;quot;First item after sort: {items[0]}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One again, the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;First item before sort: 1447366984
First item after sort: 1250278
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Let's benchmark the three methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the pre-dotnet 7 &lt;code&gt;OrderBy&lt;/code&gt; with a &lt;code&gt;keySelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the new .NET 7 &lt;code&gt;OrderBy&lt;/code&gt; without a &lt;code&gt;keySelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.Sort&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The below was run on the same 500 item collection as shown in the above examples:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OrderBy&lt;/td&gt;
&lt;td style="text-align: right;"&gt;41.56 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.216 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.181 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.2 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Order&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.75 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.304 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.285 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.98&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.23 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ArraySort&lt;/td&gt;
&lt;td style="text-align: right;"&gt;18.10 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.180 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.168 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.13 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The new and old version of &lt;code&gt;OrderBy&lt;/code&gt; practically have the same performance, however for this use case, the &lt;code&gt;Array.Sort&lt;/code&gt; is &lt;code&gt;over 200% faster&lt;/code&gt;, and uses only &lt;code&gt;20% of the memory&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The .NET 7 LINQ &lt;em&gt;OrderBy&lt;/em&gt; enhancements definitely make the code slightly more readable and concise - however if performance is critical, consider using &lt;code&gt;AArray.Sort&lt;/code&gt; and avoiding &lt;em&gt;OrderBy&lt;/em&gt; entirely. Result may vary based on the size of the array, so as always benchmark with your specific expected workload to get a comparison and make an informed choice.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1567620600599908352"&gt;Oleg Kyrylchuk tweet&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.youtube.com/watch?v=K1Ye_QEpAq8"&gt;Stop using LINQ to order your primitive collections in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;180: 12-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/10/11-readonly-list</id>
		<title>ReadOnlyList and runtime errors</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/10/11-readonly-list" />
		<updated>2022-10-11T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with a &lt;code&gt;ReadOnlyList&lt;/code&gt;, depending on how the list is defined, it is possible to &lt;em&gt;accidentally try&lt;/em&gt; change a value in the list, with the exception only becoming apparent at runtime and not compile time.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="runtime"&gt;Runtime&lt;/h2&gt;
&lt;p&gt;Suppose we have the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; golden = new List&amp;lt;int&amp;gt; { 1, 6, 1, 8 };

// readonlyGolden is a readonly list
IList&amp;lt;int&amp;gt; readonlyGolden = golden.AsReadOnly();

// still allows for trying to change the value
readonlyGolden[1] = 7;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though &lt;em&gt;golden&lt;/em&gt; is being &lt;code&gt;converted to readonly list with the AsReadOnly method&lt;/code&gt;, as it is being cast to &lt;em&gt;IList&amp;lt;int&amp;gt;&lt;/em&gt;, the compiler does recognize &lt;em&gt;readonlyGolden&lt;/em&gt; are read only.&lt;/p&gt;
&lt;p&gt;&amp;quot;Changing&amp;quot; the value in the readonly list is &amp;quot;allowed&amp;quot; at compiled, however at runtime a &lt;code&gt;NotSupportedException&lt;/code&gt; will be thrown:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Collection is read-only.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="compile-time"&gt;Compile time&lt;/h2&gt;
&lt;p&gt;Instead, of &lt;em&gt;IList&amp;lt;int&amp;gt;&lt;/em&gt; the &lt;em&gt;golden&lt;/em&gt; variable is cast to &lt;em&gt;IReadOnlyList&amp;lt;int&amp;gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; golden = new List&amp;lt;int&amp;gt; { 1, 6, 1, 8 };

// readonlyGolden is a readonly list
IReadOnlyList&amp;lt;int&amp;gt; readonlyGolden = golden.AsReadOnly();
// OR
// IReadOnlyList&amp;lt;int&amp;gt; readonlyGolden = golden

// this will cause a compiler error
readonlyGolden[1] = 7;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the code will not compile, as the compile recognizes &lt;em&gt;readonlyGolden&lt;/em&gt; as read-only.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Property or indexer 'IReadOnlyList&amp;lt;int&amp;gt;.this[int]' cannot be assigned to -- it is read only
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The above may seem obvious - cast a list to &lt;em&gt;IList&lt;/em&gt; and it's not (necessarily) readonly, while casting it to &lt;em&gt;IReadOnlyList&lt;/em&gt; will definitely make it readonly. However, the take away is that one &lt;code&gt;cannot assume that an IList is mutable&lt;/code&gt;, just because the compiler does not stop the code from compiling - the implementation could be a &lt;em&gt;ReadOnlyList&lt;/em&gt;, which will only become apparent at runtime, with an exception.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1567562406271885313"&gt;Davide Bellone tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;179: 11-10-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>