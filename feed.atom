<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2023</rights>
	<updated>2023-02-14T03:41:36Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/02/01-daily-drop-wrap</id>
		<title>Daily Drop wrap-up</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/02/01-daily-drop-wrap" />
		<updated>2023-02-01T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;At the start of 2022 I set myself the goal of &lt;code&gt;learning one new coding related piece of knowledge a day&lt;/code&gt;. It could be anything - some.NET / C# functionality I wasn't aware of, a design practice, a cool new coding technique, or just something I find interesting. It could be something I knew at one point but had forgotten, or something completely new, which I may or may never actually use.&lt;/p&gt;
&lt;p&gt;The Daily Drop was &lt;code&gt;started in February 2022&lt;/code&gt; as a record of these pieces of knowledge - writing about and summarizing them helped re-enforce the information for myself, as well as potentially helps others learn something new as well.&lt;/p&gt;
&lt;p&gt;One year, and 246 Daily Drops later (only week days, and 2 weeks off during December) the Daily Drop goal &lt;code&gt;is completed!&lt;/code&gt;. This post serves as a &lt;em&gt;wrap-up, as well as to highlight lessons learnt during the year&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="observations"&gt;Observations&lt;/h2&gt;
&lt;h3 id="forgotten-knowledge"&gt;Forgotten knowledge&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Use the knowledge learnt - or forget it&lt;/code&gt;. There are obviously exceptions to this, but for most developers unless we actively use a technique, method, syntax often, it needs to be looked-up each time. I am no exception to this. A number of the pieces of knowledge learnt throughout the year, was knowledge I had previous learn (sometime in the past 20 years), but was not actively using, and had thus &amp;quot;forgotten&amp;quot;. Reading about it again as part of the Daily Drop exercise just refreshed them memory and reminded me that I had actually previous learnt it.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="source-of-knowledge"&gt;Source of knowledge&lt;/h3&gt;
&lt;p&gt;Finding good sources of knowledge, which offer a mix between new C# features, and leveraging existing features is tough (but doable), but key. Two of my favorite sources (which are updated in the morning and afternoon CAT respectively) are &lt;a href="https://blog.cwa.me.uk/"&gt;The Morning Brew&lt;/a&gt; and the &lt;a href="https://www.alvinashcraft.com/"&gt;The Morning Dew&lt;/a&gt;. Both of these are aggregators for various Developer news.&lt;/p&gt;
&lt;p&gt;Other sources include, but not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Twitter .NET Community&lt;/li&gt;
&lt;li&gt;Youtube: &lt;a href="https://www.youtube.com/&amp;#64;nickchapsas"&gt;Nick Chapsas&lt;/a&gt;, &lt;a href="https://www.youtube.com/&amp;#64;RawCoding"&gt;Raw Coding&lt;/a&gt;, &lt;a href="https://www.youtube.com/&amp;#64;CodingTutorialsAreGo"&gt;Coding Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github repos&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="technical-writing-is-a-skill"&gt;Technical writing is a skill&lt;/h3&gt;
&lt;p&gt;Technical writing is a skill and takes times. Writing working coding samples is relatively quick - translating that into readable, understandable but concise and interesting posts is tough, and is time consuming. I feel most of the time I got this mostly right, but not always. However, as with most skills, practice over time improved my ability to write technical specifications, and this has carried over into my professional job.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="going-forward"&gt;Going forward&lt;/h2&gt;
&lt;p&gt;Do I feel like I gained skills and knowledge from Daily Drop? Yes!
Did I, overall, enjoy doing the Daily Drop? Yes!
Am I glad the year log goal has come to an end? Yes!&lt;/p&gt;
&lt;p&gt;Writing a blog post daily is time consuming and at times was very draining. So, while the daily posts will stop, they will be replaced by less frequent but more comprehensive posts. The additional time not blogging, will be dedicated to new side projects and implementation of new ideas.&lt;/p&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/31-ef-unmapped-types</id>
		<title>EF queries on unmapped types</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/31-ef-unmapped-types" />
		<updated>2023-01-31T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework 8 is (&lt;em&gt;potentially&lt;/em&gt;) introducing new functionality allowing &lt;code&gt;raw queries to be executed on unmapped types&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At the time of this post, the functionality is only available on the &lt;a href="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8/nuget/v3/index.json"&gt;daily builds&lt;/a&gt;, and may change before the EF8 release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sqlquery-example"&gt;SqlQuery Example&lt;/h2&gt;
&lt;p&gt;Making use of the new functionality is fairly straight-forward. To use the new functionality, we need a &lt;code&gt;type&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class Blog
{
    public int Id { get; set; }

    [MaxLength(500)]
    public string Title { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;DbContext&lt;/code&gt; is also required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DemoContext() : base()
    {
    }

    public DemoContext(DbContextOptions&amp;lt;DemoContext&amp;gt; options) : base(options)
    {        
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=Demo;Integrated Security=True;TrustServerCertificate=True&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important thing to note here, is that the &lt;code&gt;Blog type is NOT mapped to a DBSet in the DBContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;With the new functionality, &lt;em&gt;raw SQL queries&lt;/em&gt; can now be executed against the &lt;code&gt;unmapped type&lt;/code&gt; (&lt;em&gt;Blog&lt;/em&gt; in this example):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

// Blog type is not mapped
var blogs = await context.Database.SqlQuery&amp;lt;Blog&amp;gt;(
        &amp;#64;$&amp;quot;SELECT b.Id, b.Title, b.DateCreated
            FROM Blog b&amp;quot;)
    .ToListAsync();

Console.WriteLine($&amp;quot;Blogs returned: {blogs.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same functionality can be leveraged for &lt;em&gt;simple types&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

var titles = await context.Database.SqlQuery&amp;lt;string&amp;gt;(
        &amp;#64;$&amp;quot;SELECT b.Title
            FROM Blog b&amp;quot;)
    .ToListAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This functionality can also be abstracted to a generic method to make calling it multiple times, for multiple entities easier:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; ExecuteSqlQuery&amp;lt;T&amp;gt;(DbContext context, string query)
{
    return await context.Database.SqlQuery&amp;lt;T&amp;gt;(
            FormattableStringFactory.Create(query)
        ).ToListAsync();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can now be called as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var results = await ExecuteSqlQuery&amp;lt;Blog&amp;gt;(context, 
    &amp;quot;SELECT b.Id, b.Title, b.DateCreated FROM Blog b&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="dynamiccontext"&gt;DynamicContext&lt;/h2&gt;
&lt;p&gt;I have previous written a &lt;a href="https://www.nuget.org/packages/AlwaysDeveloping.EntityFrameworkCore.DynamicContext"&gt;NuGet package called DynamicContext&lt;/a&gt; which effectively provides the same functionality. A detailed &lt;a href="https://www.alwaysdeveloping.net/p/11-2020-dynamic-context/"&gt;blog post is also available&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So will this new EF functionality replace &lt;code&gt;DynamicContext&lt;/code&gt;? Yes, and no.&lt;/p&gt;
&lt;p&gt;For the most part, yes it does replace &lt;code&gt;DynamicContext&lt;/code&gt;. However there is one bit of functionality available in &lt;code&gt;DynamicContext&lt;/code&gt; that is not available with the new functionality - the &lt;code&gt;ability to run queries against anonymous types&lt;/code&gt;. This is possible with &lt;code&gt;DynamicContext&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Declare an example anonymous object with 
// the relevant properties, using default values 
var anon = new { BlogId = 0, Url = &amp;quot;&amp;quot; };

// Invoke the method just using the 
// example object, and not specifying T
var blog = CallWithAnon(anon);

static T CallWithAnon&amp;lt;T&amp;gt;(T example) where T: class
{
    // T is inferred from the example parameter (which is not used in the method, 
    // it is only used for the inference) and can successfully 
    // call into the dynamic runtime context
    using var dynContext = new RuntimeContext&amp;lt;T&amp;gt;();
    return dynContext.Set&amp;lt;T&amp;gt;().FromSqlRaw(&amp;quot;SELECT Id as BlogId, Url FROM Blog&amp;quot;)
        .AsNoTracking().First();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trying the same technique with the new EF functionality results in the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;No suitable constructor was found for entity type '&amp;lt;&amp;gt;f__AnonymousType0&amp;lt;int, string&amp;gt;'. 
he following constructors had parameters that could not be bound to properties of the entity type: 
    Cannot bind 'BlogId', 'Title' in '&amp;lt;&amp;gt;f__AnonymousType0&amp;lt;int, string&amp;gt;(int BlogId, string Title)'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a fairly niche use case though, so for the majority of the time, the &lt;code&gt;new functionally can replace DynamicContext&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the ability to query unmapped entities is required - this new functionality is the way to go (vs custom libraries). I'm happy to see additional &lt;em&gt;required&lt;/em&gt; functionality such as this being introduced into the base EF libraries, removing the reliance on additional libraries.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/d1f069fb-7f6d-4f80-a98f-734755474ae1"&gt;Entity Framework 8: Raw SQL queries on unmapped types&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://twitter.com/ajcvickers/status/1616203415637618688"&gt;Arthur Vickers Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;246: 31-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/30-araypool</id>
		<title>ArrayPool for frequent array creation</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/30-araypool" />
		<updated>2023-01-30T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In situations where &lt;em&gt;arrays are created and destroyed frequently&lt;/em&gt;, using the &lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; class to &lt;em&gt;rent and return&lt;/em&gt; memory buffers, instead of initializing an array, can lead to improved performance and less pressure on the garbage collection process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="array-initialization"&gt;Array initialization&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;usual traditional&lt;/em&gt; way to instantiate an array, is to use the &lt;code&gt;new&lt;/code&gt; keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void UseInitArray(int arrayLength)
{
    ArrayItem[] array = new ArrayItem[arrayLength];

    for (int i = 0; i &amp;lt; arrayLength; i++)
    {
        array[i] = new ArrayItem
        {
            Id = i,
            Name = i.ToString()
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an array of &lt;em&gt;arrayLength&lt;/em&gt; is initialized with &lt;code&gt;ArrayItem[] array = new ArrayItem[arrayLength];&lt;/code&gt;. An &lt;em&gt;ArrayItem&lt;/em&gt; instance is then added to each element of the array.&lt;/p&gt;
&lt;p&gt;When a large number of arrays and created and destroyed frequently, the garbage collector is (comparatively) under pressure, as there are large amounts of memory allocated to the various large arrays which need to be cleaned up.&lt;/p&gt;
&lt;p&gt;This is where the &lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; class plays its part.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="arraypool"&gt;ArrayPool&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; shines because it allows already allocated space to be &lt;code&gt;rented&lt;/code&gt;, before it is returned back to the pool. This eliminates the need for new memory to be allocated, and then cleaned up by the garbage collector:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void UseArrayPool(int arrayLength)
{

    ArrayItem[] array = ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Rent(arrayLength);

    try
    {
        for (int i = 0; i &amp;lt; arrayLength; i++)
        {
            array[i] = new ArrayItem
            {
                Id = i,
                Name = i.ToString()
            };
        }
    }
    finally
    {
        ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Return(array);
    }

    // DO NOT DO THIS
    // array[0] = null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of the &lt;code&gt;new&lt;/code&gt; keyword being used to instantiate the array, a block of memory (of the appropriate size for the array we required) is &lt;code&gt;rented&lt;/code&gt; from the &lt;em&gt;ArrayPool&lt;/em&gt;, using &lt;code&gt;ArrayItem[] array = ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Rent(arrayLength);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Once the array (and the memory allocated to it) is no longer required, the memory is &lt;code&gt;returned&lt;/code&gt; to the &lt;em&gt;ArrayPool&lt;/em&gt;, allowing it to be reused in future.&lt;/p&gt;
&lt;p&gt;It is important to &lt;code&gt;not access the array&lt;/code&gt; once the memory has been returned to the pool, as this could cause instability in the application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If an application creates and destroys a large number of array's, then using the &lt;code&gt;ArrayPool&lt;/code&gt; is the way to go. It is not significantly more complicated that manually instantiating the array, and the application could gain an improvement in performance by leveraging the &lt;code&gt;ArrayPool&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/StasYakhnenko/status/1618293902670454786"&gt;Stas Yakhnenko Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;245: 30-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/27-expression-body-constructor</id>
		<title>Expression-body constructor</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/27-expression-body-constructor" />
		<updated>2023-01-27T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;An &lt;code&gt;expression&lt;/code&gt; can be used as the body of a constructor, providing a more concise (but arguably, more complex) style.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="traditional-constructor"&gt;Traditional constructor&lt;/h2&gt;
&lt;p&gt;Traditionally, the constructor for an entity would have a parameter for each property of the entity and set the property value to the parameter value (or to a default):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; set; }

    public string Name { get; set; }

    public int LengthInSeconds { get; set; }

    // set all property values based on parameters
    public Song(string artist, string name, int lengthInSeconds)
    {
        Artist = artist;
        Name = name;
        LengthInSeconds = lengthInSeconds;
    }

    // set property values based on parameters and
    // default values
    public Song(string artist, string name)
    {
        Artist = artist;
        Name = name;
        LengthInSeconds = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While there is absolutely &lt;em&gt;nothing wrong with this approach&lt;/em&gt;, it is a fair number of lines of code just to set a few properties. A more concise approach, would be to use an &lt;code&gt;expression&lt;/code&gt; for the body of the constructor.&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;h2 id="expression-bodied-constructor"&gt;Expression-bodied constructor&lt;/h2&gt;
&lt;p&gt;The constructors can be rewritten as follows, using expressions for the body of the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; set; }

    public string Name { get; set; }

    public int LengthInSeconds { get; set; }

    // set all property values based on parameters
    public Song(string artist, string name, int lengthInSeconds) =&amp;gt;
        (Artist, Name, LengthInSeconds) = (artist, name, lengthInSeconds);

    // set property values based on parameters and
    // default values
    public Song(string artist, string name) =&amp;gt;
        (Artist, Name, LengthInSeconds) = (artist, name, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a powerful feature of &lt;code&gt;Tuples&lt;/code&gt; is leveraged. A &lt;em&gt;Tuple&lt;/em&gt; created from the values passed into the constructor (or default values), is assigned to a &lt;em&gt;Tuple&lt;/em&gt; created using the properties of the class. This will essentially &lt;code&gt;assign the parameter values to the property values&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Definitely a more concise approach, although if unfamiliar with the syntax and how &lt;em&gt;Tuples&lt;/em&gt; work, can definitely be a more confusing approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If concise, lean and clean code is the goal, then &lt;code&gt;expression-body constructors&lt;/code&gt; is the way to go. As mentioned, the syntax can be more confusing when compared with the traditional approach - especially to those unfamiliar with &lt;em&gt;Tuples&lt;/em&gt; and their properties.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/mjovanovictech/status/1617071212504440832"&gt;Milan Jovanović Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;244: 27-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/26-async-constructor</id>
		<title>Calling an async method in a constructor</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/26-async-constructor" />
		<updated>2023-01-26T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;As it is &lt;em&gt;not possible to await an async method in a constructor&lt;/em&gt;, if an async method &lt;em&gt;has&lt;/em&gt; to be called, a valid technique is to &lt;code&gt;call the async method in the constructor, but defer the await until later&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-async"&gt;Non async&lt;/h2&gt;
&lt;p&gt;Calling a &lt;code&gt;non async&lt;/code&gt; method in a constructor is straight forward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
	private readonly string _specialData;

    public MyClass()
    {
    	// takes long, not ideal
    	_specialData = ExternalService.GetData();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, an external service is called to get data required for &lt;code&gt;MyClass&lt;/code&gt; to function correctly.&lt;/p&gt;
&lt;p&gt;However, is the scenario when &lt;code&gt;ExternalService.GetData()&lt;/code&gt; is an async method &lt;code&gt;ExternalService.GetDataAsync()&lt;/code&gt; handled?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="async"&gt;Async&lt;/h2&gt;
&lt;h3 id="getresult"&gt;GetResult&lt;/h3&gt;
&lt;p&gt;If the only option to get the require data is via a &lt;em&gt;async method&lt;/em&gt;, simply just calling it in the constructor will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
	private readonly string _specialData;


    public MyClass()
    {
        // Won't work!
        // Return type is Task&amp;lt;string&amp;gt; not string
        // _specialData = ExternalService.GetDataAsync();

        // Won't work!
        // To use await, the method needs to be async
        // but constructors cannot be async
        //_specialData = await ExternalService.GetDataAsync();
    }
    	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One &lt;code&gt;not recommended&lt;/code&gt; option is to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
    private readonly string _specialDataTask;

    public MyClass()
    {
    	_specialData = ExternalService.GetDataAsync().GetAwaiter().GetResult();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.GetAwaiter().GetResult()&lt;/code&gt; is used on the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;GetDataAsync&lt;/em&gt; - generally not a good idea to use this approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="lazy"&gt;Lazy&lt;/h3&gt;
&lt;p&gt;A better option is to use the &lt;code&gt;lazy initialization approach&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
    private readonly Task&amp;lt;string&amp;gt; _specialDataTask;

    public MyClass()
    {
       _specialDataTask = ExternalService.GetDataAsync();
    }

    public async Task DoWorkUsingSpecialDataAsync()
    {
       var _specialData = await _specialDataTask.ConfigureAwait(false);

       // Do the work using _specialData
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The type of the &amp;quot;_specialData&amp;quot; variable was changed from &lt;code&gt;string to Task&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the constructor, the &lt;code&gt;async method is called, but not awaited&lt;/code&gt; - this returns a &lt;em&gt;Task&amp;lt;string&amp;gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;When/if the &amp;quot;_specialData&amp;quot; value is required, then the &lt;em&gt;Task&amp;lt;string&amp;gt;&lt;/em&gt; is awaited to get the actual value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this method, when the constructor is called, the process of getting the special data is initiated, but is not blocking. When it comes time to use the value returned from the process, &lt;code&gt;await&lt;/code&gt; is used to get the value from the &lt;em&gt;Task&lt;/em&gt;. Either the processing is finished and the value will be available immediately, or the process is still ongoing and the value will be returned once the process is completed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Ideally, this scenario should probably be avoided all together - but if it is a requirement, the lazy-initialization technique is great way to solve the problem.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://endjin.com/blog/2023/01/dotnet-csharp-lazy-async-initialization"&gt;Lazy and once-only C# async initialization&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;243: 26-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/25-dictionary-comparer</id>
		<title>Case-less Dictionary keys</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/25-dictionary-comparer" />
		<updated>2023-01-25T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Dictionary&lt;/code&gt; constructor can take a &lt;code&gt;StringComparer&lt;/code&gt; parameter allowing for retrieving of keys from the dictionary while ignoring the case of the key. This removes the need to perform &lt;em&gt;ToUpper&lt;/em&gt; and &lt;em&gt;ToLower&lt;/em&gt; on the calls involving the key.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="without-stringcomparer"&gt;Without StringComparer&lt;/h2&gt;
&lt;p&gt;Without a &lt;code&gt;StringComparer&lt;/code&gt;, the case of the &lt;em&gt;key added to the dictionary, and the case of the key when performing a lookup, need to match&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Dictionary&amp;lt;string, int&amp;gt;? artistAlbum = new Dictionary&amp;lt;string, int&amp;gt;();

// Call made to .ToLower() to ensure all artist 
// names are in the same standard format
artistAlbum.Add(&amp;quot;Foo Fighters&amp;quot;.ToLower(), 10);
artistAlbum.Add(&amp;quot;John Mayer&amp;quot;.ToLower(), 8);

// check will only return true if using lower case values,
// or specifically calling ToLower
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;)); // false
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;.ToLower())); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;foo fighters&amp;quot;)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;ToLower&lt;/code&gt; is called each time an item is added to the Dictionary. When performing a check to see if the Dictionary contains a key, a match will only be found if the supplied value is all lower case, or if &lt;code&gt;ToLower&lt;/code&gt; is specifically called again. This ensure that the keys are always stored, and then looked-up in a consistent format - lower case in this example.&lt;/p&gt;
&lt;p&gt;However, all the &lt;code&gt;ToLower&lt;/code&gt; (or &lt;code&gt;ToUpper&lt;/code&gt;) calls do have a performance impact, and additionally they have to manually be added everywhere the Dictionary is used. A simpler and better approach is to use a &lt;code&gt;StringComparer&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="with-stringcomparer"&gt;With StringComparer&lt;/h2&gt;
&lt;p&gt;Using the &lt;code&gt;StringComparer&lt;/code&gt; technique is as simple as passing a value into the &lt;code&gt;Dictionary&lt;/code&gt; constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Dictionary&amp;lt;string, int&amp;gt;? artistAlbum = 
        new Dictionary&amp;lt;string, int&amp;gt;(StringComparer.OrdinalIgnoreCase);

artistAlbum.Add(&amp;quot;Foo Fighters&amp;quot;, 10);
artistAlbum.Add(&amp;quot;John Mayer&amp;quot;, 8);

Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;)); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo fighters&amp;quot;)); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;foo fighters&amp;quot;)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;StringComparer.OrdinalIgnoreCase&lt;/code&gt; is supplied to constructor, &lt;code&gt;ToLower&lt;/code&gt; is no longer required when adding or checking the existence of a key. The case is now ignored when doing the comparison - this results in cleaner code, and better overall performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the &lt;code&gt;Dictionary&lt;/code&gt; could contain keys of various cases (maybe based on user input) then &lt;code&gt;StringComparer&lt;/code&gt; should be used over &lt;em&gt;ToLower&lt;/em&gt; or &lt;em&gt;ToUpper&lt;/em&gt;. There is no overhead to using this approach, and is actually cleaner and more performant.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/dictionary/#pass-in-stringcomparer-to-dictionary"&gt;Pass in StringComparer to Dictionary&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;242: 25-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method</id>
		<title>LINQ lambda vs method group</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method" />
		<updated>2023-01-24T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using an &lt;em&gt;expression&lt;/em&gt; with LINQ, &lt;code&gt;a lambda should be preferred over a method group&lt;/code&gt; as the performance is slightly better. Lambda expressions can be cached by the runtime resulting in the increased performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the below example we'll be filtering a collection of integers, to return only the values which are &lt;em&gt;greater than 100&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Where&lt;/em&gt; method on &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; accepts a &lt;code&gt;Func&amp;lt;int, bool&amp;gt;&lt;/code&gt; - this can be defined as an actual method, or as a lambda method. We'll have a look at each technique, and then compare performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="method-group"&gt;Method group&lt;/h3&gt;
&lt;p&gt;With a collection of integers, to filter using the &lt;em&gt;Where&lt;/em&gt; method with a &lt;code&gt;method group&lt;/code&gt;, a method need to be defined which &lt;em&gt;accepts an int and returns a bool&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// simple method which accepts an int
// and returns true if the value is 
// greater than 100
static bool GreaterThan100(int value)
{
    return value &amp;gt; 100;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can then be used in a &lt;em&gt;Where&lt;/em&gt; method call:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// collection of 100 integers
IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// filter using a method group
IEnumerable&amp;lt;int&amp;gt;? filteredItems = items.Where(GreaterThan100);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="lambda"&gt;Lambda&lt;/h3&gt;
&lt;p&gt;With the &lt;code&gt;lambda technique&lt;/code&gt; the separate defined method is invoked manually with the parameter specified:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// &amp;quot;manually&amp;quot; call the method, sending the int value
// &amp;quot;manually&amp;quot; to the method
var filteredItems1 = items.Where(i =&amp;gt; GreaterThan100(i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both techniques will yield the same results, and on the surface look (and are) very similar. However, next let's look at the performance of each technique to see the main difference.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;For the performance benchmarking, the following &lt;em&gt;lambda&lt;/em&gt; and &lt;em&gt;method group&lt;/em&gt; were tested:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class Benchmarks
{
    private IEnumerable&amp;lt;int&amp;gt; items = Enumerable.Range(1, 10000);

    [Benchmark(Baseline = true)]
    public List&amp;lt;int&amp;gt; MethodGroup() =&amp;gt; items.Where(IsDivisibleBy5).ToList();

    [Benchmark]
    public List&amp;lt;int&amp;gt; Lambda() =&amp;gt; items.Where(i =&amp;gt; IsDivisibleBy5(i)).ToList();

    private static bool IsDivisibleBy5(int i) =&amp;gt; i % 5 == 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;a collection of &lt;em&gt;10000 integers&lt;/em&gt; was used&lt;/li&gt;
&lt;li&gt;each item was checked to determine if it was &lt;em&gt;division by 5 or not&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MethodGroup&lt;/td&gt;
&lt;td style="text-align: right;"&gt;75.04 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.483 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.079 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lambda&lt;/td&gt;
&lt;td style="text-align: right;"&gt;66.44 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.306 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.146 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.89&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, we can see that the &lt;code&gt;lambda technique is approx. 10% faster than the method group technique&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The difference between the two methods is this example (10%) may seem fairly significant, but the timescale is in &lt;em&gt;nanoseconds&lt;/em&gt; - a 10% difference at this scale will not be noticeable. However, depending on the collection size and the complexity of the calculation, the difference could be more noticeable.&lt;br /&gt;
In short - for most scenarios using either technique will be fine, however if performance is an issue, or there is a specific bottleneck, then consider explicitly using the lambda technique.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/advanced/lambda_methodgroup/"&gt;Lambda vs method group&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;241: 24-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</id>
		<title>Task.Delay accuracy</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay" />
		<updated>2023-01-23T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Task.Delay&lt;/code&gt; relies on the underlying operating system's internal timer, which for most Windows environments, takes about 15ms to resolve. This means that the &lt;em&gt;minimum amount of time that can be accurately used with Task.Delay is approximately 15ms (on Windows)&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Diagnostics.StopWatch&lt;/code&gt; can be used to benchmark how long a &lt;code&gt;Task.Delay&lt;/code&gt; call actually takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(100);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, the result (which may vary each execution and per machine):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 110 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the code is specifying a 100ms delay, and actual delay is close to 110ms.&lt;/p&gt;
&lt;p&gt;The same &lt;em&gt;inaccurate&lt;/em&gt; delay is seen when trying to delay for a small precise time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(5);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 19 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results may vary, but (in my case) the true delay was never less than 17ms. As mentioned, this is due to the underlying operating system's internal timer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If requiring small precise waiting times, &lt;code&gt;Task.Delay&lt;/code&gt; is not the way to go. In fact there are no &amp;quot;easy&amp;quot; ways to wait for such small precise times - there are ways to do it (which will not be shown here), but they are involved and are often not very performant when it comes to resource usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/#dont-use-taskdelay-for-small-precise-waiting-times"&gt;Don’t use Task.Delay for small precise waiting times&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;240: 23-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count</id>
		<title>LINQ Any/All over Count</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count" />
		<updated>2023-01-20T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In most scenarios, the LINQ &lt;code&gt;All&lt;/code&gt; or &lt;code&gt;Any&lt;/code&gt; methods should be used instead of the &lt;code&gt;Count&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; should be avoided, as it &lt;em&gt;enumerates through every single entry in the collection to get the count&lt;/em&gt;, where &lt;code&gt;Any/All&lt;/code&gt; will &lt;em&gt;return as soon as the predicate condition is not met anymore&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;All of the below examples, use the following collection:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var intList = Enumerable.Range(1, 10);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="no-predicate"&gt;No predicate&lt;/h3&gt;
&lt;p&gt;When required to check if a list contains &lt;em&gt;any&lt;/em&gt; items, the &lt;code&gt;Any&lt;/code&gt; method should be used instead of &lt;code&gt;Count&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() &amp;gt; 0);
// Good
Console.WriteLine(intList.Any());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, when &lt;code&gt;Count&lt;/code&gt; is used, 10 items needs to be enumerated to get the full count, however &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; after one iteration, as soon as one item is found.&lt;br /&gt;
With only 10 items, the difference is negligible, however as the number of items in the collection increased, the difference will become more noticeable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="with-predicate"&gt;With predicate&lt;/h3&gt;
&lt;p&gt;The same logic applies when a &lt;em&gt;predicate is supplied&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 5) &amp;gt; 0);
// Good
Console.WriteLine(intList.Any(i =&amp;gt; i &amp;gt; 5));

// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 10) == 0);
// Good
Console.WriteLine(!intList.Any(i =&amp;gt; i &amp;gt; 10));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Count&lt;/code&gt; method will need to enumerable over all items in the collection, while &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; as soon as the first item which satisfies the predicate is reached.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="all-items"&gt;All items&lt;/h3&gt;
&lt;p&gt;Similar logic applies when &lt;code&gt;All&lt;/code&gt; items in the collection need to be checked:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() == intList.Count(i =&amp;gt; i  &amp;lt; 100));
// Good
Console.WriteLine(intList.All(i =&amp;gt; i &amp;lt; 100));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, with &lt;code&gt;Count&lt;/code&gt;, all items in the collection are enumerated over, while the &lt;code&gt;All&lt;/code&gt; method will return &lt;em&gt;false&lt;/em&gt; as soon as one item is reached which does not satisfy the predicate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally, unless &lt;code&gt;Count&lt;/code&gt; specifically needs to be used, &lt;code&gt;Any&lt;/code&gt; or &lt;code&gt;All&lt;/code&gt; should be preferred, especially as the number of items in the collection increases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/linq/#using-count-instead-of-all-or-any"&gt;Using Count() instead of All or Any&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;239: 20-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await</id>
		<title>Eliding await keyword</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await" />
		<updated>2023-01-19T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple &lt;em&gt;async method&lt;/em&gt; are called in a sequence, the &lt;code&gt;async methods should be elided&lt;/code&gt; and the &lt;em&gt;Tasks&lt;/em&gt; should be &lt;em&gt;awaited&lt;/em&gt; and not passed up the call stack.&lt;/p&gt;
&lt;p&gt;If a &lt;em&gt;Task&lt;/em&gt; is passed up the stack, and an exception occurs - the Task which is not &lt;em&gt;awaited&lt;/em&gt; will not be part of the error stack trace.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-await-exception"&gt;No await exception&lt;/h2&gt;
&lt;p&gt;In the below code snippet, we have a call stack where a &lt;em&gt;Task&lt;/em&gt; is &lt;code&gt;not awaited immediately&lt;/code&gt;, but passed up the call stack to be awaited:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await NoAwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

// return a Task
static Task NoAwaitMethod()
{
    // call a method which returns a Task but 
    // do NOT await
    return ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoAwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, but &lt;strong&gt;does not await the call&lt;/strong&gt;. The method returns the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns - which is the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Running the above code, the call stack generated from the exception is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The stack trace has &lt;code&gt;no mention that the call stack went through the NoAwaitMethod method!&lt;/code&gt;. This is due to the fact that the method is basically just a &lt;em&gt;pass through method&lt;/em&gt; for the &lt;em&gt;Task&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To get a more accurate stack trace, the &lt;em&gt;async method needs to be awaited&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="await-exception"&gt;await exception&lt;/h2&gt;
&lt;p&gt;As mentioned above, instead of a method like &lt;em&gt;NoAwaitMethod&lt;/em&gt;, which serves as a pass through for the &lt;em&gt;Task&lt;/em&gt;, the &lt;code&gt;Task should be awaited&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;wait CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await AwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

static async Task AwaitMethod()
{
    // await the task returned instead
    // of just returning the Task
    await ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, and &lt;strong&gt;awaits the call&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now running the above code, the full complete stack trace is part of the exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__AwaitMethod|0_1() in C:\Development\Blog\ElideAwait\Program.cs:line 21
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 6 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time we have a &lt;code&gt;full, complete stack trace!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When &lt;em&gt;await async&lt;/em&gt; is used in conjunction with any &lt;em&gt;exceptions&lt;/em&gt;, the Tasks in question should be elided and &lt;em&gt;awaited&lt;/em&gt; and not passed up the stack trace as it can cause certain methods to be omitted from exception stack traces.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/"&gt;Elide await keyword - Exceptions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;238: 19-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>