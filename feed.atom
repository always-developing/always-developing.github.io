<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-07-27T04:34:03Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving</id>
		<title>Null forgiving operator</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving" />
		<updated>2022-07-27T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# contains a &lt;code&gt;unary, postfix, null-forgiving&lt;/code&gt; (or null-suppression) operator &lt;code&gt;!&lt;/code&gt;, which can be used to declare that an expression of a reference type is &lt;code&gt;not null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The null-forgiving operator is used in a nullable enabled context, has no effect at run time, and only affects the compiler's static flow analysis by changing the null state of the expression in question.&lt;/p&gt;
&lt;p&gt;Effectively, the operator informs the compiler that an expression which it has determined to be &lt;code&gt;null&lt;/code&gt;, is in fact not null and no diagnostic alert (a warning by default) needs to be raised.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="unit-testing"&gt;Unit testing&lt;/h3&gt;
&lt;p&gt;A practical use of the &lt;code&gt;!&lt;/code&gt; null-forgiving operator, is when performing unit tests.&lt;/p&gt;
&lt;p&gt;Consider the following class, which has an &lt;em&gt;Artist&lt;/em&gt; property, forced to be &lt;code&gt;non-null&lt;/code&gt; by the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; }

    public Song(string artist)
    {
        Artist = artist ?? throw new ArgumentNullException(nameof(artist));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When unit testing the class, one would want to test all possible combinations of &lt;em&gt;Song&lt;/em&gt; instantiation - with and without a valid &lt;em&gt;artist&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
var exceptionSong = new Song(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, is at compile time, the compiler sees the &lt;code&gt;null&lt;/code&gt; being passed to the constructor and raises the following warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot convert null literal to non-nullable reference type.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we &lt;strong&gt;want&lt;/strong&gt; to pass &lt;code&gt;null&lt;/code&gt; as part of a unit test to determine the correct behavior is seen. The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used to effectively tell the compiler, that the &lt;em&gt;&lt;code&gt;null&lt;/code&gt; expression is not null, and the compiler does not need to treat is as such&lt;/em&gt; (and thus no warning is generated)&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
// Null-forgiving operator added
var exceptionSong = new Song(null!);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-check"&gt;Manual check&lt;/h3&gt;
&lt;p&gt;Another practical use of the &lt;code&gt;null-forgiving operator&lt;/code&gt;, is in situations when the compiler has &lt;code&gt;incorrectly&lt;/code&gt; determined that an expression could possibly be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the below method to validate an instance of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static bool IsValid(Song? song)
    =&amp;gt; song is not null &amp;amp;&amp;amp; song.Artist is not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance 
// from a source
Song? s = GetSong();

// validate the song and output if valid
if (IsValid(s))
{
    Console.WriteLine($&amp;quot;Song by Artist `{s.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code generates the following warning on the &lt;code&gt;s.Artist&lt;/code&gt; usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Dereference of a possibly null reference.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This warning is due to the fact, that based on the data types, &lt;code&gt;s&lt;/code&gt; (of type &lt;code&gt;Song?&lt;/code&gt;) could contain a &lt;code&gt;null&lt;/code&gt; value, in which case &lt;code&gt;s.Artist&lt;/code&gt; would cause an exception. However, the &lt;code&gt;IsValid&lt;/code&gt; method is performing checks to ensure that &lt;code&gt;s.Artist can never be invoked when s is null&lt;/code&gt; - in this use case the warning is incorrect.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used again to tell the compiler, that the &lt;em&gt;s&lt;/em&gt; expression in &lt;code&gt;s.Artist&lt;/code&gt; can be treated as never being null.&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance
Song? s = GetSong();

if (IsValid(s))
{
    // null-forgiving operator added
    Console.WriteLine($&amp;quot;Song by Artist `{s!.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not an operator for every day use for most applications, the &lt;code&gt;null-forgiving&lt;/code&gt; operator can be very useful in resolving certain inaccurate warnings. However take care when using the operator, and only implement when sure that the compiler is incorrect. While the code itself will not throw any exceptions &lt;strong&gt;because&lt;/strong&gt; of the operator usage (it's ignored at runtime), the code could throw exceptions due to the the expression in question being &lt;code&gt;null&lt;/code&gt; - which the compiler was trying to warn about (before being manually overwritten with the operator)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving"&gt;! (null-forgiving) operator&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;125: 27-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution</id>
		<title>IEnumerable's lazy evaluation</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution" />
		<updated>2022-07-26T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When executing a method which returns &lt;em&gt;IEnumerable&lt;/em&gt;, the method body is &lt;code&gt;not execute until the result is enumerated over&lt;/code&gt;. Invoking the method will not cause any of the method code to execute, including any code before the first &lt;code&gt;yield&lt;/code&gt; in the body - not until enumeration.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ienumerable"&gt;IEnumerable&lt;/h2&gt;
&lt;p&gt;A quick summary of &lt;code&gt;IEnumerable&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; usage - when a method is defined to have a return type of IEnumberable&amp;lt;T&amp;gt;, it can be invoked and the results iterated over:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method in the foreach loop
foreach(var number in GetNumbers())
{
    Console.WriteLine(number);
}

public IEnumberable&amp;lt;int&amp;gt; GetNumbers()
{
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The great benefit of IEnumerable though, comes with its usage in conjunction with the &lt;code&gt;yield&lt;/code&gt; keyword - this is used inside the method to return a value and (temporarily) yield control to the calling iterator. Once the iteration body (&lt;em&gt;Console.WriteLine&lt;/em&gt; in our example) is complete, control is then returned back to the method, which is executed until the next &lt;code&gt;yield&lt;/code&gt; is encountered.&lt;/p&gt;
&lt;p&gt;The output for the above would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-evaluation"&gt;Lazy evaluation&lt;/h2&gt;
&lt;p&gt;In the above example we saw how the &lt;em&gt;GetNumbers&lt;/em&gt; method was called as part of the iterator (as part of the &lt;code&gt;foreach&lt;/code&gt;) - but it is also possible to invoke the method, and store the returned &lt;em&gt;IEnumerable&lt;/em&gt; for later execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method 
IEnumerable&amp;lt;int&amp;gt; numbers = GetNumbers();

// do more processing

// iterate over the IEnumerable&amp;lt;int&amp;gt; variable
foreach (var number in numbers)
{
    Console.WriteLine(number);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the same output as the previous example above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-execution"&gt;Lazy execution&lt;/h2&gt;
&lt;p&gt;The interesting part about the lazy evaluation (and the reason for this post), is that when using &lt;code&gt;lazy evaluation&lt;/code&gt;, the method body is &lt;code&gt;not executed when the method is called&lt;/code&gt;, only when it's &lt;code&gt;iterated over&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Consider the following method which returns &lt;em&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/em&gt;, but before it returns a value it will log which value is being returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; GetStringsWithLogging()
{
    Console.WriteLine(&amp;quot;Executing iteration 1&amp;quot;);
    yield return &amp;quot;Iteration 1&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 2&amp;quot;);
    yield return &amp;quot;Iteration 2&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 3&amp;quot;);
    yield return &amp;quot;Iteration 3&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 4&amp;quot;);
    yield return &amp;quot;Iteration 4&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 5&amp;quot;);
    yield return &amp;quot;Iteration 5&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is executed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine($&amp;quot;Before '{nameof(GetStringsWithLogging)}' called&amp;quot;);
var deferLogging = GetStringsWithLogging();
Console.WriteLine($&amp;quot;After '{nameof(GetStringsWithLogging)}' called&amp;quot;);

foreach (var item in deferLogging)
{
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before 'GetStringsWithLogging' called
After 'GetStringsWithLogging' called
Executing iteration 1
Iteration 1
Executing iteration 2
Iteration 2
Executing iteration 3
Iteration 3
Executing iteration 4
Iteration 4
Executing iteration 5
Iteration 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output one can see that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is &lt;code&gt;not invoked&lt;/code&gt; when it is initially called - it is only when the &lt;em&gt;deferLogging&lt;/em&gt; variable is iterated over with the &lt;em&gt;foreach&lt;/em&gt; loop, that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;My initial gut assumption with an IEnumerable method was that the body of the method in question (&lt;em&gt;GetStringsWithLogging&lt;/em&gt; here) would execute up until the first &lt;code&gt;yield&lt;/code&gt; when called, no matter if lazy or not. However working through sample examples, and understanding how the code is lowered, the deferred execution makes more sense - and I am glad my initial assumptions were incorrect.&lt;/p&gt;
&lt;p&gt;Having the ability to defer execution of the method allows for potentially long running processes which retrieve the results data (for example), to be deferred until/if actually needed (obviously all by design, I am sure) it very valuable. The &lt;em&gt;IEnumerable&lt;/em&gt; instance can be passed around between methods, and only materialized when required - instead of passing around the (potentially larger in size) materialized data, when it might not even be needed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.blog/2022/06/15/c-ienumerable-yield-return-and-lazy-evaluation/"&gt;C#: IEnumerable, yield return, and lazy evaluation&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;124: 26-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/25-environment-configuration</id>
		<title>Environment specific startup Configure methods</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/25-environment-configuration" />
		<updated>2022-07-25T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using the &lt;code&gt;Startup&lt;/code&gt; class approach for application startup (vs the top level minimal api approach introduced in .NET6), instead of the normal &lt;em&gt;Configure&lt;/em&gt; method used to configure the middleware pipeline, a method can be specified &lt;code&gt;per environment&lt;/code&gt;. This environment specific &lt;em&gt;Configure&lt;/em&gt; method is automatically invoked depending on the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; environment variable value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="startup"&gt;Startup&lt;/h2&gt;
&lt;p&gt;Prior to .NET 6, when creating an ASP.NET Core web API project, a &lt;code&gt;Program.cs&lt;/code&gt; file is created containing the &lt;em&gt;Main&lt;/em&gt; method, and a separate &lt;code&gt;Startup.cs&lt;/code&gt; file is created containing the dependency injection setup method (&lt;em&gt;ConfigureServices&lt;/em&gt;) as well as the middleware pipeline setup method &lt;strong&gt;&lt;em&gt;Configure&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The Host setup in &lt;code&gt;Program.cs&lt;/code&gt; is configured to use the &lt;em&gt;Startup&lt;/em&gt; class in &lt;code&gt;Startup.cs&lt;/code&gt; to get its configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            // Use the Startup class
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In .NET6 the default changes to contain only a &lt;code&gt;Program.cs&lt;/code&gt;, and instead of a instance of &lt;em&gt;HostBuilder&lt;/em&gt; being used, an instance of &lt;em&gt;WebApplicationBuilder&lt;/em&gt; is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The .NET6 default can be retro-fitted to use the same approach as prior versions (Startup class), but this post is mainly focused on versions prior to .NET6.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-configuration"&gt;Default Configuration&lt;/h3&gt;
&lt;p&gt;By default in the &lt;code&gt;Startup.cs&lt;/code&gt; the &lt;em&gt;Configure&lt;/em&gt; method which is used to setup the middleware pipeline. This method is automatically invoked by the runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// This method gets called by the runtime. Use this method to 
// configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the pipeline needs to differ per environment, then checks, such as the one below, need to be implemented:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Check if we are running in a development environment
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the developer exception page is only configured if the application is running in &lt;em&gt;Development&lt;/em&gt; - when the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; is set to &lt;strong&gt;Development&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Using these checks is the default technique to configure the pipeline per environment - however, especially if the pipelines differ greatly per environment, these checks could become complicated and potentially confusing.&lt;/p&gt;
&lt;p&gt;An alternative technique is to setup a &lt;code&gt;configure method per environment&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="environment-configuration"&gt;Environment Configuration&lt;/h3&gt;
&lt;p EnvironmentName=""&gt;Setting up a &lt;em&gt;Configure&lt;/em&gt; method per environment is very simple - in the &lt;em&gt;Startup&lt;/em&gt; class, just create a new method called &lt;em&gt;Configure&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, the &lt;em&gt;ConfigureTest&lt;/em&gt; method will be called when running in &lt;strong&gt;Test&lt;/strong&gt;, instead of the default &lt;em&gt;Configure&lt;/em&gt; method, and the &lt;em&gt;ConfigureProduction&lt;/em&gt; method will be called when running in &lt;strong&gt;Production&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
public void ConfigureTest(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapGet(&amp;quot;/&amp;quot;, async (HttpContext ctx) =&amp;gt; 
            await ctx.Response.WriteAsync(&amp;quot;In Test environment&amp;quot;));
        endpoints.MapControllers();
    });
}

public void ConfigureProduction(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It no environment specific method could be found, then the default &lt;em&gt;Configure&lt;/em&gt; method is called.&lt;/p&gt;
&lt;p&gt;The same process can be applied to &amp;quot;non-built-in&amp;quot; environments (Development, Test, Production) - if when running locally, the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; environment variable is set to &lt;strong&gt;LocalDevelopment&lt;/strong&gt;, for example, then the following method will be called:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Method named Configure{EnvironmentName}
 public void ConfigureLocalDevelopment(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();
    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapGet(&amp;quot;/debug&amp;quot;, async (HttpContext ctx) =&amp;gt; 
            await ctx.Response.WriteAsync(&amp;quot;Special debug information&amp;quot;));
        endpoints.MapControllers();

    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Perhaps not especially relevent if working with the latest version of .NET (6 and above), or if there is not major differences in middleware pipelines between difference environments - this is still an interesting technique available if one requires it to ensure cleaner and easier to understand code.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;123: 25-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/22-require-property</id>
		<title>Exploring the new required properties</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/22-require-property" />
		<updated>2022-07-22T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;As part of C#11 release later this year (2022), is a potential new keyword, &lt;code&gt;required&lt;/code&gt; (potential as it's still currently in preview and is not guaranteed to be included in the final release).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; keyword is applied to a &lt;em&gt;property&lt;/em&gt; and will force the property value to be set in the &lt;em&gt;object initializer&lt;/em&gt;. The compiler will generate an error and prevent compilation if the property is not set.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="current"&gt;Current&lt;/h2&gt;
&lt;p&gt;In our example we have a &lt;em&gt;Song&lt;/em&gt; class, which has three fields. We require that these three fields always be set, and cannot be updated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Name { get; init; }

    public string Artist { get; init; }

    public int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;init&lt;/code&gt; keyword is used to specify that the values of the properties can only be set on &lt;em&gt;initialization&lt;/em&gt; of the class, and after that they are read only. However, just doing the above &lt;code&gt;does not enforce the values be set&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following is completely valid:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    LengthInSeconds = 250
};

// Name will be NULL here.
Console.WriteLine(song.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only way with the current versions of C#, is to use a &lt;code&gt;constructor&lt;/code&gt; to enforce the property values be set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Name { get; init; }

    public string Artist { get; init; }

    public int LengthInSeconds { get; init; }

    // new constructor taking all three required arguments
    public Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the &lt;em&gt;object initializer syntax&lt;/em&gt; (the syntax in the previous initialization of &lt;em&gt;Song&lt;/em&gt;) is now invalid - the compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;There is no argument given that corresponds to the required formal parameter 'name' of 'Song.Song(string, string, int)'	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;constructor&lt;/code&gt; now needs to be used to initialize an instance of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(&amp;quot;Foo Fighters&amp;quot;, &amp;quot;Everlong&amp;quot;, 250);
Console.WriteLine(song.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we've fulfilled our requirement - the three fields always be set, and cannot be updated? Yes! ...but....&lt;/p&gt;
&lt;p&gt;Imagine you have a class with &lt;code&gt;20 require properties&lt;/code&gt;, in conjunction with &lt;code&gt;10 optional properties&lt;/code&gt; - you'd end up with at least one constructor with at least 20 parameters. In addition, the 10 optional properties can either be set in a constructor resulting in a 30 parameter constructor, or using the &lt;em&gt;object initializer syntax&lt;/em&gt;, which forces the use of two different methods to set values when initializing a class.&lt;/p&gt;
&lt;p&gt;In the below, the optional &lt;em&gt;YearReleased&lt;/em&gt; &lt;code&gt;init&lt;/code&gt; only property has been added (but not added to the constructor):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(&amp;quot;Foo Fighters&amp;quot;, &amp;quot;Everlong&amp;quot;, 250)
{
    YearReleased = 1997
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of this will &lt;em&gt;function&lt;/em&gt;, but it is not very intuitive or developer friendly - enter the &lt;code&gt;required&lt;/code&gt; keyword.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="required-keyword"&gt;Required keyword&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; keyword is applied to the property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public required string Name { get; init; }

    public required string Artist { get; init; }

    public required int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And enforces that the property is set on object initialization.&lt;/p&gt;
&lt;p&gt;The following does &lt;strong&gt;NOT&lt;/strong&gt; compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    LengthInSeconds = 250
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generating the compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Required member 'Song.Name' must be set in the object initializer or attribute constructor.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now there is &lt;code&gt;no need for the constructor&lt;/code&gt; as the compiler will enforce that &lt;code&gt;required&lt;/code&gt; properties are set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    Name = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in cleaner code, as there are no constructors with numerous arguments, and there is a single standard way in which required and optional properties can be initialized.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;I'm looking forward to this feature, and hoping that it is included in C#11. It will be interesting to explore how this can replace or mostly likely, work with the &lt;code&gt;Required&lt;/code&gt; attribute data annotation to perform the necessary checks at compile time, and not only at runtime.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=9CDgPgWF9IY"&gt;Nick Chapsas - Why I won’t need constructors anymore in C# 11&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;122: 22-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/21-addjsonstream</id>
		<title>Configuration from memory with AddJsonStream</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/21-addjsonstream" />
		<updated>2022-07-21T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When writing &lt;code&gt;unit test&lt;/code&gt; which require application configuration through &lt;code&gt;IConfiguration&lt;/code&gt;, the &lt;code&gt;AddJsonStream&lt;/code&gt; method can be used to load different application settings configuration from memory (instead of from an appsettings.json file).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;The setup is a fairly common pattern I've experienced when writing &lt;code&gt;shared, reusable, packaged libraries&lt;/code&gt; - a piece of functionality is packaged into a library (not shown in this post, but published to a NuGet store). This library functionality is configured and added to the dependency injection container at startup using an extension method, with the configuration options for the library (optionally) specified in the appsettings.json file.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;class library&lt;/code&gt; is created for the shared component.&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;interface&lt;/code&gt; is created as an abstraction for the logic:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IDoWork
{
    int DoSomeWork();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we also have an &lt;code&gt;options&lt;/code&gt;/settings/configuration class which contains the settings for the library:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DoWorkOptions
{
    public bool IsEnabled { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then there is the implementation of the interface, the logic for the library (incredibly simple in this demo):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DoWork : IDoWork
{
    /// &amp;lt;summary&amp;gt;
    /// Stores the configuration options
    /// &amp;lt;/summary&amp;gt;
    private readonly DoWorkOptions _options;

    /// &amp;lt;summary&amp;gt;
    /// Constructor
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;options&amp;quot;&amp;gt;The configuration options&amp;lt;/param&amp;gt;
    public DoWork(DoWorkOptions options)
    {
        _options = options;
    }

    /// &amp;lt;summary&amp;gt;
    /// Executes the functionality of the library
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;1 if enabled, 0 if disabled&amp;lt;/returns&amp;gt;
    public int DoSomeWork()
    {
        if(_options.IsEnabled)
        {
            return 1;
        }

        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally an extension method on &lt;code&gt;IServiceCollection&lt;/code&gt; to configure all the pieces with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class DoWorkExtensions
{
    /// &amp;lt;summary&amp;gt;
    /// Configure the library with the DI container
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;services&amp;quot;&amp;gt;The IServiceCollection implementation&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&amp;quot;configuration&amp;quot;&amp;gt;The IConfiguration implementation&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static IServiceCollection AddDoWork(this IServiceCollection services, 
        IConfiguration configuration)
    {
        // load the options from the configuration implementation
        var options = new DoWorkOptions();
        configuration.GetSection(&amp;quot;doWorkOptions&amp;quot;).Bind(options);

        // add the functionality to DI
        services.AddTransient(typeof(IDoWork), typeof(DoWork));
        // add the options to DI
        services.AddSingleton(options);

        return services;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To recap - we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an interface for the functionality (&lt;em&gt;IDoWork&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;with an implementation of the functionality (&lt;em&gt;DoWork&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;which is configured using options (&lt;em&gt;DoWorkOptions&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;and setup with the dependency injection container using an extension method (&lt;em&gt;DoWorkExtensions&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our very simple shared library is now &lt;code&gt;complete and ready to be used&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="web-api"&gt;Web api&lt;/h2&gt;
&lt;p&gt;First a look at how this would be used in an &lt;code&gt;minimal web api&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the necessary references in place, the extension method can be invoked on startup, which then allows for the the &lt;em&gt;IDoWork&lt;/em&gt; interface to be injected into the endpoint handler delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// this line is not explicitly needed as its automatically done 
// if not specified here, but the configuration get loaded from the 
// appsettings.json file
builder.Configuration.AddJsonFile(&amp;quot;appsettings.json&amp;quot;);

// configured with dependency injection container
builder.Services.AddDoWork(builder.Configuration);

var app = builder.Build();

// injected IDoWork
app.MapGet(&amp;quot;/work&amp;quot;, (IDoWork worker) =&amp;gt;
{
    // execute the logic
    return worker.DoSomeWork();
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the appsettings.json being as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;DoWorkOptions&amp;quot;: {
    &amp;quot;IsEnabled&amp;quot; :  true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the &lt;code&gt;/work&lt;/code&gt; endpoint will return a &lt;code&gt;1 or 0&lt;/code&gt; dependant on if the &lt;em&gt;DoWorkOptions -&amp;gt; IsEnabled&lt;/em&gt; flag is set to &lt;code&gt;true or false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;So how do we unit test a piece of code which is dependant on json configuration? - with the &lt;code&gt;AddJsonStream&lt;/code&gt; method!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unit-test"&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AddJsonStream&lt;/code&gt; is an extension method on &lt;em&gt;ConfigurationBuilder&lt;/em&gt;, which as the name implies, allows for loading of JSON configuration data from memory, instead of from file as is the the case with &lt;code&gt;AddJsonFile&lt;/code&gt; above.&lt;/p&gt;
&lt;p&gt;We can leverage this to write unit tests with different setups of configuration.&lt;/p&gt;
&lt;p&gt;A note - there are other/better ways of performing endpoint testing, &lt;code&gt;WebApplicationFactory&lt;/code&gt; for example, but these are intentionally simple and the logic is being tested directly (from the DI container), and not through an endpoint.&lt;/p&gt;
&lt;p&gt;Test when the option is &lt;em&gt;&lt;strong&gt;enabled&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TestMethod]
public void Test_Enabled_Config()
{
    // create a memory stream with the json configuration
    var sr = new MemoryStream(Encoding.ASCII.GetBytes(&amp;#64;&amp;quot;
{
&amp;quot;&amp;quot;DoWorkOptions&amp;quot;&amp;quot; : {
    &amp;quot;&amp;quot;IsEnabled&amp;quot;&amp;quot; : true
}
}&amp;quot;));

    // setup host
    var host = Host.CreateDefaultBuilder()
        .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
        {
            // load from the memory stream, and not from file
            config.AddJsonStream(sr);
        })
        .ConfigureServices((context, services) =&amp;gt; services
            .AddDoWork(context.Configuration)
        ).Build();

    // get the implementation from the DI container
    var worker = (IDoWork)host.Services.GetService(typeof(IDoWork));

    // invoke and assert the result
    Assert.AreEqual(1, worker.DoSomeWork());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test when the option is &lt;em&gt;&lt;strong&gt;disabled&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TestMethod]
public void Test_Disabled_Config()
{
    // create a memory stream with the json configuration
    var sr = new MemoryStream(Encoding.ASCII.GetBytes(&amp;#64;&amp;quot;
{
&amp;quot;&amp;quot;DoWorkOptions&amp;quot;&amp;quot; : {
    &amp;quot;&amp;quot;IsEnabled&amp;quot;&amp;quot; : false
}
}&amp;quot;));

    // setup host
    var host = Host.CreateDefaultBuilder()
        .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
        {
            // load from the memory stream, and not from file
            config.AddJsonStream(sr);
        })
        .ConfigureServices((context, services) =&amp;gt; services
            .AddDoWork(context.Configuration)
        ).Build();

    // get the implementation from the DI container
    var worker = (IDoWork)host.Services.GetService(typeof(IDoWork));

    // invoke and assert the result
    Assert.AreEqual(0, worker.DoSomeWork());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additional tests can obviously be included for additional use cases (empty configuration file, invalid name or value in the file etc.) - and these are easy and quick to add and configure with &lt;code&gt;AddJsonStream&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AddJsonStream&lt;/code&gt; is a very useful method when writing unit tests - I'm not sure how useful it would be outside of a unit test, during the normal execution of an application, but its available if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;121: 21-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/20-sql-wildcards</id>
		<title>SQL wildcard characters</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/20-sql-wildcards" />
		<updated>2022-07-20T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;There are a number of SQL wildcard characters, apart from the commonly used (at least in my case) &lt;code&gt;zero or more characters, %&lt;/code&gt; wildcard. These include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; - representing a single character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - representing any single character within the brackets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; - representing any character not in the brackets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; - representing any single character in the specified range&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="table-setup"&gt;Table setup&lt;/h2&gt;
&lt;p&gt;We have a simple &lt;code&gt;Word&lt;/code&gt; table, with one column, also called &lt;code&gt;Word&lt;/code&gt;. The table is populated with 5 records:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;flout
hit
hot
hut
shout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="single-character"&gt;Single character&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;_&lt;/code&gt; is used to represent a single character.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which start with an 'h' and end with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h_t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="single-character-array"&gt;Single character array&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;[]&lt;/code&gt; characters are used to represent any single character specified within the brackets.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which start with an 'h', have an 'o' OR 'u' as the middle letter, and which end with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To reiterate,  only a &lt;code&gt;single character&lt;/code&gt; from within the brackets is matched. For example&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'sh[ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No rows will be returned, as &lt;code&gt;shout&lt;/code&gt; is NOT a match. Only &lt;code&gt;shot&lt;/code&gt; and &lt;code&gt;shut&lt;/code&gt; would be matched.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="character-array-negation"&gt;Character array negation&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;^&lt;/code&gt; character is used, in conjunction with the characters in the brackets &lt;code&gt;[]&lt;/code&gt;, as a negation.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which end in 'out', but NOT preceded by an 'l'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE '%[^l]out'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;shout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The negation applies to all character in the brackets.&lt;/p&gt;
&lt;p&gt;The following will select &lt;code&gt;any three letter word, which starts with an 'h', does NOT contain 'o' or 'u' as the middle letter, and ends in 't'&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[^ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="character-range"&gt;Character range&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;-&lt;/code&gt; character is used in conjunction with the characters in the brackets &lt;code&gt;[]&lt;/code&gt;, as a range specifier.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words starting with 'h', has any character in the alphabet between, and including, 'o' and 'u' in the middle, and ending in 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[o-u]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="multiple-characters"&gt;Multiple characters&lt;/h3&gt;
&lt;p&gt;A quick look at the more common &lt;code&gt;%&lt;/code&gt; character, which is used to represent zero or more characters.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;words starting with zero or more of any characters, followed by an 'h', followed by zero or more of any characters, and finally ending with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE '%h%t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
hot
hut
shout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Personally, I've never had any specific need or requirement for any of these wildcards, apart from &lt;code&gt;%&lt;/code&gt; -  however, they all have their place. With the knowledge of their existence, one is at least equipped to determine if any can add any value with each specific use case or requirement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.w3schools.com/sql/sql_wildcards.asp"&gt;SQL Wildcard Characters&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;120: 20-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/19-nameof-constants</id>
		<title>nameof usage for better code quality</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/19-nameof-constants" />
		<updated>2022-07-19T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When defining string with constants (in particular, but other situations also apply) the &lt;code&gt;nameof operator&lt;/code&gt; can be leveraged to remove explicitly set values, ensuring more consistent, cleaner and less error prone code is produced.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nameof-expression"&gt;nameof expression&lt;/h2&gt;
&lt;p&gt;So briefly, what does &lt;code&gt;nameof&lt;/code&gt; do? - it &lt;em&gt;produces the name of a variable type, or member as the string constant&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var fibonacci = new List&amp;lt;int&amp;gt; { 0, 1, 1, 2, 3, 5 } ;
Console.WriteLine(nameof(List&amp;lt;int&amp;gt;));  // outputs the type
Console.WriteLine(nameof(fibonacci)); // outputs the variable name
Console.WriteLine(nameof(fibonacci.Count)); // outputs the method name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List
fibonacci
Count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So let's see how we can leverage &lt;code&gt;nameof&lt;/code&gt; in the following use cases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="constants"&gt;Constants&lt;/h2&gt;
&lt;h3 id="issue"&gt;Issue&lt;/h3&gt;
&lt;p&gt;Suppose our application has a list of &lt;em&gt;system statuses&lt;/em&gt; stored as &lt;code&gt;string constants&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = &amp;quot;Starting&amp;quot;;
    public const string Running = &amp;quot;Running&amp;quot;;
    public const string ShuttingDown = &amp;quot;ShuttingDown&amp;quot;;
    public const string Offline = &amp;quot;Offline&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the usage and output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(SystemStatus.ShuttingDown); // outputs &amp;quot;ShuttingDown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is there anything &lt;code&gt;inherently wrong&lt;/code&gt; with this approach? Not really, it still functions as expected.&lt;/p&gt;
&lt;p&gt;However, suppose we need to &lt;code&gt;change the &amp;quot;ShuttingDown&amp;quot; status to &amp;quot;Terminating&amp;quot;&lt;/code&gt;. Navigating to one of the usages of &lt;em&gt;SystemStatus.ShuttingDown&lt;/em&gt;, we rename the &lt;code&gt;const&lt;/code&gt; (using F2 &lt;em&gt;Rename&lt;/em&gt;, for example).&lt;/p&gt;
&lt;p&gt;We now have this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(SystemStatus.Terminating); // still outputs &amp;quot;ShuttingDown&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However the output is still &lt;code&gt;&amp;quot;ShuttingDown&amp;quot;&lt;/code&gt;, even though the &lt;code&gt;const&lt;/code&gt; name has been changed to &lt;em&gt;Terminating&lt;/em&gt;! We now either have &lt;code&gt;misleading code at best or a bug at worst.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="resolution"&gt;Resolution&lt;/h3&gt;
&lt;p&gt;As this post implies, the solution is to use the &lt;code&gt;nameof&lt;/code&gt; operator instead of a hard-coded string!&lt;/p&gt;
&lt;p&gt;Replacing the string values, with &lt;code&gt;nameof&lt;/code&gt; referencing the same variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = nameof(Starting);
    public const string Running = nameof(Running);
    public const string ShuttingDown = nameof(ShuttingDown);
    public const string Offline = nameof(Offline);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This for example will set the value of the &lt;em&gt;Starting&lt;/em&gt; constants to the name of the constant, &amp;quot;Starting&amp;quot;.&lt;/p&gt;
&lt;p&gt;Now when renaming one of the &lt;code&gt;const&lt;/code&gt; names, it's value will be kept consistent - the same as the &lt;code&gt;const&lt;/code&gt; name. If manually renaming one of the &lt;code&gt;const&lt;/code&gt; names, but forgetting to rename its usage in &lt;code&gt;nameof&lt;/code&gt; will result in a compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = nameof(Starting);
    public const string Running = nameof(Running);
    // Compiler error &amp;quot;ShuttingDown&amp;quot; does not exist
    public const string Terminating = nameof(ShuttingDown);
    public const string Offline = nameof(Offline);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result - cleaner, more consistent and less error prone code!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="parameters"&gt;Parameters&lt;/h2&gt;
&lt;h3 id="issue-1"&gt;Issue&lt;/h3&gt;
&lt;p&gt;A similar issue can be experience in instances where a &lt;code&gt;parameter name is used&lt;/code&gt;, in an exception message, for example.&lt;/p&gt;
&lt;p&gt;If we have this method, with the parameter name hardcoded in the exception string message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int div)
{
    if(div == 0)
    {
        // string value is hardcoded with the parameter name
        throw new ArgumentException($&amp;quot;Parameter 'div' cannot be zero&amp;quot;);
    }

    return dividend / div;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We realize the &lt;code&gt;div&lt;/code&gt; parameter is not a good parameter name, and should be renamed to &lt;code&gt;divisor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int divisor)
{
    if(divisor == 0)
    {
        // string value is hardcoded with the INCORRECT parameter name
        throw new ArgumentException($&amp;quot;Parameter 'div' cannot be zero&amp;quot;);
    }

    return dividend / divisor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Its very easy to miss the hardcoded string when refactoring, especially if using an IDE rename feature, which won't automatically rename the hand-coded parameter name within the string.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="resolution-1"&gt;Resolution&lt;/h3&gt;
&lt;p&gt;Again, the remedy is to use the &lt;code&gt;nameof&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int divisor)
{
    if (divisor == 0)
    {
        throw new ArgumentException($&amp;quot;Parameter '{nameof(divisor)}' cannot be zero&amp;quot;);
    }

    return dividend / divisor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if renaming the parameter name, the exception message is automatically updated as well (or will throw a compiler error if not all usages of the parameter are not updated):&lt;/p&gt;
&lt;p&gt;The result - cleaner, more consistent and less error prone code!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, simple technique to incorporate into daily coding, which may not have any obvious immediate benefit - but if/when it comes time to do any refactoring, will definitely save time and effort due to its cleaner, more consistent approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/v81c13/can_anyone_tell_me_the_point_of_this_syntax_im/"&gt;Reddit CSharp post&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;119: 19-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/18-tuple-equality</id>
		<title>Tuples for class value equality</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/18-tuple-equality" />
		<updated>2022-07-18T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;tuple&lt;/code&gt; can be used to check the &lt;code&gt;value equality&lt;/code&gt; of two instances of the same class.&lt;/p&gt;
&lt;p&gt;When comparing classes, the equality operator (&lt;code&gt;==&lt;/code&gt;) will check that the two instances are actually the same instance, not that the values of the two instances are the same. There are a &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type"&gt;number of different techniques&lt;/a&gt; to define value equality for a class, but they all ultimately have the same underlying logic - each property of the instances being compared need to individually be compared.&lt;/p&gt;
&lt;p&gt;The usage of &lt;code&gt;tuples&lt;/code&gt; can be used to simplify this comparison.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In this post we will be using a &lt;code&gt;Song&lt;/code&gt; class, which has three properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Name { get; init; }

    public string Artist { get; init; }

    public int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For two &lt;em&gt;Song&lt;/em&gt; instances to be equal, each of the three properties for the two instances need to be equal.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="equality"&gt;Equality&lt;/h2&gt;
&lt;h3 id="equality-operator"&gt;Equality operator&lt;/h3&gt;
&lt;p&gt;As mentioned above, using the default equality operator for classes will test if the two instances are actually the same instance, not check the values of the two instances:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
// two Song instances, both with the same values
var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    Name = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

var song1 = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    Name = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

// a 3rd instance, set to the first instance
var song2 = song;

// comparing two different instances
Console.WriteLine(song == song1);
// comparing two instances, which are the &amp;quot;same&amp;quot; instance
Console.WriteLine(song == song2);

// comparing two different instances
Console.WriteLine(song.Equals(song1));
// comparing two instances, which are the &amp;quot;same&amp;quot; instance
Console.WriteLine(song.Equals(song2));

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;False
True
False
True
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-comparison"&gt;Manual comparison&lt;/h3&gt;
&lt;p&gt;To compare a value comparison of the two classes (instead of using one of &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type"&gt;these techniques&lt;/a&gt;) we are going to write a method to do the comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;bool Compare(Song s1, Song s2) =&amp;gt;
    s1.Artist == s2.Artist &amp;amp;&amp;amp; // compare artist
    s1.Name == s2.Name &amp;amp;&amp;amp;  // and Name
    s1.LengthInSeconds == s2.LengthInSeconds; // and song Length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Only if all three properties are equal, are the two instances equal:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(Compare(song, song1));
Console.WriteLine(Compare(song, song2));
Console.WriteLine(Compare(song1, song2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;True
True
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above will function correctly, adequately doing a value comparison of the two instance - however a simpler and cleaner technique is to use a &lt;code&gt;tuple&lt;/code&gt; for the value comparison.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tuple-equality"&gt;Tuple equality&lt;/h3&gt;
&lt;p&gt;One feature of the &lt;code&gt;Tuple&lt;/code&gt; is that using the equality operator on it &lt;strong&gt;does&lt;/strong&gt; compare the values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var tuple = (1, 2, 3);
var tuple1 = (1, 2, 3);

Console.WriteLine(tuple == tuple1);
Console.WriteLine(tuple.Equals(tuple1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;True
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This fact can be leverage to compare two class instances by &lt;code&gt;creating tuples with the class values, and then comparing the tuples!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tuple-comparison"&gt;Tuple comparison&lt;/h3&gt;
&lt;p&gt;If we rework the &lt;em&gt;Compare&lt;/em&gt; method defined above, to use a &lt;code&gt;Tuple&lt;/code&gt; instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Use the properties of each instance to create a tuple
// and compare the two tuples
bool CompareTuple(Song s1, Song s2) =&amp;gt;
    (s1.Artist, s1.Name, s1.LengthInSeconds) == (s2.Artist, s2.Name, s2.LengthInSeconds);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the same comparisons as above using the new method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(CompareTuple(song, song1));
Console.WriteLine(CompareTuple(song, song2));
Console.WriteLine(CompareTuple(song1, song1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yields the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;True
True
True
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the results of the two methods are the same, the tuple version is more &lt;em&gt;concise, cleaner and less prone to developer error&lt;/em&gt;, especially if there are a large number of fields being compare.&lt;/p&gt;
&lt;p&gt;The tuple method can also be used in conjunction with the &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type"&gt;techniques already mentioned&lt;/a&gt; - for example by overriding the &lt;em&gt;equals operator&lt;/em&gt; (==) and performing the tuples equality check in that method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=aUbXGs7YTGo&amp;amp;t=569s"&gt;Change your habits: Modern techniques for modern C# - Bill Wagner&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;118: 18-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/15-testing-protected</id>
		<title>Unit testing a protected method</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/15-testing-protected" />
		<updated>2022-07-15T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;To unit test a &lt;code&gt;protected&lt;/code&gt; method of a class, inheritance and a public method wrapper can be used.&lt;/p&gt;
&lt;p&gt;Consider a class, (called, for example, &lt;em&gt;CustomClass&lt;/em&gt;) with a protected member - a &lt;em&gt;test&lt;/em&gt; class (&lt;em&gt;TestCustomClass&lt;/em&gt;) can be created which inherits from &lt;em&gt;CustomClass&lt;/em&gt; Then a public wrapper method created on &lt;em&gt;TestCustomClass&lt;/em&gt; can be created, which in turn invokes the &lt;code&gt;protected&lt;/code&gt; method on &lt;em&gt;CustomClass&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This pattern enables the &lt;code&gt;protected&lt;/code&gt; member to be accessed and tested through the &lt;em&gt;public test wrapper&lt;/em&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="protected-keyword"&gt;Protected keyword&lt;/h2&gt;
&lt;p&gt;A quick recap of the &lt;code&gt;protected&lt;/code&gt; keyword - a &lt;code&gt;protected member is accessible within its class and by derived class instances&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For testing, the &lt;code&gt;&amp;quot;&amp;quot;derived class instance&amp;quot;&amp;quot;&lt;/code&gt; is the relevent and important piece of information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;We have a library which performs some business logic, some of it &lt;code&gt;publicly&lt;/code&gt; exposed, and some of it &lt;code&gt;protected&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace CustomLibrary;

public class CustomClass
{
    public int PerformPublicLibraryLogic()
    {
        // do some processing
        return 0;
    }

    protected int PerformProtectedLibraryLogic()
    {
        // do processing
        return 0;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to unit test these two methods, so a separate test project is created (a &lt;em&gt;MSTest&lt;/em&gt; test project in this example):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace CustomApplication.UnitTest;

[TestClass]
public class CustomLibraryUnitTests
{
    [TestMethod]
    // Tests the public method
    public void TestPublic()
    {
        // create an instance and call the public method
        var customclass = new CustomClass();
        var result = customclass.PerformPublicLibraryLogic();

        // check the results
        Assert.AreEqual(0, result);
    }

    [TestMethod]
    // Try test the protected method
    public void TestProtectedBroken()
    {
        var customclass = new CustomClass();
        // THIS WILL NOT COMPILE
        // PerformProtectedLibraryLogic is not accessible
        var result = customclass.PerformProtectedLibraryLogic();
        
        Assert.AreEqual(0, result);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code will &lt;code&gt;NOT compile&lt;/code&gt;, as the &lt;em&gt;PerformProtectedLibraryLogic&lt;/em&gt; is &lt;code&gt;not accessible from the test project&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;p&gt;As mentioned above, the important piece of information related to the &lt;code&gt;protected&lt;/code&gt; keyword, is that a protected member is accessible from a &lt;code&gt;derived class instance&lt;/code&gt; - so let's create a derived class.&lt;/p&gt;
&lt;p&gt;In the test project:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace CustomApplication.UnitTest;

// inherit from the class in question
public class TestCustomClass : CustomClass
{
    // create a public method, which wraps the protected method
    public int WrappedPerformProtectedLibraryLogic()
    {
        // as this code is inside a derived class, it has accessibility
        // to the PerformProtectedLibraryLogic method
        return PerformProtectedLibraryLogic();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of testing the protected method on the &lt;em&gt;CustomClass&lt;/em&gt; directly, it can now be tested through &lt;em&gt;public&lt;/em&gt; method on &lt;em&gt;TestCustomClass&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TestMethod]
// Tests the protected method
public void TestProtectedWorking()
{
    // used the TestCustomClass instead of CustomClass 
    var customclass = new TestCustomClass();
    // invoke the wrapper method
    var result = customclass.WrappedPerformProtectedLibraryLogic();

    Assert.AreEqual(0, result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What's important here is that the &lt;em&gt;TestCustomClass&lt;/em&gt; and &lt;em&gt;wrapper method&lt;/em&gt; &lt;code&gt;add no additional logic or complexity&lt;/code&gt;. We do not want the test class to interfere with the goal of testing the underlying protected method.&lt;/p&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The technique mentioned here is not a ground-breaking revelation, but it is very useful. Personally, I've recently started writing more unit tests in earnest (after not having done any for 5+ years) this was one of the first issues I encountered, I had not experienced before, which needed to be solved.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;117: 15-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/07/14-dbcontext-pooling</id>
		<title>Entity Framework DbContext Pooling</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/07/14-dbcontext-pooling" />
		<updated>2022-07-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework Core's &lt;code&gt;DbContext pooling&lt;/code&gt; functionality can be used to improve the performance of an application.&lt;/p&gt;
&lt;p&gt;While generally a lightweight object, each context instance does require some internal setup of various services, which does have an overhead. &lt;code&gt;Context pooling&lt;/code&gt;, as the name implies, create a pool of DbContext instances, setup during startup of the application and reused, thus paying the setup cost only once.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="configuration"&gt;Configuration&lt;/h2&gt;
&lt;p&gt;Configuring an application to use &lt;code&gt;DbContext pooling&lt;/code&gt; instead of the non-pooling option is incredibly simple - in fact it requires just one small change to the usual DbContext setup.&lt;/p&gt;
&lt;p&gt;On startup of an application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Default non-pooling configuration&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDbContext&amp;lt;DemoContext&amp;gt;(o =&amp;gt; o
    .UseSqlServer(builder.Configuration.GetConnectionString(&amp;quot;DemoContext&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DbContext pooling configuration&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDbContextPool&amp;lt;DemoContext&amp;gt;(o =&amp;gt; o
    .UseSqlServer(builder.Configuration.GetConnectionString(&amp;quot;DemoContext&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead of the &lt;code&gt;AddDbContext&lt;/code&gt; method being called, the &lt;code&gt;AddDbContextPool&lt;/code&gt; method is called - thats all the configuration required.&lt;/p&gt;
&lt;p&gt;The default pool size can also be manually specified as part of the &lt;em&gt;AddDbContextPool&lt;/em&gt; call (with the default being 1024 in EF Core 6.0 and 128 in previous versions)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage is &lt;code&gt;exactly the same&lt;/code&gt; awith our without the context pooling - inject the application &lt;em&gt;DbContext&lt;/em&gt; (DemoContext in the above examples) into the relevent constructor and use it as per normal.&lt;/p&gt;
&lt;p&gt;Entity Framework will internally handle everything related to the pooling functionality.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;For the benchmarks, we have a database table with &lt;code&gt;50&lt;/code&gt; records, and will be comparing retrieving a single row (using the primary key) using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Manually created &lt;code&gt;DbContext&lt;/code&gt; instance each time&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;DbContext&lt;/code&gt; retrieved from the context pool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the below code, as dependency injection was not used, &lt;code&gt;PooledDbContextFactory&lt;/code&gt; is used to control getting an instance of a DbContext from the pool:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
private DbContextOptions&amp;lt;DemoContext&amp;gt; _options;
private PooledDbContextFactory&amp;lt;DemoContext&amp;gt; _poolingFactory;

public Benchmarks()
{
    // confiture the dbcontext options
    _options = new DbContextOptionsBuilder&amp;lt;DemoContext&amp;gt;()
        .UseSqlServer(&amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFPool;Integrated Security=True&amp;quot;)
        .Options;

    // setup the pooling factory using the options
    _poolingFactory = new PooledDbContextFactory&amp;lt;DemoContext&amp;gt;(_options);
}

[Benchmark]
public Song WithoutContextPooling()
{
    // new DbContext using the options
    using var context = new DemoContext(_options);

    return context.Songs.First(s =&amp;gt; s.Id == 1);
}

[Benchmark]
public Song WithContextPooling()
{
    // new DbContext using the PooledDbContextFactory which uses the options
    using var context = _poolingFactory.CreateDbContext();

    return context.Songs.First(s =&amp;gt; s.Id == 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;WithoutContextPooling&lt;/td&gt;
&lt;td style="text-align: right;"&gt;701.3 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.09 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;147.42 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;96 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithContextPooling&lt;/td&gt;
&lt;td style="text-align: right;"&gt;124.9 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.15 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.02 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.4648&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;context pooling results in a 5.5x speed improvement&lt;/code&gt; and &lt;code&gt;10x memory improvement!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Improvements such as the ones shown above in the benchmarks above might not be applicable in every application and use case - however my recommendation is to &lt;code&gt;default to using DbContext pooling&lt;/code&gt;. If performance is not where it should be, then benchmark the two options and revert to the option with the best performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/ef/core/performance/advanced-performance-topics?tabs=with-di%2Cwith-constant#dbcontext-pooling"&gt;DbContext pooling&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;116: 14-07-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>