<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://alwaysdeveloping.net/</id>
	<title />
	<link rel="self" href="https://alwaysdeveloping.net/" />
	<rights>Copyright © 2023</rights>
	<updated>2023-01-06T03:38:27Z</updated>
	<subtitle>always learning | always growing</subtitle>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/06-linq-distinct</id>
		<title>LINQ DistinctBy</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/06-linq-distinct" />
		<updated>2023-01-06T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;Enumerable&lt;/em&gt; &lt;code&gt;DistinctBy&lt;/code&gt; method, introduced in .NET 6, can be used to return &lt;em&gt;distinct elements from a sequence according to the specified key selector&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Prior to .NET 6, performing this operation was a bit complex, but the introduction of the &lt;code&gt;DistinctBy&lt;/code&gt; method simplifies the process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In this example, a collection of 3 &lt;em&gt;Songs&lt;/em&gt; will be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;Song&amp;gt; songs = new List&amp;lt;Song&amp;gt;
{
    new Song
    {
        Id = 1,
        Name = &amp;quot;Everlong&amp;quot;,
        Album = &amp;quot;The Colour and the Shape&amp;quot;
    },
    new Song
    {
        Id = 2,
        Name = &amp;quot;Monkey Wrench&amp;quot;,
        Album = &amp;quot;The Colour and the Shape&amp;quot;
    }
    ,
    new Song
    {
        Id = 3,
        Name = &amp;quot;Learn to Fly&amp;quot;,
        Album = &amp;quot;There Is Nothing Left to Lose&amp;quot;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's look at how we can get a &lt;em&gt;distinct list of albums from the collection of songs&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre.net-6"&gt;Pre .NET 6&lt;/h2&gt;
&lt;p&gt;The process for doing this (using LINQ) prior to .NET 6 was as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; albums = songs
    .GroupBy(s =&amp;gt; s.Album)
    .Select(g =&amp;gt; g.First())
    .Select(a =&amp;gt; a.Album);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The steps are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;GroupBy&lt;/strong&gt; to get a collection of &lt;em&gt;Songs&lt;/em&gt;, with the &lt;em&gt;Album&lt;/em&gt; value as the key&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; and &lt;strong&gt;First&lt;/strong&gt; to get the first record in each group&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; to get the &lt;em&gt;Album&lt;/em&gt; of the first record&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the &lt;em&gt;Songs&lt;/em&gt; in each group will all contain the same &lt;em&gt;Album&lt;/em&gt; (as we are grouping by Album), selecting any record will yield the same Album.&lt;/p&gt;
&lt;p&gt;This works, but is a fairly convoluted process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-6-and-beyond"&gt;.NET 6 and beyond&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;DistinctBy&lt;/code&gt; method greatly simplifies this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; albums = songs
    .DistinctBy(s =&amp;gt; s.Album)
    .Select(a =&amp;gt; a.Album);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the steps are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;DistinctBy&lt;/strong&gt; to get a collection of &lt;em&gt;Songs&lt;/em&gt;, each one having a &lt;em&gt;unique Album value&lt;/em&gt;. In this example, after this is executed, the record with &lt;em&gt;id = 2&lt;/em&gt; is dropped from the collection as it has the same &lt;em&gt;Album&lt;/em&gt; value as thew previous record&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;Select&lt;/strong&gt; to get the &lt;em&gt;Album&lt;/em&gt; of each of the remaining records&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Easier to read and less convoluted!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The addition of the new &lt;code&gt;DistinctBy&lt;/code&gt; makes a big difference to the complexity, as well as the readability of the code - instead of trying to decider some &lt;em&gt;complex&lt;/em&gt; LINQ (as was the case prior to .NET 6), the code now better describes what it is actually doing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/zpjpst/do_you_know_about_the_distinctby_method/"&gt;Do you know about the DistinctBy method?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;229: 06-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/05-new-stopwatch</id>
		<title>Efficient Stopwatch usage</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/05-new-stopwatch" />
		<updated>2023-01-05T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET 7 introduced new &lt;code&gt;StopWatch&lt;/code&gt; functionality, which not only makes using the class easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="typical-usage"&gt;Typical usage&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;StopWatch&lt;/code&gt; class is often used to perform simple benchmarks to determine how long a piece of code executes for. The &lt;em&gt;StopWatch&lt;/em&gt; is started, the code in question is executed, and then the &lt;em&gt;StopWatch&lt;/em&gt; is stopped and the ElapsedTime is captured.&lt;/p&gt;
&lt;p&gt;Typically the &lt;code&gt;StopWatch&lt;/code&gt; class is used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// new instance of Stopwatch
Stopwatch sw = new Stopwatch();
sw.Start();

await Task.Delay(500);

sw.Stop();
Console.WriteLine($&amp;quot;Time Elapsed: {sw.Elapsed}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="improved-usage"&gt;Improved usage&lt;/h2&gt;
&lt;p&gt;The issue with the above is that memory is allocated for the &lt;em&gt;StopWatch&lt;/em&gt; instance declared. Instead, a more memory efficient approach is to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the start time (in ticks)
long startTime = Stopwatch.GetTimestamp();

await Task.Delay(500);

// get the end time (in ticks)
long endTime = Stopwatch.GetTimestamp();
// calculate the difference
TimeSpan elapsedTime = new TimeSpan(endTime - startTime);
Console.WriteLine($&amp;quot;Time Elapsed: {elapsedTime}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No memory is allocated in this example, but it is slightly more complex to code than the previous example.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="net-7-improvements"&gt;.NET 7 improvements&lt;/h2&gt;
&lt;p&gt;A new method, &lt;code&gt;Stopwatch.GetElapsedTime&lt;/code&gt;,  was introduced with .NET 7 which makes the above approach simpler:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the start time (in ticks)
long startTime = Stopwatch.GetTimestamp();

await Task.Delay(500);

// get the elapsed time between the startTime and the currentTime
TimeSpace elapsedTime = Stopwatch.GetElapsedTime(startTime);
Console.WriteLine($&amp;quot;Time Elapsed: {elapsedTime}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;GetElapsedTime&lt;/code&gt; method will calculate the elapsed time between the &lt;em&gt;startTime&lt;/em&gt; and the &lt;em&gt;current time&lt;/em&gt; (it is also possible to explicitly supply an &lt;em&gt;endTime&lt;/em&gt; to the method as well).&lt;/p&gt;
&lt;p&gt;Here we get the benefit of less memory allocations, and also not having to do additional calculations.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, useful new method which makes using &lt;code&gt;StopWatch&lt;/code&gt; cleaner and more efficient overall - one doesn't want diagnostic tools to be detrimental to the performance and readability of the application code.
Having said that, having a single StopWatch instance should really not impact application performance at all - however its always a good practice to be as efficient as possible, traded off with effort, and in this case, there is no additional effort required to be slightly more efficient.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=NTz99yN2urc"&gt;Are you using the Stopwatch efficiently in .NET?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;228: 05-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/04-multi-attributes</id>
		<title>Combining multiple attributes</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/04-multi-attributes" />
		<updated>2023-01-04T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple attributes are applied to a program entity, the attributes can either be &lt;code&gt;specified on separate lines, or on a single line&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiline"&gt;Multiline&lt;/h2&gt;
&lt;p&gt;In this example, a &lt;em&gt;class&lt;/em&gt; is used to demonstrate an entity having multiple attributes, but the same applies to other relevent program entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Serializable]
[Obsolete]
[DebuggerDisplay(&amp;quot;Id={Id}, Name={Name}&amp;quot;)]
public class MultiAttributeClass
{
    public int Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Three attributes added to the class - the actual attributes themselves are not important, it could be been any number of any attributes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-line"&gt;Single line&lt;/h2&gt;
&lt;p&gt;The multiple attributes can also be applied as follows though:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Serializable, Obsolete, DebuggerDisplay(&amp;quot;Id={Id}, Name={Name}&amp;quot;)]
public class MultiAttributeClass
{
    public int Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Does this reduce the number of lines in code? Yes
Does it make it more difficult to read? Potentially
Is this recommended? Probably not. But you can if you want&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very small knowledge drop today, but something I was not aware was possible. As mentioned, as a general rule I would argue this make the code slightly less readable - however, some might find this code cleaner and more readable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/zk8oyj/did_you_know_you_could_combine_method_or_class/"&gt;Reddit Post&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;227: 04-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/03-ef-value-converter</id>
		<title>Converting values with EF</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/03-ef-value-converter" />
		<updated>2023-01-03T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;An EntityFramework &lt;code&gt;ValueConverter&lt;/code&gt; can be used to convert a property from one value or type to another when reading to and writing from the database.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the example, the C# class has a &lt;code&gt;DateTime&lt;/code&gt; property, however when saved in the database, this property will be stored as a &lt;code&gt;long&lt;/code&gt; (BIGINT in SQL) - a value representing the &lt;em&gt;DateTime as ticks&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="scaffolding"&gt;Scaffolding&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;Blog&lt;/em&gt; class looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table("Blog")]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the &lt;em&gt;DateCreated&lt;/em&gt; is of type &lt;code&gt;DateTime&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;DBContext&lt;/em&gt; implementation is configured as per usual:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            @"Server=.\SQLEXPRESS;Database=ValueConverter;Integrated Security=True;TrustServerCertificate=True");
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="definition"&gt;Definition&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;code&gt;ValueConverter&lt;/code&gt; - this is done by inheriting from &lt;code&gt;ValueConverter&amp;lt;TModel, TProvider&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The converter defined below will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Provide functionality to convert from &lt;em&gt;DateTime&lt;/em&gt; to &lt;em&gt;long&lt;/em&gt; when writing to the database&lt;/li&gt;
&lt;li&gt;Provide functionality to convert from &lt;em&gt;long&lt;/em&gt; to &lt;em&gt;DateTime&lt;/em&gt; when reading from the database&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal class DateCreatedConverter : ValueConverter&amp;lt;DateTime, long&amp;gt;
{
    // constructor calls into the base constructor
    // with the two methods to do the conversion
    public DateCreatedConverter()
    : base(modelValue =&amp;gt; ToTicks(modelValue), 
        provValue =&amp;gt; ToDateTime(provValue)) { }

    // convert a long to DateTime - for when reading
    // from the database
    private static DateTime ToDateTime(long ticks)
    {
        return new DateTime(ticks);
    }

    // convert a DateTime to long - for when writing
    // do the database
    private static long ToTicks(DateTime datetime)
    {
        return datetime.Ticks;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The base &lt;code&gt;ValueConverter&amp;lt;DateTime, long&amp;gt;&lt;/code&gt; constructor takes two parameters - two &lt;em&gt;Expressions&lt;/em&gt; for doing the conversion between the values. Our class defines two methods defining the logic for how the conversion is to the happen, and then passes these methods to the &lt;em&gt;base constructor&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The same blueprint can be used to define more complex conversions between property values.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="registration"&gt;Registration&lt;/h3&gt;
&lt;p&gt;Now that we have the converter defined, the next step is to register it with the Entity Framework infrastructure. This is done either in an &lt;code&gt;IEntityTypeConfiguration&lt;/code&gt; implementation for the specific entity, or in this example, in the &lt;em&gt;OnModelCreating&lt;/em&gt; method of the DbContext:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            @"Server=.\SQLEXPRESS;Database=ValueConverter;Integrated Security=True;TrustServerCertificate=True");
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // define that the specific property 
        // on the specific entity has the converter
        modelBuilder.Entity&amp;lt;Blog&amp;gt;()
            .Property(b =&amp;gt; b.DateCreated)
            .HasConversion&amp;lt;DateCreatedConverter&amp;gt;();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the specific &lt;em&gt;property&lt;/em&gt; on the specific &lt;em&gt;entity&lt;/em&gt; is specified to have the converter.&lt;/p&gt;
&lt;p&gt;That's all there is to it! Entity Framework will now &lt;code&gt;automatically apply the conversion when reading to and writing from the database&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;When interacting with the database using Entity Framework, the &lt;code&gt;ValueConverter&lt;/code&gt; is automatically used. This includes when creating the table based on the entity schema:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Blog blog = new Blog
{
    Id = 1,
    Title = "My first post",
    Description = "My very first blog ever!",
    DateCreated = DateTime.Now,
};

DemoContext context = new DemoContext();
context.Database.EnsureCreated();
await context.Blogs.AddAsync(blog);
await context.SaveChangesAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we look at the data in the database, the &lt;em&gt;DateCreated&lt;/em&gt; property is stored as a BIGINT (the SQL equivalent of a long):&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/database.png" alt="Conversion in the database"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful feature when needing to convert data/value types between code and the database - some relatively simple configuration, and Entity Framework takes care of the rest.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://shadynagy.com/value-converters-efcore/"&gt;Value converters in Entity Framework Code (EF Core)&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;226: 03-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2023/01/02-exception-helpers</id>
		<title>.NET 8 Exception helpers</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2023/01/02-exception-helpers" />
		<updated>2023-01-02T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A number of &lt;em&gt;helper&lt;/em&gt; methods are being introduced with .NET 8, which make the process of &lt;code&gt;checking values and throwing exception&lt;/code&gt; a lot simpler.&lt;/p&gt;
&lt;p&gt;Keep in mind .NET 8 is in pre-release, so the functionality could potentially change or be removed before the final .NET8 release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="existing-helper"&gt;Existing helper&lt;/h2&gt;
&lt;p&gt;An example of an existing (prior to .NET 8) exception helper method, is the &lt;code&gt;ArgumentException.ThrowIfNullOrEmpty&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;Instead of having to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ManualThrowException(string strParam)
{
    if (string.IsNullOrEmpty(strParam))
    {
        throw new Exception($&amp;quot;{nameof(strParam)} is null or empty&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ThrowIfNullOrEmpty&lt;/code&gt; method can be used, which checks the value of the parameter and throws the exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ThrowNullOrEmptyException(string strParam)
{
    ArgumentException.ThrowIfNullOrEmpty(strParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="new-helpers"&gt;New helpers&lt;/h2&gt;
&lt;p&gt;There are a number of new static helper methods (on &lt;em&gt;ArgumentOutOfRangeException&lt;/em&gt;) being introduced, which include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ThrowIfZero&lt;/li&gt;
&lt;li&gt;ThrowIfNegative&lt;/li&gt;
&lt;li&gt;ThrowIfNegativeOrZero&lt;/li&gt;
&lt;li&gt;ThrowIfGreaterThan&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The usage and functionality of these are the same as &lt;code&gt;ThrowIfNullOrEmpty&lt;/code&gt; - the parameter is checked, and an exception is throw if the check fails.&lt;/p&gt;
&lt;p&gt;To check if a int value is &lt;em&gt;zero or negative&lt;/em&gt;, instead of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ManualThrowZeroNegativeException(int intParam)
{
    if (intParam &amp;lt;= 0)
    {
        throw new Exception($&amp;quot;{nameof(intParam)} is less than or equal to zero&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void EnhancedThrowZeroNegativeException(int intParam)
{
    ArgumentOutOfRangeException.ThrowIfNegative(intParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If thrown, the exception generated is also more informative than before, including the parameter name in the exception text:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'intParam' must be a non-negative value.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result - more readable code, and quicker and easier for a developer to thrown an exception.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small and simple helper method update - but one will facilitate cleaner, simpler and more readable code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/f4bc6fcc-5691-4f72-b9bb-75aeeb59230a"&gt;New ArgumentException and ArgumentOutOfRangeException helpers in .NET 8&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;225: 02-01-2023&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions</id>
		<title>Entity Framework conventions</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions" />
		<updated>2022-12-16T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework comes out of the box with a number of default &lt;em&gt;conventions&lt;/em&gt; - however &lt;code&gt;new conventions can easily be added&lt;/code&gt; to an application specific EF configuration to customize how Entity Framework operates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;By default, when a &lt;code&gt;string&lt;/code&gt; property on an entity is mapped to a SQL database column, it will be generated as &lt;code&gt;nvarchar(max)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the DbContext configuration, some additional logging for demo purposes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=ConfigConventions;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

        // enable additional logging for demo purposes
        optionsBuilder.EnableSensitiveDataLogging(true);
        optionsBuilder.LogTo((string query) =&amp;gt;
        {
            Console.WriteLine(query);
        }, LogLevel.Information);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;CREATE TABLE SQL&lt;/em&gt; generated is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(max) NOT NULL,
    [Description] nvarchar(max) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the default for C# properties of type &lt;code&gt;string&lt;/code&gt; is &lt;code&gt;nvarchar(max)&lt;/code&gt; - next we'll go through the various steps to change the convention for &lt;em&gt;non-explicitly set string&lt;/em&gt; properties from &lt;code&gt;nvarchar(max)&lt;/code&gt; to &lt;code&gt;nvarchar(256)&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-definition"&gt;Convention definition&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;em&gt;convention&lt;/em&gt; to change the default string length. This is achieved by implementing the &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; interface (which inherits the &lt;code&gt;IConvention&lt;/code&gt; interface). The &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; implementations, as the name suggests, are executed once the model has mostly been built (using the built-in and other custom conventions), and is being &lt;em&gt;finalized&lt;/em&gt;. This is the &amp;quot;safest&amp;quot; time to execute custom conventions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MaxStringLengthConvention : IModelFinalizingConvention
{
    private readonly int _maxLength;

    public MaxStringLengthConvention(int maxLength)
	{
        this._maxLength = maxLength;
    }

    // implement the only method on the interface
    public void ProcessModelFinalizing(IConventionModelBuilder modelBuilder, 
        IConventionContext&amp;lt;IConventionModelBuilder&amp;gt; context)
    {
        // iterate through each type defined in the EF model
        // and through each property and check if a string
        foreach (var property in modelBuilder.Metadata.GetEntityTypes()
                     .SelectMany(entityType =&amp;gt; entityType.GetDeclaredProperties()
                                    .Where( property =&amp;gt; property.ClrType == typeof(string))))
        {
            // set the max length based on the value passed in
            property.Builder.HasMaxLength(_maxLength);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The implementation for this convention effectively checks &lt;em&gt;each type&lt;/em&gt; and &lt;em&gt;each property&lt;/em&gt; on the type to see if it is of type &lt;em&gt;string&lt;/em&gt; - if so, the max length is set based on the max length specified on initialization.&lt;/p&gt;
&lt;p&gt;Now to register the newly created convention!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-configuration"&gt;Convention configuration&lt;/h3&gt;
&lt;p&gt;The convention is required to be registered with Entity Framework - so EF knows to apply the convention to the model (adn when to apply it)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ConfigureConventions&lt;/code&gt; method is &lt;em&gt;overridden&lt;/em&gt; on the &lt;em&gt;DbContext&lt;/em&gt;, and the convention(s) registered:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    configurationBuilder.Conventions.Add(_ =&amp;gt; new MaxStringLengthConvention(256));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;With the convention configured, the SQL generated now looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(256) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All string properties/columns are set to have a length of 256 by default.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="explicitly-set-properties"&gt;Explicitly set properties&lt;/h3&gt;
&lt;p&gt;Entity Framework is smart enough to know that if the &lt;em&gt;max length&lt;/em&gt; has explicitly been set on a property/column, then the default length set by the convention will &lt;code&gt;not be applied&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the &lt;em&gt;Title&lt;/em&gt; property on the &lt;em&gt;Blog&lt;/em&gt; was set to have a max length of 500:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    [MaxLength(500)]
    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(500) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An explicitly defined max length on a property, takes precedence over the max length specified by the convention.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While all of the above could have been achieved by overwriting the &lt;code&gt;OnModelCreating&lt;/code&gt; method on the &lt;em&gt;DbContext&lt;/em&gt;, the conventions approach is more flexible and reusable. The conventions can be packaged and shared across teams in an enterprise to ensure consistent database standards.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=6apfe1L1FhY&amp;amp;t=2041s"&gt;.NET Data Community Standup - EF7 Custom Model Conventions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;224: 16-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/p/2022-12-holiday</id>
		<title>Holiday Break 2022</title>
		<link href="https://alwaysdeveloping.net/p/2022-12-holiday" />
		<updated>2022-12-16T01:00:00Z</updated>
		<content>&lt;h2 id="until-next-year"&gt;Until next year&lt;/h2&gt;
&lt;p&gt;Today will be the final Daily Drop post for 2022 - alwaysdeveloping.net is taking a break until the begining of January. The learning and growing will continue, just not the posts. Until next year!&lt;/p&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection</id>
		<title>.NET8 Frozen collection</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection" />
		<updated>2022-12-15T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET8 &lt;em&gt;potentially&lt;/em&gt; introduces a new collection type called a &lt;code&gt;Frozen collection&lt;/code&gt; - this post will explore the new collection, and see how to compares to existing collection implementations.&lt;/p&gt;
&lt;p&gt;As .NET8 is still currently in alpha, the &lt;code&gt;Frozen collection&lt;/code&gt; as well as any specific functionality it may offer could change before the final release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;To see how the &lt;code&gt;Frozen collection&lt;/code&gt; operates, below it is used along with other common collection implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create a base list of 10 items
List&amp;lt;int&amp;gt; baseList = Enumerable
    .Range(1, 10).ToList();

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

// now add another item to the list
baseList.Add(11);

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 11
ReadOnlyList count: 11
FrozenSet count: 10
ImmutableList count: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see, that when &lt;em&gt;adding an item to the underlying list&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;ReadOnlyList&lt;/code&gt; count also increases, as it is a readonly view into the underlying list&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt; count is &lt;em&gt;not increased&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what's the difference between the &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt;?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="set-vs-list"&gt;Set vs List&lt;/h2&gt;
&lt;p&gt;As per their name, the &lt;code&gt;FrozenSet&lt;/code&gt; is a &lt;em&gt;set&lt;/em&gt;, while the &lt;code&gt;ImmutableList&lt;/code&gt; is a &lt;em&gt;list&lt;/em&gt; - &lt;code&gt;a set cannot contain duplicates and is unordered&lt;/code&gt;, unlike a list. Consider the following code, similar to the previous example, but now with duplicate items:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
List&amp;lt;int&amp;gt; baseList = Enumerable.Range(1, 10)
    .ToList();
// add duplicate items to the base list
baseList.Add(1);
baseList.Add(2);
baseList.Add(3);

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 13
ReadOnlyList count: 13
FrozenSet count: 10
ImmutableList count: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 3 duplicate items are automatically removed when converting the base list to a set.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="another-collection-type"&gt;Another collection type&lt;/h2&gt;
&lt;p&gt;So why the need for another specialized collection type - &lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Steven Giesel&lt;/a&gt; benchmark's the performance of the &lt;code&gt;FrozenSet&lt;/code&gt; against other collection types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is substantially &lt;em&gt;quicker&lt;/em&gt; vs the other types when &lt;em&gt;performing a lookup&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;it is however &lt;em&gt;slower&lt;/em&gt; when creating the set vs creating the other types&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A new specialized collection type, which might not see every day use by the majority, but which, with the right use case, can improve the performance of the code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Frozen collections in .NET 8&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;223: 15-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query</id>
		<title>New HTTP methods</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query" />
		<updated>2022-12-14T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Standards have been published for a new HTTP method, &lt;code&gt;QUERY&lt;/code&gt;, which aims to effectively be a merge between the GET and POST methods.&lt;/p&gt;
&lt;p&gt;While this post will focus on handling the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, the same configuration and logic could be applied to any custom HTTP method (although not advised)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-need-for-query"&gt;The need for QUERY&lt;/h2&gt;
&lt;p&gt;First, a quick word on the need for the QUERY method. When using the GET method, all information to be passed to the server is contained in the URL as a &lt;em&gt;GET method does not have a body&lt;/em&gt;. The problem is that URL's have a finite length and when this limit is reached, often developers will switch to using a POST method which allows for more complex and lengthy information to be &lt;em&gt;passed in the body&lt;/em&gt;.
While this technique will work, the two different methods will generally have different caching mechanisms and a POST method may not offer the same performance as a GET method.&lt;/p&gt;
&lt;p&gt;The QUERY method aims to address this, by effectively providing a method which operates like the &amp;quot;GET&amp;quot; method, but which allows for a body to be posted to the server.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="defining-the-endpoint"&gt;Defining the endpoint&lt;/h2&gt;
&lt;p&gt;Defining an endpoint which uses a custom or new HTTP method is surprisingly easy - the &lt;code&gt;MapMethods&lt;/code&gt; method can be used, with a list of &lt;em&gt;httpMethods&lt;/em&gt; the endpoint supports:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define an endpoint with QUERY http method
app.MapMethods(&amp;quot;/query&amp;quot;, new[] { &amp;quot;QUERY&amp;quot; }, async (HttpContext context) =&amp;gt;
{
    string? text = null;
    var request = context.Request;

    // the body has to be read manually
    if (!request.Body.CanSeek)
    {
        request.EnableBuffering();
    }

    if (request.Body.CanRead)
    {
        // read the body as a stream, and then set the
        // reader position back to the start
        request.Body.Position = 0;
        var reader = new StreamReader(request.Body, Encoding.UTF8);
        text = await reader.ReadToEndAsync();
        request.Body.Position = 0;
    }

    // return the body
    return Results.Ok($&amp;quot;Querying data using body: {text}&amp;quot;);

})
// give the endpoint a name, just making it easier to 
// find later. Not required
.WithName(&amp;quot;query&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an endpoint &lt;code&gt;/query&lt;/code&gt; is defined, which uses the HTTP method &lt;code&gt;QUERY&lt;/code&gt;. The endpoint will read the contents of the body supplied with the HTTP request, and return it back to the caller.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;WithName&lt;/em&gt; method is used to name the endpoint, which will be used in the next step to easily build up the URL to be invoked - this is not strictly required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="calling-the-endpoint"&gt;Calling the endpoint&lt;/h2&gt;
&lt;p&gt;Calling the endpoint is a &lt;em&gt;little&lt;/em&gt; tricker, as the typical tools one might use (e.g. Postman) will not support the new or custom HTTP method. In this example, the C# HttpClient will be used to call the &lt;code&gt;QUERY&lt;/code&gt; endpoint - we are going to &lt;em&gt;create a GET endpoint, which will call the QUERY endpoint&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/callquery&amp;quot;, async (HttpContext context, 
    LinkGenerator generator) =&amp;gt;
{
    var client = new HttpClient();

    // set the http method as QUERY
    var request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;QUERY&amp;quot;),
        // get the URL by the name specified
        generator.GetUriByName(context, &amp;quot;query&amp;quot;, null)
    );

    // set the body of the QUERY call
    request.Content = new StringContent(&amp;quot;This is a body of a QUERY call&amp;quot;, 
        Encoding.UTF8, &amp;quot;text/plain&amp;quot;);

    // call the QUERY endpoint
    var response = client.Send(request);
    var result = await response.Content.ReadAsStringAsync();

    // the expected result should be the same 
    // as the body specified
    return result;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the &lt;code&gt;/callquery&lt;/code&gt; endpoint yields the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;&amp;quot;Querying data using body: This is a body of a QUERY call&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Success! We have successfully defined an endpoint which uses the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, which was successfully invoked with a body supplied.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="simplifying-the-code"&gt;Simplifying the code&lt;/h2&gt;
&lt;p&gt;The above is a very rough implementation of the &lt;code&gt;QUERY&lt;/code&gt; (or any custom HTTP method) implementation - in &lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Khalid Abuhakmeh's post&lt;/a&gt;, he has some good ways to simplify the code, and make it more generic. I suggest having a look at the techniques mentioned in his post on how to streamline the code for reuse.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful &lt;em&gt;experiment&lt;/em&gt; to see how support for any HTTP method support can be added relatively easily. There are limitation of custom HTTP methods - including the above mention support from 3rd party applications (Postman) as well as libraries (Swashbuckle), as well as limited or no support from caching or load balancing mechanisms.&lt;/p&gt;
&lt;p&gt;With reference to the &lt;code&gt;QUERY&lt;/code&gt; HTTP method - personally I like this, and will make sue of this, so I hope it does get adopted in the mainstream in future.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;222: 14-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
	<entry>
		<id>https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags</id>
		<title>EF tags and interceptors</title>
		<link href="https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags" />
		<updated>2022-12-13T01:00:00Z</updated>
		<content>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tags&lt;/code&gt;, in conjunction with an &lt;code&gt;IInterceptor&lt;/code&gt; implementation, can be used to intercept SQL commands before being executed on the database, and modify them to fix the tag requirements.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In the examples below, we are using DbContext setup the standard way, with a &lt;code&gt;Blog&lt;/code&gt; DbSet.&lt;/p&gt;
&lt;p&gt;As per normal, to get a list of all &lt;em&gt;Blogs&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var normalQuery = context.Blogs.ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll look at how to &lt;em&gt;tag&lt;/em&gt; the queries with a &lt;code&gt;nolock&lt;/code&gt; tag, and then how to &lt;em&gt;intercept&lt;/em&gt; the query, look presence of the &lt;em&gt;tag&lt;/em&gt;, and modify the query to include &lt;code&gt;nolock&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tagging-queries"&gt;Tagging queries&lt;/h3&gt;
&lt;p&gt;The first step is to &lt;em&gt;tag&lt;/em&gt; the query with the &lt;code&gt;nolock&lt;/code&gt; tag - this is relatively straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var nolockQuery = context
    .Blogs
    .TagWith(&amp;quot;Nolock&amp;quot;)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the generated SQL is inspected, one will see the query is now tagged as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 1 completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="interceptor"&gt;Interceptor&lt;/h3&gt;
&lt;p&gt;The next step is to &lt;em&gt;intercept&lt;/em&gt; the query before it's executed on the database and modify it - luckily this is also fairly straightforward, as Entity Framework has a built in mechanism for this.&lt;/p&gt;
&lt;p&gt;To create an &lt;em&gt;interceptor&lt;/em&gt; (in this example) all that is required is to inherit from &lt;code&gt;DbCommandInterceptor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inherit DbCommandInterceptor
public class NoLockInterceptor : DbCommandInterceptor
{
    // overwrite the ReaderExecuting method
    public override InterceptionResult&amp;lt;DbDataReader&amp;gt; ReaderExecuting(DbCommand command, 
        CommandEventData eventData, 
        InterceptionResult&amp;lt;DbDataReader&amp;gt; result)
    {
        // if the query generated by EF starts with &amp;quot;nolock&amp;quot;
        if(command.CommandText.StartsWith(&amp;quot;-- Nolock&amp;quot;, StringComparison.Ordinal))
        {
            // append &amp;quot;nolock&amp;quot; to the end
            command.CommandText += &amp;quot; (NOLOCK)&amp;quot;;
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ReaderExecuting&lt;/code&gt; method is executed before the query is about to be executed - in this method, the query is (crudely) checked to see if it has been &lt;em&gt;tagged&lt;/em&gt; for &lt;code&gt;nolock&lt;/code&gt;, and if so, the &lt;code&gt;NOLOCK&lt;/code&gt; keyword is added to the end of the query.&lt;/p&gt;
&lt;p&gt;This is very crude and only for demo purposes - it is not production ready. Ror example, this does not take into account any &lt;em&gt;WHERE&lt;/em&gt; statements in the SQL.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dbcontext"&gt;DbContext&lt;/h3&gt;
&lt;p&gt;Now that we have the &lt;em&gt;interceptor&lt;/em&gt; defined, the next step is to register it with EF.&lt;/p&gt;
&lt;p&gt;In this demo, this is done in the &lt;em&gt;OnConfiguring&lt;/em&gt; method of the &lt;code&gt;DbContext&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(
        &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFTagging;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

    // add the interceptor
    optionsBuilder.AddInterceptors(new NoLockInterceptor());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuration is now completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;When querying (without an predicate in this sample) and tagging the query, the &lt;code&gt;nolock&lt;/code&gt; keyword is automatically added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// query without tagging
var normalQuery = context.Blogs.ToList();

//query with the tag
var nolockQuery = context.Blogs.TagWith(&amp;quot;Nolock&amp;quot;).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated by the two queries.&lt;/p&gt;
&lt;p&gt;Without the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b] (NOLOCK)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful and interesting way to combine two EF features - the &lt;em&gt;tagging&lt;/em&gt; and &lt;em&gt;interception&lt;/em&gt; features. Manually modifying SQL generated by EF can be dangerous as there are a lot of options and variations to the SQL generated - so do it with caution and test extensively.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/DaveCallanIE/status/1599379983817879552"&gt;Dave Callan Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;221: 13-12-2022&lt;?#/ DailyDrop ?&gt;
</content>
		<summary>always learning | always growing</summary>
	</entry>
</feed>