<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>task on Always Developing</title><link>https://always-developing.github.io/tags/task/</link><description>Recent content in task on Always Developing</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Wed, 20 Apr 2022 01:00:00 +0200</lastBuildDate><atom:link href="https://always-developing.github.io/tags/task/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a task in a task</title><link>https://always-developing.github.io/dailydrop/2022/04/20-task-attachtoparent/</link><pubDate>Wed, 20 Apr 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/04/20-task-attachtoparent/</guid><description>Daily Knowledge Drop By default, when creating a child task from within a parent task, the child task has no dependency on the parent task - they are unrelated and will be run independently.
If a parent task is require to wait on the child task(s) to complete, then the TaskCreationOptions.AttachedToParent option is to be used when creating the child task.
Single Task First we&amp;rsquo;ll look at an example of just a single task being created:</description></item><item><title>Using Partitioner to improve parallel processing</title><link>https://always-developing.github.io/dailydrop/2022/04/14-partitioner/</link><pubDate>Thu, 14 Apr 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/04/14-partitioner/</guid><description>Daily Knowledge Drop When using Parallel.ForEach to execute tasks in parallel, it might be more performant to execute the tasks in parallel chucks (partitions), using the Partitioner functionality.
Performing tasks In all of the below examples, an array of 1000 sequential integers (starting at 0 all the way up to 999) is used. Each of the 1000 values are multiplied by itself and then stored in the corresponding location in the results array.</description></item><item><title>Interlocked vs using the lock keyword</title><link>https://always-developing.github.io/dailydrop/2022/04/05-interlocked/</link><pubDate>Tue, 05 Apr 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/04/05-interlocked/</guid><description>Daily Knowledge Drop Instead of using the lock keyword to block a portion of code from negative effects of multi-threading, the Interlocked class can be used instead to simplify the code.
Why even lock? So why would we need to even lock? consider the following example, regarding a bank account.
The bank account has a balance, and two methods to Deposit and Withdraw money from the account.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Account { public int Balance { get; set; } public void Deposit(int depositAmount) { Balance += depositAmount; } public void Withdraw(int withdrawAmount) { Balance -= withdrawAmount; } } The following code simulates a high volume number of transactions on the bank account - it loops for 10000 iterations in total, creating tasks to deposit $5 and to withdraw $5.</description></item><item><title>Task.WaitAsync in .NET6</title><link>https://always-developing.github.io/dailydrop/2022/02/16-task-wait-async/</link><pubDate>Wed, 16 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/16-task-wait-async/</guid><description>Daily Knowledge Drop A new method on Task called WaitAsync was introduced in .NET6. This method allows for waiting on a Task for a specific period of time before throwing a timeout exception.
On the surface, this might not seem very useful, but lets look at some examples to see how this new method can be leveraged.
The issue Long running processes Suppose we have a long running method which returns a Task - in the below example we are simulating a download process which takes 5 seconds</description></item></channel></rss>