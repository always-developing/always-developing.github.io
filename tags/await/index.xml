<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>await on Always Developing</title><link>https://always-developing.github.io/tags/await/</link><description>Recent content in await on Always Developing</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Wed, 16 Feb 2022 01:00:00 +0200</lastBuildDate><atom:link href="https://always-developing.github.io/tags/await/index.xml" rel="self" type="application/rss+xml"/><item><title>Task.WaitAsync in .NET6</title><link>https://always-developing.github.io/dailydrop/2022/02/16-task-wait-async/</link><pubDate>Wed, 16 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/16-task-wait-async/</guid><description>Daily Knowledge Drop A new method on Task called WaitAsync was introduced in .NET6. This method allows for waiting on a Task for a specific period of time before throwing a timeout exception.
On the surface, this might not seem very useful, but lets look at some examples to see how this new method can be leveraged.
The issue Long running processes Suppose we have a long running method which returns a Task - in the below example we are simulating a download process which takes 5 seconds</description></item></channel></rss>