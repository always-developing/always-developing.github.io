<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>performance on Always Developing</title><link>https://always-developing.github.io/tags/performance/</link><description>Recent content in performance on Always Developing</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Mon, 30 May 2022 01:00:00 +0200</lastBuildDate><atom:link href="https://always-developing.github.io/tags/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>LINQ First and Single performance</title><link>https://always-developing.github.io/dailydrop/2022/05/30-linq-first-performance/</link><pubDate>Mon, 30 May 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/05/30-linq-first-performance/</guid><description>Daily Knowledge Drop When using LINQ to retrieve a value from a collection, there are a number of different techniques - however not all are equal in terms of performance.
Today we&amp;rsquo;ll explore the various methods and their comparative performance.
First performance First, we&amp;rsquo;ll look at the various ways to retrieve a single value using variations of First, when multiple values match the condition:
1 2 3 4 5 6 7 8 9 10 11 // populate with 10000 values int[] values = values = Enumerable.</description></item><item><title>Sealed class performance</title><link>https://always-developing.github.io/dailydrop/2022/04/29-sealed-performance/</link><pubDate>Fri, 29 Apr 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/04/29-sealed-performance/</guid><description>Daily Knowledge Drop There are a number of situations in which performance gains can be had by marking a class as sealed.
Sealed class A sealed class is a class (marked with the sealed keyword) which cannot be inherited from. If the intention is to not have a class available for inheritance (probably the majority of classes by default) the class should be marked as sealed to prevent unwanted effects of it being inherited - but there is the benefit of some performance improvements.</description></item><item><title>Performant logging with LoggerMessageAttribute</title><link>https://always-developing.github.io/dailydrop/2022/02/09-logger-message-attribute/</link><pubDate>Wed, 09 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/09-logger-message-attribute/</guid><description>Daily Knowledge Drop .NET6 introduced a new attribute called LoggerMessageAttribute, which leverages source generators and is designed to deliver a highly useable and performant logging solution.
It works by using source generators, triggered at compile time by the presence of LoggerMessageAttribute to generate the additional source code. This solution, due to the compile time generation, is able to eliminate performance hits, such as boxing, temporary memory allocation as well as copies which enables it to be typically considerably faster than the existing run time logging methods.</description></item></channel></rss>