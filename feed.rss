<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Tue, 13 Sep 2022 05:09:20 GMT</pubDate>
		<lastBuildDate>Tue, 13 Sep 2022 05:09:20 GMT</lastBuildDate>
		<item>
			<title>Correlation using the Activity class</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</guid>
			<pubDate>Tue, 13 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with &lt;code&gt;distributed systems&lt;/code&gt;, the built in &lt;code&gt;Activity&lt;/code&gt; class can be used to automatically correlate requests across the various systems.&lt;/p&gt;
&lt;p&gt;For each unique request to an api (for example) a new activity root id is generated. If however, the specific api makes a call into another api, the activity root id is persisted across the http call, allowing the two calls to be linked together and related together when querying or reporting on the data.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-endpoint"&gt;Single endpoint&lt;/h2&gt;
&lt;p&gt;First, we'll look at how to get access to the &lt;code&gt;activity id&lt;/code&gt;. To do this we generate a simple minimal endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, (IHttpClientFactory httpFactory) =&amp;gt;
{
    // Output the root Id, and the current Id
     Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the static &lt;code&gt;Activity&lt;/code&gt; class is used, to access the &lt;em&gt;Current&lt;/em&gt; activity, and output the &lt;em&gt;Root Id&lt;/em&gt; as well as the &lt;em&gt;Id&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Calling the endpoint a few times, results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id: 319d4ff500ce3100c2a3017531e023e4 | Id: 00-319d4ff500ce3100c2a3017531e023e4-e4c21e8cfae4db47-00
Root Id: 7de97ec9692106503aaabab105951bdf | Id: 00-7de97ec9692106503aaabab105951bdf-fa3c7b807eda8800-00
Root Id: e1868729b9f3db8c40942ffb1daf24c9 | Id: 00-e1868729b9f3db8c40942ffb1daf24c9-79de739f0d38d58c-00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time the endpoint is invoked, and new &lt;em&gt;Root Id and Id&lt;/em&gt; is generated, with the &lt;em&gt;Id&lt;/em&gt; containing the &lt;em&gt;Root Id&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-endpoints"&gt;Multiple endpoints&lt;/h2&gt;
&lt;p&gt;Next, we define a second endpoint - for this example the second endpoint is defined in the same project as the first endpoint, but the exact same behavior would be experienced if the endpoint was contained in a separate application.&lt;/p&gt;
&lt;p&gt;This second endpoint will return it's &lt;em&gt;Root Id and Id&lt;/em&gt; as a string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint2&amp;quot;, () =&amp;gt;
{
    return $&amp;quot;Second Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Second Id: {Activity.Current.Id}&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we update the first endpoint to call the second endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
        Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    // call the second endpoint
    var client = httpFactory.CreateClient();
    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);

    // output the response (which contains the Id's)
    // from the second endpoint
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    Console.WriteLine(&amp;quot;------&amp;quot;);

    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when the first endpoint is called, we see the following (formatted to make it easier to compare):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        8f1e949168197f1185135e963eab68bc | Unit Id:   00-8f1e949168197f1185135e963eab68bc-2adc30476d372b95-00
Second Root Id: 8f1e949168197f1185135e963eab68bc | Second Id: 00-8f1e949168197f1185135e963eab68bc-d18ddb27c96b1a1b-00
------
Root Id:        2b39afb72f3773289d8d141b2ef030d4 | Unit Id:   00-2b39afb72f3773289d8d141b2ef030d4-77be0c303ee8028a-00
Second Root Id: 2b39afb72f3773289d8d141b2ef030d4 | Second Id: 00-2b39afb72f3773289d8d141b2ef030d4-66e8aa928caf5619-00
------
Root Id:        46d2eedeacdfe46a89888598886a5186 | Unit Id:   00-46d2eedeacdfe46a89888598886a5186-f7e42f6b6d868069-00
Second Root Id: 46d2eedeacdfe46a89888598886a5186 | Second Id: 00-46d2eedeacdfe46a89888598886a5186-1af4f5b27e45f9f7-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the &lt;code&gt;root id is the same across the http call&lt;/code&gt;, even though it is being returned from a separate endpoint in another service. The &lt;em&gt;Unit Id&lt;/em&gt; portion of the &lt;em&gt;Id&lt;/em&gt; changes though, indicating a smaller unit of work is being performed as part of the larger &lt;em&gt;root&lt;/em&gt; piece of work.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="child-activity"&gt;Child activity&lt;/h2&gt;
&lt;p&gt;We've seen how the the &lt;em&gt;Root Id&lt;/em&gt; is shared across http calls - now we look at how to get the same functionality when performing smaller units of work not involving http calls.&lt;/p&gt;
&lt;p&gt;Once again we update first endpoint, this time to start a child activity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
    Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    var client = httpFactory.CreateClient();

    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    
    // start with the child activity
    using var childActivity = new Activity(&amp;quot;MessagePublishing&amp;quot;);
    childActivity.Start();

    // a message is published to a message broker here, with the 
    // Id as metadata/correlationId
    Console.WriteLine($&amp;quot;Child Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Child Id: {Activity.Current.Id}&amp;quot;);

    childActivity.Stop();
    Console.WriteLine(&amp;quot;------&amp;quot;);

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here a child activity is manually started, and within the scope of the child activity - a message is published to a message broker (for example).&lt;/p&gt;
&lt;p&gt;Invoking the endpoint now results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        00a695a71d140a4105750a0cb04d9408 | Id:        00-00a695a71d140a4105750a0cb04d9408-4aba3488957c9a75-00
Second Root Id: 00a695a71d140a4105750a0cb04d9408 | Second Id: 00-00a695a71d140a4105750a0cb04d9408-e29b9eb28fe6d34f-00
Child Root Id:  00a695a71d140a4105750a0cb04d9408 | Child Id:  00-00a695a71d140a4105750a0cb04d9408-2a6e2ad5d7916142-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the above, we can see that manually declaring and &lt;em&gt;starting&lt;/em&gt; an activity will result in a &lt;em&gt;new Id&lt;/em&gt; to be generated, but using the same &lt;em&gt;Root Id&lt;/em&gt; as the parent.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="why-the-need"&gt;Why the need?&lt;/h2&gt;
&lt;p&gt;So why the need for a &lt;em&gt;Root Id&lt;/em&gt; and &lt;em&gt;correlation&lt;/em&gt; - all of this is to &lt;code&gt;gain better observability into how an application is performing&lt;/code&gt;. This data can be output and collected, either using industry standard tools and formatting (&lt;a href="https://opentelemetry.io/"&gt;for example OpenTelemetry&lt;/a&gt;), or by rolling our one's own reporting database - either way though, this provides insight into how each portion of a larger distributed transaction are linked together, and how each portion is performing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Distributed systems can become very complex, and observability is key in managing the stability and performance of the various systems - the &lt;code&gt;Activity&lt;/code&gt; class provides an easy, simple way to manage the correlation between the various systems and processes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.activity?view=net-6.0"&gt;Activity Class&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;159: 13-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Constructors with default values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</guid>
			<pubDate>Mon, 12 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Constructor and minimal api parameters&lt;/code&gt; can have &lt;code&gt;default values&lt;/code&gt;, allowing for dependency injection to work - while not actually working. Specifying a default value allows for the application to &lt;em&gt;run with a default implementation&lt;/em&gt; even if the services has not been registered with the dependency injection container.&lt;/p&gt;
&lt;p&gt;This is not something one would usually do as a standard practice, but in specific use cases it does have a place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;In the below examples, we have an interface, and a couple of implementations:&lt;/p&gt;
&lt;p&gt;The interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IDependencyInterface 
{
    string GetName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// a default implementation
public class DefaultImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(DefaultImplementation);
    }
}

// and another implementation
public class OtherImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(OtherImplementation);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="injection"&gt;Injection&lt;/h3&gt;
&lt;p&gt;Usually to make use of the functionality provided by the interface and the associated implementation, the service is registered with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Depending on the implementation the application requires:
builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
// OR
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then is injected into the relevent constructor, or minimal api delegate in the below sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// explicitly tell it to get the IDependencyInterface implementation
// from the DI service collection
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface injected) =&amp;gt;
{
    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="di-assumption"&gt;DI Assumption&lt;/h3&gt;
&lt;p&gt;In the above setup, the runtime assumes that the necessary registrations with the dependency injection container have take place. If neither of the following registrations are  done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when trying to inject &lt;em&gt;IDependencyInterface&lt;/em&gt;, the following error will be experienced:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;InvalidOperationException: No service for type 'IDependencyInterface' has been registered.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We've told the runtime and dependency injection container to &lt;em&gt;inject the IDependencyInterface implementation, but have not made it aware of any implementations!&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-value"&gt;Default value&lt;/h3&gt;
&lt;p&gt;Generally if in control of the entire dependency injection container registration, one should ensure that the required registrations are performed, and the error is resolved.&lt;/p&gt;
&lt;p&gt;However, in some cases this might not be possible - for example if developing a library package, there is no direct control over what the developer configures with the dependency injection container.&lt;br /&gt;
As a developer of the library package, one could just allow the exception to occur, which directs the developer to configure the dependency injection container correctly. Another, arguably more developer friendly technique, is to &lt;code&gt;automatically set a default implementation if one is not explicitly set&lt;/code&gt;. This does require a few updates to the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// make the parameter nullable, the default value will be null.
// In the case of a constructor (vs this minimal api delegate)
// the value can explicitly be set to null if desired:
// IDependencyInterface? injected = null
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface? injected) =&amp;gt;
{
    // if it is null, set it to the default implementation
    injected ??= new DefaultImplementation();

    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two changes are made to code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the parameter as &lt;code&gt;nullable&lt;/code&gt; using the &lt;code&gt;?&lt;/code&gt; operator&lt;/li&gt;
&lt;li&gt;Instantiate the parameter to the &lt;code&gt;default implementation&lt;/code&gt; if the value of the parameter is null&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now if &lt;code&gt;no implementation is registered&lt;/code&gt; for IDependencyInterface, the application will still function and use the &lt;code&gt;default implementation&lt;/code&gt; specified.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, this is not a practice which is generally recommended - however in the case of developing an external library (which requires a dependency), there is no guarantee the host application has injected the required dependencies. By making use of &lt;code&gt;default values&lt;/code&gt; the library will &lt;em&gt;still function with default configuration&lt;/em&gt;, but allows for &lt;code&gt;specific implementations to be overwritten&lt;/code&gt; by the developer if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/CFDevelop/status/1556055501661929472"&gt;Christian Findlay Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;158: 12-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Delay SQL execution with WAITFOR</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/09-sql-waitfor</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/09-sql-waitfor</guid>
			<pubDate>Fri, 09 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;SQL is a &lt;code&gt;WAITFOR&lt;/code&gt; command which an be used to delay the execution of a proceeding SQL statement. One of two options can be supplied to the &lt;code&gt;WAITFOR&lt;/code&gt; statement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TIME&lt;/code&gt;: waits until the  time of day specified before executing the next statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELAY&lt;/code&gt;: waits for the time span specified before executing the next statement&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-format"&gt;WAITFOR Format&lt;/h2&gt;
&lt;p&gt;The format and usage of &lt;code&gt;WAITFOR&lt;/code&gt; is straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;WAITFOR DELAY 'time_to_pass' | TIME 'time_to_execute'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-delay"&gt;WAITFOR DELAY&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WAITFOR DELAY&lt;/code&gt; will wait the &lt;code&gt;specified time span&lt;/code&gt; before executing the next command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO

WAITFOR DELAY '00:00:05';
GO

PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-09-08 20:39:51.2166773
2022-09-08 20:39:56.2387040

Completion time: 2022-09-08T20:39:56.2397037+02:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A time span between &lt;code&gt;00:00:00.001&lt;/code&gt; and &lt;code&gt;23:59:59.998&lt;/code&gt; can be specified - anything longer will result in an error.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-time"&gt;WAITFOR TIME&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WAITFOR TIME&lt;/code&gt; will wait until the &lt;code&gt;specified time of day&lt;/code&gt; before executing the next command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO

WAITFOR TIME '20:47:00';
GO

PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-08-15 20:46:48.9212859
2022-08-15 20:47:00.0130443

Completion time: 2022-08-15T20:47:00.0140433+02:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we only had to wait &lt;em&gt;12 seconds&lt;/em&gt;, but the wait could be longer depending on the time specified. Only a &lt;code&gt;time can be specified, not a particular date&lt;/code&gt;. If the next execution of the specified time is the following day, the wait until the time is reached the following day.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scheduling"&gt;Scheduling&lt;/h2&gt;
&lt;p&gt;The below is an &lt;em&gt;example&lt;/em&gt; of how the functionality can be used to executing a command on a specific schedule. This technique is used for demo purposes not necessarily recommended for a production use case.&lt;/p&gt;
&lt;p&gt;The following will execute the command every second for a full minute, once a day:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- wait until a specific time
WAITFOR TIME '20:52:00';
GO

-- while it is the 53th minute
WHILE(DATEPART(MINUTE, GETDATE()) &amp;lt; 54)
BEGIN
        -- print out the date time
	BEGIN
		PRINT CONVERT(varchar, SYSDATETIME(), 121)
	END

        -- wait for 1 second
	BEGIN
		WAITFOR DELAY '00:00:01';
	END
END
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-08-15 20:52:00.0145585
2022-08-15 20:52:01.0162047
2022-08-15 20:52:02.0209920
2022-08-15 20:52:03.0229534
.
.
.
2022-08-15 20:53:56.6402032
2022-08-15 20:53:57.6424606
2022-08-15 20:53:58.6450557
2022-08-15 20:53:59.6499793
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not necessarily a command which will see every day usage, it could prove useful to simulate a specific &amp;quot;real world&amp;quot; scenario when there is a time span between statements, either for testing or investigation purposes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mssqltips.com/sqlservertip/7344/delay-sql-code-execution-with-sql-waitfor/"&gt;SQL WAITFOR Command to Delay SQL Code Execution&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;157: 09-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Formatting interpolated strings</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/08-interpolation-formatting</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/08-interpolation-formatting</guid>
			<pubDate>Thu, 08 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;string interpolation&lt;/code&gt;, the colon &lt;code&gt;:&lt;/code&gt; operator can be used, followed by the &lt;code&gt;format string&lt;/code&gt; to specify how the string should be formatted. This can be used instead of the &lt;code&gt;ToString&lt;/code&gt; method with a specified format.&lt;/p&gt;
&lt;p&gt;This post is about &lt;code&gt;interpolated strings&lt;/code&gt; however the technique will also work when using the &lt;code&gt;index component&lt;/code&gt; (using &lt;em&gt;String.Format&lt;/em&gt; with &lt;code&gt;{0}&lt;/code&gt; instead the string).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="format"&gt;Format&lt;/h2&gt;
&lt;p&gt;In a previous post, we learnt how to &lt;a href="https://alwaysdeveloping.net/08/03-string-interpolation-alignment"&gt;align the string when performing string interpolation&lt;/a&gt; - but when using this method (and other composite string techniques) there also an optional &lt;em&gt;formatString&lt;/em&gt; component.&lt;/p&gt;
&lt;p&gt;The full syntax for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string interpolation&lt;/code&gt; is: &lt;code&gt;{&amp;lt;interpolationExpression&amp;gt;[,&amp;lt;alignment&amp;gt;][:&amp;lt;formatString&amp;gt;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;composite formatting&lt;/code&gt; is: &lt;code&gt;{index[,alignment][:formatString]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post will focus on the &lt;em&gt;formatString&lt;/em&gt; portion - this provides a shortcut to using the &lt;code&gt;.ToString(format)&lt;/code&gt; method on the relevent entity.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the examples below, the &lt;em&gt;ToString&lt;/em&gt; method, and the &lt;em&gt;interpolated format string&lt;/em&gt; method are compared, with the same format string, and shown to produce the same output. It is also shown when no format string is specified, the `general ("G") format specifier is used (for numeric, datetime and enumeration).&lt;/p&gt;
&lt;h3 id="datetime"&gt;DateTime&lt;/h3&gt;
&lt;p&gt;Below we see how to format a &lt;code&gt;DateTime&lt;/code&gt; using the more traditional &lt;em&gt;ToString&lt;/em&gt; method, and then the &lt;em&gt;format string&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;DateTime current  = DateTime.Now;
Console.WriteLine($"Current Datetime:{current}");
Console.WriteLine($"Current Datetime:{current.ToString("MM/dd/yyyy hh:mm:ss.fff")}");
Console.WriteLine($"Current Datetime:{current:MM/dd/yyyy hh:mm:ss.fff}");

Console.WriteLine($"Current Datetime:{current.ToString("hh:mm")}");
Console.WriteLine($"Current Datetime:{current:hh:mm}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Current Datetime:2022/08/15 05:56:53
Current Datetime:09/07/2022 05:54:25.527
Current Datetime:09/07/2022 05:54:25.527
Current Datetime:05:54
Current Datetime:05:54
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Same output with the two methods, but when using the &lt;em&gt;interpolated format string&lt;/em&gt; method, the code is more concise and (arguably) cleaner.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="guid"&gt;Guid&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;Guid&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Guid newGuid = Guid.NewGuid();
Console.WriteLine($"Guid value: {newGuid}");
Console.WriteLine($"Guid value: {newGuid.ToString("B")}");
Console.WriteLine($"Guid value: {newGuid:B}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Guid value: bcaf5b5e-14be-4156-a480-a87614a900f4
Guid value: {bcaf5b5e-14be-4156-a480-a87614a900f4}
Guid value: {bcaf5b5e-14be-4156-a480-a87614a900f4}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="timespan"&gt;TimeSpan&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;TimeSpan&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;TimeSpan travelTime = new TimeSpan(1, 6, 24, 1);
Console.WriteLine($"Travel time: {travelTime}");
Console.WriteLine($"Travel time: {travelTime.ToString("g")}");
Console.WriteLine($"Travel time: {travelTime:g}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Travel time: 1.06:24:01
Travel time: 1:6:24:01
Travel time: 1:6:24:01
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="numeric"&gt;Numeric&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;numeric&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int cost = 5699;
Console.WriteLine($"Cost: {cost}");
Console.WriteLine($"Cost: {cost.ToString("c")}");
Console.WriteLine($"Cost: {cost:c}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cost: 5699
Cost: R5&amp;nbsp;699,00
Cost: R5&amp;nbsp;699,00
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="enum"&gt;Enum&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;Enum&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ConsoleColor drawColor = ConsoleColor.Green;
Console.WriteLine($"Draw color: {drawColor}");
Console.WriteLine($"Draw color: {drawColor.ToString("D")}");
Console.WriteLine($"Draw color: {drawColor:D}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Draw color: Green
Draw color: 10
Draw color: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is &lt;code&gt;not a new or revolutionary feature&lt;/code&gt;. I tend to use the &lt;code&gt;ToString&lt;/code&gt; method when formatting strings, not really aware that there was an alternative. Using the &lt;code&gt;:formatString&lt;/code&gt; method is not going to drastically change the maintainability, readability or performance of the code - but it does require slightly less typing and removes one additional method call (&lt;em&gt;ToString&lt;/em&gt;) so personally I will be using this method more frequently going forward.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting#format-string-component"&gt;Composite formatting: Format string component&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;156: 08-09-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>.NET 7 API output caching</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/07-output-cache</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/07-output-cache</guid>
			<pubDate>Wed, 07 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Built in &lt;code&gt;output caching&lt;/code&gt; support is being introduced with .NET 7, providing &lt;code&gt;caching functionality for minimal api responses&lt;/code&gt;. The functionality is highly configurable allowing for fast, yet accurate responses from a minimal api.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="endpoints"&gt;Endpoints&lt;/h2&gt;
&lt;h3 id="default-endpoint"&gt;Default endpoint&lt;/h3&gt;
&lt;p&gt;In these examples, a simple minimal api endpoint will be used as a base, which &lt;em&gt;returns the current datetime when invoked&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/date", () =&amp;gt;
{
    return DateTime.Now;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="default-caching"&gt;Default caching&lt;/h3&gt;
&lt;p&gt;Let's start by adding default caching to the endpoint. There are basically 3 steps to be performed to configure output caching (these are the same three steps that apply to most  API functionality):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Configure the &lt;code&gt;dependency injection container&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddOutputCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure the api &lt;code&gt;middleware pipeline&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseOutputCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Define the endpoint, and &lt;code&gt;apply the output cache functionality to the endpoint&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datedefaultcache", () =&amp;gt;
{
    return DateTime.Now;
}).CacheOutput();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Invoking the &lt;code&gt;/date&lt;/code&gt; endpoint will always result in a new return value, however invoking &lt;code&gt;/datedefaultcache&lt;/code&gt; a cached value will be returned (apart from the first time it is invoked). By default, the response is cached for 60 seconds.&lt;/p&gt;
&lt;p&gt;Inspecting the response headers (by using a tool like Postman, for example), one can see the age of the cached response (in seconds) is included:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/response-age.png" alt="Response age - 17 seconds old"&gt;&lt;/p&gt;
&lt;p&gt;By default, once the cache is 60 seconds old, it expires and the next request to the endpoint will generate a new cache.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="caching-policy"&gt;Caching policy&lt;/h3&gt;
&lt;p&gt;It is also possible to define one or more &lt;code&gt;cache policy&lt;/code&gt; which allows for finer control of the behavior over the caching mechanism. A policy can either be defined as part of the &lt;code&gt;AddOutputCache&lt;/code&gt; call, and then applied to one or many endpoints (as is shown in the example immediately below), or defined when applying caching to a specific endpoint (as shown in an &lt;em&gt;VaryBy&lt;/em&gt; example further down).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define the &lt;code&gt;caching policy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddOutputCache(options =&amp;gt;
{
    options.AddPolicy("ignore-cache", p =&amp;gt; p
        .With(ctx =&amp;gt; !ctx.HttpContext.Request.Headers.ContainsKey("ignore-cache"))
    );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This policy looks for the presence of a header called &lt;em&gt;ignore-cache&lt;/em&gt; and only applies the cache policy if the header is &lt;strong&gt;not&lt;/strong&gt; present (irrespective of the header value)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Apply the policy&lt;/code&gt; to an endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// option to ignore
app.MapGet("/dateignorecache", () =&amp;gt;
{
    return DateTime.Now;
}).CacheOutput("ignore-cache");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking this endpoint will result in default caching behavior, &lt;em&gt;unless&lt;/em&gt; a header named &lt;code&gt;ignore-cache&lt;/code&gt; is included in the request, in which case caching will be ignored.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="caching-varyby"&gt;Caching VaryBy&lt;/h3&gt;
&lt;p&gt;Another feature which can be leveraged, is the ability to &lt;code&gt;cache by a specific value&lt;/code&gt;. The built in options available are to cache:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By query&lt;/li&gt;
&lt;li&gt;By header&lt;/li&gt;
&lt;li&gt;By value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the below example, the output is &lt;code&gt;cached by the query string value 'timezone'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimezone", (string? timezone) =&amp;gt;
{
    // insert some logic to get the correct datetime
    // based on the timezone
    return DateTime.Now;

}).CacheOutput(p =&amp;gt; p.VaryByQuery("timezone"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the endpoint is invoked with a specific timezone (&lt;em&gt;/datetimezone&lt;code&gt;?timezone=CAT&lt;/code&gt;&lt;/em&gt; for example), the output will be cached while the same timezone query string is provided. If another timezone is provided (&lt;em&gt;/datetimezone&lt;code&gt;?timezone=GMT&lt;/code&gt;&lt;/em&gt; for example), the same cache used for CAT is &lt;strong&gt;not applied&lt;/strong&gt; and a new cache will be generated specific for &lt;code&gt;GMT&lt;/code&gt;. The cache will &lt;code&gt;vary by a query string value&lt;/code&gt;. The same logic can be applied to a header value, or any other custom value.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="evicting-cache"&gt;Evicting cache&lt;/h3&gt;
&lt;p&gt;In some instances it might be required to &lt;code&gt;manually invalidate a cache&lt;/code&gt; if we know the content is no longer valid. The below example is very simple (for demo purposes), but the same mechanism can be extended for more elaborate use cases:&lt;/p&gt;
&lt;p&gt;The first step is to &lt;code&gt;tag the output cache&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimetag", () =&amp;gt;
{
    return DateTime.Now;

}).CacheOutput(t =&amp;gt; t.Tag("current"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here when the &lt;code&gt;/datetimetag&lt;/code&gt; endpoint is called, the output cache is tagged with the name &lt;em&gt;"current"&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The implementation of &lt;code&gt;IOutputCacheStore&lt;/code&gt; (configured with dependency injection using the &lt;em&gt;AddOutputCache&lt;/em&gt; method) can then be injected where and when required to &lt;code&gt;evict&lt;/code&gt; (invalidate) a cache using the tag.&lt;/p&gt;
&lt;p&gt;In this example, another endpoint is defined which will evict the cache for the &lt;code&gt;/datetimetag&lt;/code&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimeclear", (IOutputCacheStore cache) =&amp;gt;
{
    // evict the cache tagged with "current"
    cache.EvictByTagAsync("current", default);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Another very useful and easy to configure feature coming with .NET 7 (along with &lt;a href="https://alwaysdeveloping.net/08/31-rate-limiting"&gt;rate limiting&lt;/a&gt;, for example) - making minimal api's even more powerful and bringing it closer to parity with the more traditional MVC (controllers) approach.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=0WvGwOoK-CI"&gt;Nick Chapsas - The NEW caching you should be using in .NET 7&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;155: 07-09-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Dynamic EF operations with EF.Property</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/06-ef-property</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/06-ef-property</guid>
			<pubDate>Tue, 06 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;EF.Property&lt;/code&gt; static method can be used to &lt;code&gt;reference an entity property dynamically&lt;/code&gt; using a &lt;code&gt;string representation of the property name&lt;/code&gt;. This can be leveraged to perform dynamic ordering or filtering on the DbSet, for example.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;In all of the examples below, a simple &lt;em&gt;Blog&lt;/em&gt; table is being used which contains a list of 10 000 blog records.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="selection"&gt;Selection&lt;/h3&gt;
&lt;p&gt;Suppose we wanted to get a list of all &lt;em&gt;Blog Titles&lt;/em&gt; - a simple enough query using Entity Framework:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var titles = context.Blogs
    .Select(e =&amp;gt; e.Title)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose now we have a requirement to allow the user to choose which specific column data should be returned. This could be done with a &lt;code&gt;switch statement&lt;/code&gt; or &lt;code&gt;multiple if statements&lt;/code&gt;, but this is not a sustainable approach. The better option is to use &lt;code&gt;Ef.Property&lt;/code&gt; - this allows for the &lt;code&gt;column name to be specified as a string&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var dynTitle = context.Blogs
    .Select(e =&amp;gt; EF.Property&amp;lt;string&amp;gt;(e, &amp;quot;Title&amp;quot;))
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we get all &lt;em&gt;Titles&lt;/em&gt;, without ever referencing the &lt;em&gt;Title&lt;/em&gt; property on the &lt;em&gt;Blog&lt;/em&gt; entity directly.&lt;/p&gt;
&lt;p&gt;This can be enhanced, and a generic method created to &lt;code&gt;select values from the specified table and column&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get all ids from the Blog table
var ids = GetColumnValues&amp;lt;Blog, int&amp;gt;(&amp;quot;Id&amp;quot;);
Console.WriteLine($&amp;quot;Num Ids in list: {ids.Count}&amp;quot;);
Console.WriteLine($&amp;quot;First Id in list: {ids.First()}&amp;quot;);

// the entity type and the colum value type are specific
// as well as the column name
public List&amp;lt;TColumn&amp;gt; GetColumnValues&amp;lt;TEntity, TColumn&amp;gt;(
    string columnName) where TEntity : class
{
    using var context = new DemoContext();

    return context.Set&amp;lt;TEntity&amp;gt;()
        .Select(e =&amp;gt; EF.Property&amp;lt;TColumn&amp;gt;(e, columnName))
        .ToList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Num Ids in list: 10000
First Id in list: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now have a dynamic method to retrieve all values from the specified column.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;EF.Property&lt;/code&gt; can be used anywhere a entity property would traditionally be used - this means it could also be used for dynamic ordering and filtering!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ordering"&gt;Ordering&lt;/h3&gt;
&lt;p&gt;We can use the above &lt;code&gt;GetColumnValues&lt;/code&gt; method as a template for a new method to perform &lt;em&gt;dynamic ordering&lt;/em&gt; on the &lt;em&gt;Blog&lt;/em&gt; entity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;Blog&amp;gt; GetBlogs(string sortProperty, int pageSize)
{
    using var context = new DemoContext();

    // instead of specifying the column to order by 
    // directly, EF.Property is used
    return context.Blogs
        .OrderBy(e =&amp;gt; EF.Property&amp;lt;object&amp;gt;(e, sortProperty))
        .Take(pageSize)
        .ToList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can now be invoked as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get 5 blogs sorted by Id
var sortedById = GetBlogs(&amp;quot;Id&amp;quot;, 5);
Console.WriteLine($&amp;quot;Sorted by Id, the first Id &amp;quot; +
    $&amp;quot;is: {sortedById.First().Id}&amp;quot;);

// get 5 blogs sorted by Title
var sortedByTitle = GetBlogs(&amp;quot;Title&amp;quot;, 5);
Console.WriteLine($&amp;quot;Sorted by Title, the first Id &amp;quot; +
    $&amp;quot;is: {sortedByTitle.First().Id}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sorted by Id, the first Id is: 1
Sorted by Title, the first Id is: 665
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="filtering"&gt;Filtering&lt;/h3&gt;
&lt;p&gt;One final example of how &lt;code&gt;EF.Property&lt;/code&gt; can be leveraged, is to perform &lt;em&gt;dynamic filtering&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public List&amp;lt;Blog&amp;gt; GetFilterBlogs&amp;lt;T&amp;gt;(string sortProperty, T value, int pageSize)
{
    using var context = new DemoContext();

    return context.Blogs
        .Where(e =&amp;gt; EF.Property&amp;lt;T&amp;gt;(e, sortProperty).Equals(value))
        .Take(pageSize)
        .ToList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows for a &lt;em&gt;column name&lt;/em&gt; and &lt;em&gt;column value&lt;/em&gt; to be &lt;code&gt;specified dynamically and have filtering applied&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// filter by id
var filteredById = GetFilterBlogs&amp;lt;int&amp;gt;(&amp;quot;Id&amp;quot;, 1011, 1);
Console.WriteLine($&amp;quot;Filtered count: {filteredById.Count}&amp;quot;);

// filter by title
var filteredByTitle = GetFilterBlogs&amp;lt;string&amp;gt;(&amp;quot;Title&amp;quot;, 
    &amp;quot;Dynamic EF operations with EF.Property&amp;quot;, 1);
Console.WriteLine($&amp;quot;Filtered count: {filteredByTitle.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Filtered count: 1
Filtered count: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Ef.Property&lt;/code&gt; is a very useful utility method when required to change the target column of operations at runtime, such as when ordering or filtering dynamically (from a user interface grid, for example). There may be a performance impact in using this over referencing the column directly (but this should be benchmarked to confirm for the specific use case) - however these are the tradeoffs which need to be considered when deciding which method to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.ef.property?view=efcore-6.0"&gt;EF.Property&lt;TProperty&gt;(Object, String) Method&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;154: 06-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Performing a ping programmatically</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/05-ping-programmatically</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/05-ping-programmatically</guid>
			<pubDate>Mon, 05 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Ping&lt;/code&gt; class is available in the &lt;em&gt;System.Net.NetworkInformation&lt;/em&gt; namespace - this class facilitates performing &lt;em&gt;ping&lt;/em&gt; operations (as the name suggests), on a hostname or IP address from code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage of the class is straightforward - declare an instance of &lt;code&gt;Ping&lt;/code&gt;, and call the &lt;em&gt;SendPingAsync&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.Net.NetworkInformation;

var looping = true;

// format asynchronously on a separate thread
Task.Run(async () =&amp;gt;
{
    // create an instance of the Ping class
    Ping pinger = new Ping();

    // loop until the user presses a key
    while (looping)
    {
        // ping and get the response
        PingReply response = await pinger
            .SendPingAsync(&amp;quot;alwaysdeveloping.net&amp;quot;);

        // extract response information
        Console.WriteLine($&amp;quot;Ping to '{response.Address}' took &amp;quot; +
            $&amp;quot;{response.RoundtripTime}milliseconds and the response &amp;quot; +
            $&amp;quot;was: `{response.Status}`&amp;quot;);

        // wait 250ms before pinging again
        await Task.Delay(250);
    }
});

// wait for a key press
// and then cancel the looping above
Console.ReadKey();
looping = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sample response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Ping to '192.11.119.201' took 604 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 321 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 311 milliseconds and was: 'Success'
Ping to '0.0.0.0' took 0 milliseconds and was: 'TimedOut'
Ping to '192.11.119.201' took 307 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 620 milliseconds and was: 'Success'
Ping to '192.11.119.201' took 308 milliseconds and was: 'Success'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While there are better and more featureful (and more expensive) 3rd party tools available for monitoring the status and uptime of a website, with &lt;code&gt;Ping&lt;/code&gt; a simple, small application could be written to ping on an interval (as in the above example) and send out an alert if numerous timeouts are received.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1553066721702977537"&gt;Davide Bellone Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;153: 05-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>nameof enhancement in C# 11</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/02-enhanced-nameof</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/02-enhanced-nameof</guid>
			<pubDate>Fri, 02 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;With C# 11 (coming towards the end of this year) the scope of the &lt;code&gt;nameof&lt;/code&gt; expression is being extended, allowing it to be used inside an &lt;code&gt;attribute expression&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below examples written and tested using .NET 7-preview5, and as such may differ from the final release or subsequent preview releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;In the examples below, a simple &lt;code&gt;Attribute&lt;/code&gt; which takes a single string in the constructor is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[AttributeUsage(AttributeTargets.Method)]
public class MethodAttr : Attribute
{
    private readonly string _parameterName;

    // constructor just takes a string
    public MethodAttr(string parameterName)
    {
        _parameterName = parameterName;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we want to apply this attribute to a method, and specify the method &lt;code&gt;parameter name as the argument to the Attribute constructor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below we'll look at how this is done prior to C# 11 and how it can be improved on with C# 11.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pre-c-11"&gt;Pre C# 11&lt;/h3&gt;
&lt;p&gt;Prior to C #11 when using the attribute, the parameter name had to be &lt;em&gt;hardcoded&lt;/em&gt; into the &lt;code&gt;MethodAttr constructor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class NameOfClass
{
    public NameOfClass()
    {
        Console.WriteLine($&amp;quot;In constructor of {nameof(NameOfClass)}&amp;quot;);
    }

    public void NameOfMethod()
    {
        Console.WriteLine($&amp;quot;In method {nameof(NameOfMethod)}&amp;quot;);
    }

    // method parameter name hardcoded into the MethodAttr constructor
    [MethodAttr(&amp;quot;The parameter name is 'stringParam'&amp;quot;)]
    public void MethodWithParam(string stringParam)
    {
        // however, in the method nameof can be used to get 
        // the name of the parameter
        Console.WriteLine($&amp;quot;Value of parameter '{nameof(stringParam)}' is &amp;quot; +
            $&amp;quot;is {stringParam}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;nameof&lt;/code&gt; expression can be used successfully on the parameter name &lt;em&gt;in the method&lt;/em&gt; (&lt;code&gt;nameof(stringParam)&lt;/code&gt;), however when it comes to the attribute, the name has to be hardcoded - the &lt;code&gt;nameof&lt;/code&gt; expression cannot be used in this context.&lt;/p&gt;
&lt;p&gt;The issue with this approach, is that if the variable &lt;em&gt;stringParam&lt;/em&gt; is renamed (either with &lt;em&gt;F2&lt;/em&gt;, or &lt;em&gt;CTRL R+R&lt;/em&gt;) then all &lt;code&gt;string value representations&lt;/code&gt; of the variable name (such as in the attribute constructor) need to &lt;code&gt;manually be updated&lt;/code&gt;. With &lt;code&gt;nameof&lt;/code&gt;, a rename will ensure that all references (including the &lt;code&gt;nameof&lt;/code&gt; references) are renamed - this results in a more consistent and accurate code base.&lt;/p&gt;
&lt;p&gt;Prior to C# 11, there was no choice but to use the string value in the attribute - however this changes in C# 11.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="c-11"&gt;C# 11&lt;/h3&gt;
&lt;p&gt;With C# 11, the scope of &lt;code&gt;nameof&lt;/code&gt; has been increased, and it can now be used in attribute parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class NameOfClass
{
    public NameOfClass()
    {
        Console.WriteLine($&amp;quot;In constructor of {nameof(NameOfClass)}&amp;quot;);
    }

    public void NameOfMethod()
    {
        Console.WriteLine($&amp;quot;In method {nameof(NameOfMethod)}&amp;quot;);
    }

    // method parameter name hardcoded into the MethodAttr constructor
    [MethodAttr($&amp;quot;The parameter name is '{nameof(stringParam)}'&amp;quot;)]
    public void MethodWithParam(string stringParam)
    {
        // however, in the method nameof can be used to get 
        // the name of the parameter
        Console.WriteLine($&amp;quot;Value of parameter '{nameof(stringParam)}' is &amp;quot; +
            $&amp;quot;is {stringParam}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;nameof&lt;/code&gt; can be used in the method as well as in the attribute parameter!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, but welcome change - leveraging &lt;code&gt;nameof&lt;/code&gt; results in more consistent, more accurate and safer code. It's not possible to change the name of the variable, without changing all reference to it also being updated - otherwise a compiler error will occur. The more places &lt;code&gt;nameof&lt;/code&gt; can be utilized, the better!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1553081565613367298"&gt;Oleg Kyrylchuk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;152: 02-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Dispose vs Exception handling</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/01-disposable-exceptions</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/01-disposable-exceptions</guid>
			<pubDate>Thu, 01 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using a class which implements &lt;code&gt;IDisposable&lt;/code&gt; inside a &lt;code&gt;try-catch-finally&lt;/code&gt; block, if an exception is thrown in what order are the &lt;em&gt;Dispose&lt;/em&gt; and &lt;em&gt;catch&lt;/em&gt; block executed?&lt;/p&gt;
&lt;p&gt;The order is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Dispose&lt;/em&gt; method on the class implementing &lt;em&gt;IDisposable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Catch&lt;/em&gt; block&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Finally&lt;/em&gt; block&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Logically this makes sense, as the &lt;code&gt;IDisposable&lt;/code&gt; class is out of scope when the &lt;code&gt;catch&lt;/code&gt; block is being executed. The &lt;em&gt;lowered&lt;/em&gt; code can also be viewed to get an even deeper understanding of how these two features fit together.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;Consider the following class which implements &lt;em&gt;IDisposable&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DisposableClass : IDisposable
{
    public DisposableClass()
    {
        Console.WriteLine($&amp;quot;In Constructor of {nameof(DisposableClass)}&amp;quot;);
    }

    public void Dispose()
    {
        Console.WriteLine($&amp;quot;In Dispose of {nameof(DisposableClass)}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it implements &lt;em&gt;IDisposable&lt;/em&gt;, it can be used with the &lt;code&gt;using&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;try
{
    // declare instance of the disposable class
    using var disposableInstance = new DisposableClass();

    throw new Exception(&amp;quot;Exception or dispose?&amp;quot;);

}catch(Exception ex)
{
    Console.WriteLine(&amp;quot;An exception occurred&amp;quot;);
}
finally
{
    Console.WriteLine(&amp;quot;In the finally block&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In Constructor of DisposableClass
In Dispose of DisposableClass
An exception occurred
In the finally block
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Dispose&lt;/em&gt; called before the &lt;em&gt;catch block&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lowered"&gt;Lowered&lt;/h2&gt;
&lt;p&gt;Looking at the &lt;code&gt;lowered&lt;/code&gt; code (generated using &lt;a href="https://sharplab.io/"&gt;sharplab.io&lt;/a&gt;) it becomes more obvious as to why this is the sequence of events:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal static class &amp;lt;Program&amp;gt;$
{
    private static void &amp;lt;Main&amp;gt;$(string[] args)
    {
        try
        {
            DisposableClass disposableClass = new DisposableClass();
            try
            {
                throw new Exception(&amp;quot;Exception or dispose?&amp;quot;);
            }
            finally
            {
                if (disposableClass != null)
                {
                    ((IDisposable)disposableClass).Dispose();
                }
            }
        }
        catch (Exception)
        {
            Console.WriteLine(&amp;quot;An exception occurred&amp;quot;);
        }
        finally
        {
            Console.WriteLine(&amp;quot;In the finally&amp;quot;);
        }
    }
}
internal class DisposableClass : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine(&amp;quot;Disposing DisposableClass&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;using&lt;/code&gt; statement is converted into its own &lt;code&gt;try-finally&lt;/code&gt; block, with the &lt;em&gt;Dispose&lt;/em&gt; being called inside the &lt;em&gt;finally&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Looking at the above code, it make entire sense that the sequence of events is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Constructor&lt;/code&gt; of the &lt;em&gt;disposable class&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The first &lt;code&gt;finally&lt;/code&gt; block is called, and the &lt;code&gt;Dispose&lt;/code&gt; method is invoked&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;catch&lt;/code&gt; block is called, and the exception is handled&lt;/li&gt;
&lt;li&gt;The second &lt;code&gt;finally&lt;/code&gt; block is called&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The sequence of events in this scenario was not something I had considered before - but thinking through what each block of code does (as well as executing the sample code, and looking at the lowered code), the sequence of events makes sense, and is as one would probably expect. However, it is good to get confirmation and gain a better understanding of how one's code might operate under the hood.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/BelloneDavide/status/1547993398853767170"&gt;Davide Bellone tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;151: 01-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>.NET 7 Rate limiting</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/31-rate-limiting</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/31-rate-limiting</guid>
			<pubDate>Wed, 31 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Built in &lt;code&gt;rate limiting support&lt;/code&gt; is being introduced with .NET 7, and provides a way to protect a resource from being overwhelmed with requests.&lt;/p&gt;
&lt;p&gt;The rate limiting can be applied to an endpoint(s) to automatically control how often it can be called (API rate limiting), but in addition it can also be manually leveraged to control how often any resource in the applications gets used (such as a database connection)&lt;/p&gt;
&lt;p&gt;All below examples were written using .NET 7-preview5, and as such may differ from the final release or subsequent preview releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="rate-limiter-types"&gt;Rate limiter types&lt;/h2&gt;
&lt;p&gt;There are a number of different rate limiting algorithms available in .NET 7 to control the flow of requests. We will not go into detail in this post, but full details on each one can be found in the references link below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Concurrency&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Token bucket&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fixed window&lt;/code&gt; limit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sliding window&lt;/code&gt; limit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the examples below, we make use of, and explore in a little more depth, the &lt;code&gt;fixed window&lt;/code&gt; and &lt;code&gt;token bucket&lt;/code&gt; limiters.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limiting-an-api"&gt;Limiting an API&lt;/h2&gt;
&lt;p&gt;The most obvious and well-known usage for rate limiting, is to apply it to an API endpoint to control how often it can get called. A few examples on why one might want to do this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To prevent API being overwhelmed with requests from any source&lt;/li&gt;
&lt;li&gt;To control how often a specific user can call the API based on account balance (or account tier)&lt;/li&gt;
&lt;li&gt;To limit the number of requests from a specific IP address (in the case of endpoint abuse)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the example below, a &lt;code&gt;fixed windows&lt;/code&gt; rate limiter will be applied to an endpoint. Two NuGet package references are required:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;System.Threading.RateLimiting&lt;/code&gt; - provides the based rate limiting functionality&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.AspNetCore.RateLimiting&lt;/code&gt; - provides functionality to integrate rate limiting into AspNetCore middleware&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two steps are involved when using rate limiting with an endpoint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defined the rate limit policy&lt;/li&gt;
&lt;li&gt;Apply the policy to an endpoint(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-policy"&gt;Define the policy&lt;/h3&gt;
&lt;p&gt;The policy is defined on startup by using the &lt;code&gt;UseRateLimiter&lt;/code&gt; extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
app.UseRateLimiter(new RateLimiterOptions()
    .AddFixedWindowLimiter(&amp;quot;getlimiter&amp;quot;, 
        new FixedWindowRateLimiterOptions(1, 
            QueueProcessingOrder.OldestFirst, 
            0, 
            TimeSpan.FromSeconds(2)))
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;FixedWindowLimiter&lt;/code&gt; is being used, with the policy name being &lt;em&gt;&amp;quot;getlimiter&amp;quot;&lt;/em&gt;. Effectively the policy states that: &lt;code&gt;During the 2 second window, only 1 request may be served, with no requests allowed to queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that the policy is defined, the next step is to apply it to an endpoint.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="apply-the-policy"&gt;Apply the policy&lt;/h3&gt;
&lt;p&gt;In the below example, we have a minimal api endpoint which returns the current datetime. Applying the rate limiter is as easy as invoking the &lt;code&gt;RequireRateLimiting&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getwithlimit&amp;quot;, () =&amp;gt;
{
    return DateTime.Now;

}).RequireRateLimiting(&amp;quot;getlimiter&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;RequireRateLimiting&lt;/em&gt; method is called with the policy name to apply specified.&lt;/p&gt;
&lt;p&gt;If the endpoint is now invoked more than once in a 2 second window, the called will receive a &lt;code&gt;503: Service unavailable&lt;/code&gt; response.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limiting-a-resource"&gt;Limiting a resource&lt;/h2&gt;
&lt;p&gt;It is also possible to control the flow of requests to any part of the code or resource using the rate limiting functionality.&lt;/p&gt;
&lt;p&gt;In the following example, we have an endpoint which can either &lt;code&gt;return data from a cache or from the database&lt;/code&gt;. We only want to &lt;em&gt;limit the number of requests which go to the database&lt;/em&gt; using a rate limiter.&lt;/p&gt;
&lt;h3 id="define-the-policy-1"&gt;Define the policy&lt;/h3&gt;
&lt;p&gt;First step again, is to define the policy.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;TokenBucketRateLimiter tokenLimiter = 
    new TokenBucketRateLimiter(
        new TokenBucketRateLimiterOptions(0, 
            QueueProcessingOrder.OldestFirst,
            0, 
            TimeSpan.FromSeconds(10), 
            5));

builder.Services.AddSingleton(tokenLimiter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;em&gt;TokenBucketRateLimiter&lt;/em&gt; is being used - it is defined and added as a singleton to the dependency injection container. Effectively the policy states that: &lt;code&gt;Every 10 second period, 5 tokens will be added to the bucket (with a max of 5 tokens in the bucket), with no requests allowed to queue&lt;/code&gt;. Once the tokens are all taken, no requests will be allowed until the bucket is replenished.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="apply-the-policy-1"&gt;Apply the policy&lt;/h3&gt;
&lt;p&gt;We can now inject the policy into a constructor, or API endpoint&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject the limiter as well as the DatabaseResource to limit
// the number of requests to
app.MapGet(&amp;quot;/limitresource&amp;quot;, (TokenBucketRateLimiter tokenLimiter, 
    DatabaseResource databaseAccess) =&amp;gt;
{
    // use Random to simulate if the database should be 
    // called or if the cache should be used
    var random = new Random();
    var shouldCallDatabase = random.Next(0, 2);

    // database should be called, rate limiting applies
    if (shouldCallDatabase == 1)
    {
        // try acquire a token
        var lease = tokenLimiter.Acquire();
        // if there was a token available
        // then we can call the database
        if (lease.IsAcquired)
        {
            return databaseAccess.GetData();
        }

        // otherwise, unable to call at this time
        return &amp;quot;Unable to retrieve data at this time&amp;quot;;
    }

    // from cache, no rate limiting
    return &amp;quot;Retrieved from cache&amp;quot;;

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The basic flow is to try &lt;em&gt;acquire&lt;/em&gt; a lease on a token from the rate limiter instance - if no token is available, the lease is not acquired and a relevent message is returned.&lt;br /&gt;
In this specific example, a &lt;code&gt;200 Success&lt;/code&gt; will still be returned in all branches of the flow, but this could be manually changed handled to change the HTTP response code based on the branch taken by the code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very useful and easy to configure feature coming with .NET 7. If already using an &lt;em&gt;API Management (APIM)&lt;/em&gt; tool, which usually has rate limiting functionality included, this feature might not be &lt;em&gt;as&lt;/em&gt; useful, but can still play its part. Often some internal traffic doesn't always go through the APIM, so the .NET rate limiting feature could be leveraged for those cases, and used in conjunction with the APIM.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-rate-limiting-for-dotnet/"&gt;Announcing Rate Limiting for .NET&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;150: 31-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>