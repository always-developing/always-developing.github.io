<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2023</copyright>
		<pubDate>Tue, 24 Jan 2023 03:39:17 GMT</pubDate>
		<lastBuildDate>Tue, 24 Jan 2023 03:39:17 GMT</lastBuildDate>
		<item>
			<title>LINQ lambda vs method group</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method</guid>
			<pubDate>Tue, 24 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using an &lt;em&gt;expression&lt;/em&gt; with LINQ, &lt;code&gt;a lambda should be preferred over a method group&lt;/code&gt; as the performance is slightly better. Lambda expressions can be cached by the runtime resulting in the increased performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the below example we'll be filtering a collection of integers, to return only the values which are &lt;em&gt;greater than 100&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Where&lt;/em&gt; method on &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; accepts a &lt;code&gt;Func&amp;lt;int, bool&amp;gt;&lt;/code&gt; - this can be defined as an actual method, or as a lambda method. We'll have a look at each technique, and then compare performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="method-group"&gt;Method group&lt;/h3&gt;
&lt;p&gt;With a collection of integers, to filter using the &lt;em&gt;Where&lt;/em&gt; method with a &lt;code&gt;method group&lt;/code&gt;, a method need to be defined which &lt;em&gt;accepts an int and returns a bool&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// simple method which accepts an int
// and returns true if the value is 
// greater than 100
static bool GreaterThan100(int value)
{
    return value &amp;gt; 100;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can then be used in a &lt;em&gt;Where&lt;/em&gt; method call:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// collection of 100 integers
IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// filter using a method group
IEnumerable&amp;lt;int&amp;gt;? filteredItems = items.Where(GreaterThan100);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="lambda"&gt;Lambda&lt;/h3&gt;
&lt;p&gt;With the &lt;code&gt;lambda technique&lt;/code&gt; the separate defined method is invoked manually with the parameter specified:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// &amp;quot;manually&amp;quot; call the method, sending the int value
// &amp;quot;manually&amp;quot; to the method
var filteredItems1 = items.Where(i =&amp;gt; GreaterThan100(i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both techniques will yield the same results, and on the surface look (and are) very similar. However, next let's look at the performance of each technique to see the main difference.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;For the performance benchmarking, the following &lt;em&gt;lambda&lt;/em&gt; and &lt;em&gt;method group&lt;/em&gt; were tested:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class Benchmarks
{
    private IEnumerable&amp;lt;int&amp;gt; items = Enumerable.Range(1, 10000);

    [Benchmark(Baseline = true)]
    public List&amp;lt;int&amp;gt; MethodGroup() =&amp;gt; items.Where(IsDivisibleBy5).ToList();

    [Benchmark]
    public List&amp;lt;int&amp;gt; Lambda() =&amp;gt; items.Where(i =&amp;gt; IsDivisibleBy5(i)).ToList();

    private static bool IsDivisibleBy5(int i) =&amp;gt; i % 5 == 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;a collection of &lt;em&gt;10000 integers&lt;/em&gt; was used&lt;/li&gt;
&lt;li&gt;each item was checked to determine if it was &lt;em&gt;division by 5 or not&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MethodGroup&lt;/td&gt;
&lt;td style="text-align: right;"&gt;75.04 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.483 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.079 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lambda&lt;/td&gt;
&lt;td style="text-align: right;"&gt;66.44 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.306 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.146 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.89&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, we can see that the &lt;code&gt;lambda technique is approx. 10% faster than the method group technique&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The difference between the two methods is this example (10%) may seem fairly significant, but the timescale is in &lt;em&gt;nanoseconds&lt;/em&gt; - a 10% difference at this scale will not be noticeable. However, depending on the collection size and the complexity of the calculation, the difference could be more noticeable.&lt;br /&gt;
In short - for most scenarios using either technique will be fine, however if performance is an issue, or there is a specific bottleneck, then consider explicitly using the lambda technique.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/advanced/lambda_methodgroup/"&gt;Lambda vs method group&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;241: 24-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Task.Delay accuracy</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</guid>
			<pubDate>Mon, 23 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Task.Delay&lt;/code&gt; relies on the underlying operating system's internal timer, which for most Windows environments, takes about 15ms to resolve. This means that the &lt;em&gt;minimum amount of time that can be accurately used with Task.Delay is approximately 15ms (on Windows)&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Diagnostics.StopWatch&lt;/code&gt; can be used to benchmark how long a &lt;code&gt;Task.Delay&lt;/code&gt; call actually takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(100);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, the result (which may vary each execution and per machine):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 110 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the code is specifying a 100ms delay, and actual delay is close to 110ms.&lt;/p&gt;
&lt;p&gt;The same &lt;em&gt;inaccurate&lt;/em&gt; delay is seen when trying to delay for a small precise time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(5);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 19 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results may vary, but (in my case) the true delay was never less than 17ms. As mentioned, this is due to the underlying operating system's internal timer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If requiring small precise waiting times, &lt;code&gt;Task.Delay&lt;/code&gt; is not the way to go. In fact there are no &amp;quot;easy&amp;quot; ways to wait for such small precise times - there are ways to do it (which will not be shown here), but they are involved and are often not very performant when it comes to resource usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/#dont-use-taskdelay-for-small-precise-waiting-times"&gt;Don’t use Task.Delay for small precise waiting times&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;240: 23-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>LINQ Any/All over Count</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count</guid>
			<pubDate>Fri, 20 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In most scenarios, the LINQ &lt;code&gt;All&lt;/code&gt; or &lt;code&gt;Any&lt;/code&gt; methods should be used instead of the &lt;code&gt;Count&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; should be avoided, as it &lt;em&gt;enumerates through every single entry in the collection to get the count&lt;/em&gt;, where &lt;code&gt;Any/All&lt;/code&gt; will &lt;em&gt;return as soon as the predicate condition is not met anymore&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;All of the below examples, use the following collection:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var intList = Enumerable.Range(1, 10);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="no-predicate"&gt;No predicate&lt;/h3&gt;
&lt;p&gt;When required to check if a list contains &lt;em&gt;any&lt;/em&gt; items, the &lt;code&gt;Any&lt;/code&gt; method should be used instead of &lt;code&gt;Count&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() &amp;gt; 0);
// Good
Console.WriteLine(intList.Any());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, when &lt;code&gt;Count&lt;/code&gt; is used, 10 items needs to be enumerated to get the full count, however &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; after one iteration, as soon as one item is found.&lt;br /&gt;
With only 10 items, the difference is negligible, however as the number of items in the collection increased, the difference will become more noticeable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="with-predicate"&gt;With predicate&lt;/h3&gt;
&lt;p&gt;The same logic applies when a &lt;em&gt;predicate is supplied&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 5) &amp;gt; 0);
// Good
Console.WriteLine(intList.Any(i =&amp;gt; i &amp;gt; 5));

// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 10) == 0);
// Good
Console.WriteLine(!intList.Any(i =&amp;gt; i &amp;gt; 10));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Count&lt;/code&gt; method will need to enumerable over all items in the collection, while &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; as soon as the first item which satisfies the predicate is reached.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="all-items"&gt;All items&lt;/h3&gt;
&lt;p&gt;Similar logic applies when &lt;code&gt;All&lt;/code&gt; items in the collection need to be checked:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() == intList.Count(i =&amp;gt; i  &amp;lt; 100));
// Good
Console.WriteLine(intList.All(i =&amp;gt; i &amp;lt; 100));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, with &lt;code&gt;Count&lt;/code&gt;, all items in the collection are enumerated over, while the &lt;code&gt;All&lt;/code&gt; method will return &lt;em&gt;false&lt;/em&gt; as soon as one item is reached which does not satisfy the predicate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally, unless &lt;code&gt;Count&lt;/code&gt; specifically needs to be used, &lt;code&gt;Any&lt;/code&gt; or &lt;code&gt;All&lt;/code&gt; should be preferred, especially as the number of items in the collection increases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/linq/#using-count-instead-of-all-or-any"&gt;Using Count() instead of All or Any&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;239: 20-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Eliding await keyword</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await</guid>
			<pubDate>Thu, 19 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple &lt;em&gt;async method&lt;/em&gt; are called in a sequence, the &lt;code&gt;async methods should be elided&lt;/code&gt; and the &lt;em&gt;Tasks&lt;/em&gt; should be &lt;em&gt;awaited&lt;/em&gt; and not passed up the call stack.&lt;/p&gt;
&lt;p&gt;If a &lt;em&gt;Task&lt;/em&gt; is passed up the stack, and an exception occurs - the Task which is not &lt;em&gt;awaited&lt;/em&gt; will not be part of the error stack trace.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-await-exception"&gt;No await exception&lt;/h2&gt;
&lt;p&gt;In the below code snippet, we have a call stack where a &lt;em&gt;Task&lt;/em&gt; is &lt;code&gt;not awaited immediately&lt;/code&gt;, but passed up the call stack to be awaited:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await NoAwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

// return a Task
static Task NoAwaitMethod()
{
    // call a method which returns a Task but 
    // do NOT await
    return ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoAwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, but &lt;strong&gt;does not await the call&lt;/strong&gt;. The method returns the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns - which is the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Running the above code, the call stack generated from the exception is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The stack trace has &lt;code&gt;no mention that the call stack went through the NoAwaitMethod method!&lt;/code&gt;. This is due to the fact that the method is basically just a &lt;em&gt;pass through method&lt;/em&gt; for the &lt;em&gt;Task&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To get a more accurate stack trace, the &lt;em&gt;async method needs to be awaited&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="await-exception"&gt;await exception&lt;/h2&gt;
&lt;p&gt;As mentioned above, instead of a method like &lt;em&gt;NoAwaitMethod&lt;/em&gt;, which serves as a pass through for the &lt;em&gt;Task&lt;/em&gt;, the &lt;code&gt;Task should be awaited&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;wait CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await AwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

static async Task AwaitMethod()
{
    // await the task returned instead
    // of just returning the Task
    await ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, and &lt;strong&gt;awaits the call&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now running the above code, the full complete stack trace is part of the exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__AwaitMethod|0_1() in C:\Development\Blog\ElideAwait\Program.cs:line 21
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 6 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time we have a &lt;code&gt;full, complete stack trace!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When &lt;em&gt;await async&lt;/em&gt; is used in conjunction with any &lt;em&gt;exceptions&lt;/em&gt;, the Tasks in question should be elided and &lt;em&gt;awaited&lt;/em&gt; and not passed up the stack trace as it can cause certain methods to be omitted from exception stack traces.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/"&gt;Elide await keyword - Exceptions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;238: 19-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Accurate string length</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/18-string-length</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/18-string-length</guid>
			<pubDate>Wed, 18 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;String.Length&lt;/code&gt; does &lt;em&gt;not always return a &amp;quot;true&amp;quot; accurate length&lt;/em&gt; of the string - instead, the &lt;code&gt;StringInfo.LengthInTextElements&lt;/code&gt; method should be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="string-length"&gt;String Length&lt;/h2&gt;
&lt;p&gt;Generally, for most common string usage, the &lt;code&gt;String.Length&lt;/code&gt; will return the correct length of the string - the number of characters in the string object. However, the number of characters in the string object &lt;code&gt;does not always correspond to the number of characters which reflect on the screen&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.Write(&amp;quot;This string '👍' has the length of: &amp;quot;);
Console.WriteLine(&amp;quot;👍&amp;quot;.Length);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This string '??' has the length of: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The terminal window is unable to render the 👍 emoji, so it is reflected as '??' - but this also gives insight into its length (two question marks, and no one). Even though 👍 reflects as &lt;code&gt;one character when output, it actually consists of two characters in the string object&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="stringinfo-lengthintextelements"&gt;StringInfo LengthInTextElements&lt;/h2&gt;
&lt;p&gt;To get a more accurate string length, the &lt;code&gt;StringInfo.LengthInTextElements&lt;/code&gt; property can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.Write(&amp;quot;This string '👍' has the true length of: &amp;quot;);
Console.WriteLine(new StringInfo(&amp;quot;👍&amp;quot;).LengthInTextElements);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This string '??' has the length of: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;LengthInTextElements&lt;/em&gt; property will return the number of text elements displayed in the terminal.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the length of the string is required for display purposes, and the string could contain &amp;quot;non-traditional&amp;quot; characters, such as emoji's - then the &lt;em&gt;StringInfo.LengthInTextElements&lt;/em&gt; property should be used for more accurate results.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/strings/#getting-the-printable-length-of-a-string-or-character"&gt;Getting the printable length of a string or character&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;237: 18-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Non-generic to generic method call</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic</guid>
			<pubDate>Tue, 17 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;dynamic&lt;/code&gt; type can be used in the use case when required to call into a &lt;em&gt;generic method, from a non-generic method&lt;/em&gt;. This is a fairly niche use case, but when required, the &lt;code&gt;dynamic&lt;/code&gt; technique explained below can be of great benefit.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generic-method"&gt;Generic method&lt;/h2&gt;
&lt;p&gt;Assume we have the following simple generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static void GenericMethod&amp;lt;T&amp;gt;(T parameter)
{
    Console.WriteLine($&amp;quot;T is of type: {typeof(T).Name}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method needs to be called from another non-generic method which contains an &lt;code&gt;object&lt;/code&gt; variable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="object-technique"&gt;Object technique&lt;/h3&gt;
&lt;p&gt;Calling into the generic method with an &lt;code&gt;object&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // call into the generic method with the
        // object type
        GenericMethod(randomObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this will compile and &amp;quot;work&amp;quot;, calling the &lt;code&gt;ObjectMethod&lt;/code&gt; method with various types, will result in the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: Object
T is of type: Object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an &lt;code&gt;Object&lt;/code&gt; is being passed to the generic method (even though the underlying types are different), the values are &lt;em&gt;boxed&lt;/em&gt; into that type, and that is what is output.&lt;/p&gt;
&lt;p&gt;If we would like to know the &lt;em&gt;actual&lt;/em&gt; type output, then the &lt;code&gt;dynamic technique&lt;/code&gt; can be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dynamic-technique"&gt;Dynamic technique&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;dynamic technique&lt;/code&gt; involves casting the &lt;code&gt;object to dynamic&lt;/code&gt; before calling the generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // cast the object to dynamic
        dynamic dynObj = randomObj;
        GenericMethod(dynObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, calling the generic method with the same variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: String
T is of type: Int32
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A fairly niche use case, and a small difference in code but one which can make a big difference when the use case is encountered. There might be a performance impact with the &lt;em&gt;dynamic technique&lt;/em&gt; (as dynamic generally is less performant), but this might be out-weighed by the benefit the technique gives. As always, if performance is an issue, benchmark and and make an informed decision which technique to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/RogerAlsing/status/1609955500363333632"&gt;Roger Johansson Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;236: 17-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Cancelling a collection iteration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation</guid>
			<pubDate>Mon, 16 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When iterating over a collection or items, the &lt;code&gt;TakeWhile&lt;/code&gt; method can be used in conjunction with a &lt;code&gt;CancellationToken&lt;/code&gt; to successfully stop iterating if the parent process is cancelled.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-cancellationtoken"&gt;No CancellationToken&lt;/h2&gt;
&lt;p&gt;Generally, when iteration through a collection, a &lt;code&gt;foreach&lt;/code&gt; (or &lt;code&gt;for&lt;/code&gt;) loop is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task ExecuteLoopNoCancel()
{
    // generate a collection of 100 items
    var iterationItems = Enumerable.Range(0, 100);

    // iterate through the 100 items
    foreach (var item in iterationItems)
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the above &lt;code&gt;/ExecuteLoopNoCancel&lt;/code&gt; endpoint has the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processing item: 0
Processing item: 1
Processing item: 2
Processing item: 3
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, and &lt;em&gt;especially in an endpoint which can be cancelled at any time&lt;/em&gt;, is that if the parent process is cancelled, the &lt;code&gt;iteration of the collection will continue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;loop will continue to execute in the background&lt;/em&gt; (and output to the console), as it is being executed &lt;code&gt;asynchronously&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="with-cancellationtoken"&gt;With CancellationToken&lt;/h2&gt;
&lt;p&gt;To correctly &lt;code&gt;cancel the iteration&lt;/code&gt; when the parent process is cancelled, a &lt;code&gt;CancellationToken&lt;/code&gt; should be passed from the top of the stack all the way down to the loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// pass in a CancellationToken
async Task ExecuteLoop(CancellationToken cnlTkn)
{
    var iterationItems = Enumerable.Range(0, 100);

    // only loop while the CancellationToken is not cancelled
    foreach(var item in iterationItems
        .TakeWhile(_ =&amp;gt; !cnlTkn.IsCancellationRequested))
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; token is passed into the endpoint - this is &lt;em&gt;linked&lt;/em&gt; to client, so if the request is &lt;em&gt;cancelled from the client side, the CancellationToken is &amp;quot;notified&amp;quot;&lt;/em&gt; of the cancellation&lt;/li&gt;
&lt;li&gt;In the &lt;em&gt;foreach&lt;/em&gt; loop, the &lt;code&gt;TakeWhile&lt;/code&gt; method is called, with a &lt;code&gt;CancellationToken&lt;/code&gt; passed in as a parameter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, when the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;CancellationToken is marked as cancelled (IsCancellationRequested is set to true), and the iteration will stop&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When performing iterations over a collection, where it makes sense (in situations when the calling process can be cancelled, such as in an endpoint), a &lt;code&gt;CancellationToken&lt;/code&gt; instance should always be used. This ensures any iterations being done asynchronously will be cancelled, ensuring resources are not being unessacary used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/vekzdran/status/1610197203901091840"&gt;&amp;#64;vekzdran&amp;#64;hachyderm.io Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;235: 16-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Naming minimal endpoints</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname</guid>
			<pubDate>Fri, 13 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A minimal endpoint can be &lt;code&gt;given a name&lt;/code&gt;, which can then be leveraged to &lt;code&gt;automatically generate a link to the endpoint&lt;/code&gt; making it easier to be invoked.&lt;/p&gt;
&lt;p&gt;The endpoint name metadata is also treated as the &lt;em&gt;operation Id&lt;/em&gt; in the OpenAPI specification, which is used by tools which use the swagger file to generate a client.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint"&gt;Named endpoint&lt;/h2&gt;
&lt;p&gt;The first step is to give the endpoint a name - this is very simply and involves using the &lt;em&gt;WithName&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the default sample endpoint
app.MapGet(&amp;quot;/weatherforecast&amp;quot;, () =&amp;gt;
{
    WeatherForecast[]? forecast = Enumerable.Range(1, 5).Select(index =&amp;gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
// give it a name
.WithName(&amp;quot;GetWeatherForecast&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the body of the minimal API is defined, the &lt;em&gt;WithName&lt;/em&gt; method is called, with the endpoint name supplied. In this example the sample &lt;em&gt;/weatherforecast&lt;/em&gt; endpoint is given the name &lt;code&gt;GetWeatherForecast&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="link-generation"&gt;Link generation&lt;/h2&gt;
&lt;p&gt;This &lt;em&gt;endpoint name&lt;/em&gt; can now be used to generate a URL to the endpoint - this is done using the &lt;code&gt;LinkGenerator&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject LinkGenerator from DI
app.MapGet(&amp;quot;/generateUrl&amp;quot;, (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    // use the name to get a link to the GetWeatherForecast endpoint
    return generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code defines an endpoint, which when invoked will return the URL of the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint. Browsing to the &lt;code&gt;/generateUrl&lt;/code&gt; endpoint returns the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;http://localhost:5276/weatherforecast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The full URL (including port etc) is automatically calculated by the &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; method, based on the &lt;em&gt;HttpContext&lt;/em&gt; and the &lt;em&gt;endpoint name&lt;/em&gt;. &lt;em&gt;LinkGenerator&lt;/em&gt; is available through the dependency injection container and can just be injected into the relevent constructor/delegate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint-invocation"&gt;Named endpoint invocation&lt;/h2&gt;
&lt;p&gt;A practical use of this functionality is &lt;em&gt;when an endpoint is required to call another endpoint in the same application&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/weatherforecastproxy&amp;quot;, async (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    HttpClient? client = new HttpClient();

    // get the URL for the &amp;quot;GetWeatherForecast&amp;quot; endpoint
    // and create an HttpRequestMessage for it
    HttpRequestMessage? request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;GET&amp;quot;),
        generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null)
    );

    // invoke it
    HttpResponseMessage? response = client.Send(request);
    return await response.Content.ReadAsStringAsync();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, calling &lt;code&gt;/weatherforecastproxy&lt;/code&gt; will proxy the call to the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint and returns the result - this proxy endpoint is not adding much value in this sample, but it could do more complicated logic, such as calling multiple endpoints and reconciling the results, for example.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;named endpoints&lt;/code&gt; and &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; is a safer approach to generating the URL, instead of manually trying to build up the URL based on the information extracted from the &lt;em&gt;HttpContext&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A simple and easy way to name, and then generate a link using the name. If the code is required to call another endpoint in the same application, or will be used with a client generation tool - then all endpoints should be named, and &lt;em&gt;LinkGenerator&lt;/em&gt; used when generating the links.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;234: 13-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Request binding with IParseable</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable</guid>
			<pubDate>Thu, 12 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post&lt;/a&gt; we had a look at the &lt;code&gt;IParseable interface&lt;/code&gt; which allows for a &lt;code&gt;string to be parsed into a type&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This functionality can be leveraged with minimal API's to &lt;em&gt;automatically parse a query string to a complex type&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="iparseable-request"&gt;IParseable request&lt;/h2&gt;
&lt;p&gt;In this example, the &lt;em&gt;Song&lt;/em&gt; entity implements the &lt;em&gt;IParsable&amp;lt;Song&amp;gt;&lt;/em&gt; interface (more details in the &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post about IParseable&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song : IParsable&amp;lt;Song&amp;gt;
{
    public string Name { get; set; }
    public string Artist { get; set; }
    public int LengthInSeconds { get; set; }

    private Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }

    public static Song Parse(string s, IFormatProvider? provider)
    {
        string[] songPortions = s.Split(new[] { '|' });

        if (songPortions.Length != 3) 
        { 
            throw new OverflowException("Expect format: Name|Artist|LengthInSeconds"); 
        }

        return new Song(songPortions[0], songPortions[1], Int32.Parse(songPortions[2]));
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
    {
        result = null;
        if (s == null) 
        { 
            return false; 
        }

        try
        {
            result = Parse(s, provider);
            return true;
        }
        catch { return false; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This interface implementation allows for a string value (in a specific format), to be converted to a &lt;code&gt;Song instance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Song song = "Everlong|Foo Fighters|326".Parse&amp;lt;Song&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="minimal-endpoint"&gt;Minimal endpoint&lt;/h2&gt;
&lt;h3 id="manual-parsing"&gt;Manual parsing&lt;/h3&gt;
&lt;p&gt;If we want an endpoint which accepts a &lt;em&gt;Song&lt;/em&gt; as a parameter, one option is to have the request entity &lt;code&gt;as a string&lt;/code&gt; and perform the conversion to &lt;em&gt;Song&lt;/em&gt; manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/song", ([FromQuery]string song) =&amp;gt;
{
    // perform the conversion from string
    // to Song manually, using the IParsable
    // interface
    return details.Parse&amp;lt;Song&amp;gt;();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a valid approach, but because the &lt;em&gt;Song class&lt;/em&gt; implements &lt;em&gt;IParseable&lt;/em&gt;, the conversion can be done automatically!&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="automatic-parsing"&gt;Automatic parsing&lt;/h3&gt;
&lt;p&gt;A slightly easier approach that manually doing the conversions, is allowing it to happen automatically. Changing the parameter type from &lt;em&gt;string&lt;/em&gt; to &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// parameter is Song instead of string
app.MapGet("/song", ([FromQuery] Song song) =&amp;gt;
{
    return song;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the same endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the same response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;code&gt;Song implement IParsable, the string parameter is automatically parsed to a Song instance&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small quality of life feature which makes working with the &lt;em&gt;IParsable&lt;/em&gt; interface and minimal endpoints easier and more streamline.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/5-new-mvc-features-in-dotnet-7/#1-iparseable-tryparse-for-primitive-binding"&gt;5 new MVC features in .NET 7&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;233: 12-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>SQL: IS DISTINCT FROM</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from</guid>
			<pubDate>Wed, 11 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;SQL Server 2022 introduced a new predicate &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt;, which allows for two expressions to be compared, but takes &lt;code&gt;NULL&lt;/code&gt; values into account.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="data-setup"&gt;Data setup&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Blog&lt;/em&gt; table, with a &lt;code&gt;nullable DateCreated column&lt;/code&gt; - this column &lt;em&gt;could&lt;/em&gt; have a valid &lt;em&gt;DateTime value&lt;/em&gt;, but could also contain NULL values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pre-sql-2022"&gt;Pre SQL 2022&lt;/h3&gt;
&lt;p&gt;Prior to SQL 2022, when comparing two values, &lt;code&gt;NULL&lt;/code&gt; values were, by default, not taken into account.&lt;/p&gt;
&lt;p&gt;Assume the &lt;em&gt;Blog&lt;/em&gt; table &lt;code&gt;DOES&lt;/code&gt; contain rows which have &lt;em&gt;NULL&lt;/em&gt; DateCreated values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE DateCreated = &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;0 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Even though &lt;code&gt;&amp;#64;createdDate&lt;/code&gt; is &lt;em&gt;NULL&lt;/em&gt;, and there are rows in the table with &lt;em&gt;NULL&lt;/em&gt;, &lt;code&gt;no rows are returned&lt;/code&gt; - &lt;em&gt;NULL&lt;/em&gt; values are not taken into account.&lt;/p&gt;
&lt;p&gt;To successfully return rows which do contain &lt;em&gt;NULL&lt;/em&gt; values, both expressions need to be converted to the same default value in case of a &lt;em&gt;NULL&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE ISNULL(DateCreated, '1900-01-01') = 
	ISNULL(&amp;#64;createdDate, '1900-01-01')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With this technique, &lt;em&gt;NULL&lt;/em&gt; values on either expression is converted to &lt;code&gt;'1900-01-01'&lt;/code&gt;, which is then successfully compared.&lt;/p&gt;
&lt;p&gt;With SQL Server 2022, performing this comparison becomes much easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="sql-2022"&gt;SQL 2022&lt;/h3&gt;
&lt;p&gt;SQL Server 2022 introduces the new &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate - this allows the comparison of values while taking &lt;em&gt;NULL&lt;/em&gt; values into account.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT * 
FROM Blog
WHERE DateCreated IS NOT DISTINCT FROM &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate &lt;em&gt;compares the equality of two expressions and guarantees a true or false result, even if one or both operands are NULL&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively minor update, but for a developer which writes a good amount SQL this small update definitely does make things simpler and easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.sqlservercentral.com/blogs/cool-stuff-in-sql-server-2022-is-distinct-from"&gt;Cool Stuff in SQL Server 2022 – IS DISTINCT FROM&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;232: 11-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>