<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Sun, 05 Jun 2022 04:55:48 GMT</pubDate>
		<lastBuildDate>Sun, 05 Jun 2022 04:55:48 GMT</lastBuildDate>
		<item>
			<title>IEnumerable performance cost</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/06-ienumerable-performance</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/06-ienumerable-performance</guid>
			<pubDate>Sun, 05 Jun 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt; instead of a concrete implementation (List or an array for example) can make the code more usable and concise, but comes with a performance cost.&lt;/p&gt;
&lt;p&gt;If performance is critical, it will be worth performing a &lt;code&gt;type check&lt;/code&gt; and handling accordingly.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generic-method"&gt;Generic method&lt;/h2&gt;
&lt;p&gt;We want to create a method which takes a collection of integers, sums them up and returns the result. We are not entirely sure what this collection will be (a list, an array) so we want to make the method generic.&lt;/p&gt;
&lt;p&gt;We might end up with something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int SumItems(IEnumerable&amp;lt;int&amp;gt; enumerable)
{
    var runningSum = 0;

    foreach(var item in enumerable)
    {
        runningSum += item;
    }

    return runningSum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fairly straightforward - the method takes an &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; as a parameter, will iterate through each item keeping a running total, and then return the total at the end.&lt;/p&gt;
&lt;p&gt;Lets look at the performance of this method using various implementations of &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt; enumerableData = Enumerable.Range(0, 10000);
IEnumerable&amp;lt;int&amp;gt; listData = new List&amp;lt;int&amp;gt;(Enumerable.Range(0, 10000));
IEnumerable&amp;lt;int&amp;gt; arrayData = Enumerable.Range(0, 10000).ToArray();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here three different implementations are declared and &lt;code&gt;populated with 10000 items&lt;/code&gt;. We have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an IEnumerable&amp;lt;int&amp;gt;&lt;/li&gt;
&lt;li&gt;a List&amp;lt;int&amp;gt;&lt;/li&gt;
&lt;li&gt;an int array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As all three of these implement IEnumerable, they can all be passed to the &lt;em&gt;SumItems&lt;/em&gt; method as a parameter.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;BenchmarkDotNet&lt;/code&gt; our method is called using each of the IEnumerable types:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;IEnumerable&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.400 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4611 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4313 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57.201 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3635 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.226 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2972 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As one can see, the &lt;code&gt;IEnumerable and the int array are comparable&lt;/code&gt;, with the &lt;code&gt;List considerably slower&lt;/code&gt; (relatively).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="type-checking"&gt;Type checking&lt;/h2&gt;
&lt;p&gt;Next, let's modify the &lt;em&gt;SumItems&lt;/em&gt; method to check the type of IEnumerable, cast to that type, and then iterate on the specific type instead of IEnumerable.&lt;/p&gt;
&lt;p&gt;This could have also been done with method overloading, but with this approach all the code is kept in a single method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int SumListChecked(IEnumerable&amp;lt;int&amp;gt; enumerable)
{
    var runningSum = 0;

    // check for List
    if(enumerable is List&amp;lt;int&amp;gt; list)
    {
        foreach (var item in list)
        {
            runningSum += item;
        }
        return runningSum;
    }

    // check for array
    if (enumerable is int[] array)
    {
        foreach (var item in array)
        {
            runningSum += item;
        }
        return runningSum;
    }

    // all others
    foreach (var item in enumerable)
    {
        runningSum += item;
    }

    return runningSum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the type of IEnumerable parameter &lt;em&gt;enumerable&lt;/em&gt; is checked, if its a &lt;code&gt;List&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt;, then the IEnumerable is cast to that type, and the foreach loop is done on the &lt;code&gt;cast type&lt;/code&gt; not on the original IEnumerable.&lt;/p&gt;
&lt;p&gt;Running the benchmarks for both methods, yields the following results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;IEnumerable&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.400 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4611 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4313 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;IEnumerable&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.846 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3551 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3148 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57.201 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3635 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.523 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0806 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0754 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumItems&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;37.226 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3353 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2972 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SumListChecked&lt;/td&gt;
&lt;td&gt;int[]&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.580 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0213 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0189 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;IEnumerable is effectively the same&lt;/code&gt;, as the code is the same between the two method, however &lt;code&gt;List and Array are considerably quicker&lt;/code&gt; when performing the iterating on the concrete type and not IEnumerable.&lt;/p&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this type of micro-optimization will probably not be required or noticeable in most use cases, its worth knowing about the trade-offs which come with each approach.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Just using IEnumerable&lt;/code&gt;: simplest, most maintainable code, but slowest in most cases&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type checking&lt;/code&gt;: less maintainable, but better performance in some cases&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method overloading&lt;/code&gt;: even less maintainable, as the same/similar code will be in multiple methods but better performance in some cases&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leveluppp.ghost.io/content/images/size/w1000/2021/07/net_virt1.png"&gt;The cost of virtualization in .NET can be surprising&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;89: 06-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Optional parameters in minimal apis</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/03-api-optional-param</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/03-api-optional-param</guid>
			<pubDate>Thu, 02 Jun 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using minimal apis in C#, while query string values will automatically be extracted and send to the lambda expression, they are by &amp;quot;default&amp;quot;, required values. Defaults can also not be supplied, as lambda expressions do not allow default values.&lt;/p&gt;
&lt;p&gt;Either the minimal api needs to use a method (as opposed to a lambda expression) or the parameter needs to be nullable, with the default value being set in the lambda body if not passed in.&lt;/p&gt;
&lt;p&gt;A few examples will make this clearer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lambda-endpoint"&gt;Lambda endpoint&lt;/h2&gt;
&lt;p&gt;First, lets look at a &amp;quot;default&amp;quot; minimal endpoint which uses a lambda expression. Here we expect the &lt;em&gt;count&lt;/em&gt; parameter to be supplied in a query string.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int count) =&amp;gt;
{
    return count;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the endpoint &lt;code&gt;/getdata/lambda?count=5&lt;/code&gt; is invoked, then the result return is &lt;em&gt;5&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, if no parameter is supplied and &lt;code&gt;/getdata/lambda&lt;/code&gt; is invoked, or if a the parameter is incorrectly name (for example &lt;code&gt;/getdata/lambda?counter=5&lt;/code&gt; is invoked ) an exception will be thrown:&lt;br /&gt;
&lt;em&gt;BadHttpRequestException: Required parameter &amp;quot;int count&amp;quot; was not provided from query string&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="method-endpoint"&gt;Method endpoint&lt;/h2&gt;
&lt;p&gt;If the lambda is replaced with a method, the same exception will occur if no query string parameter is supplied:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// external method
int ExtMethod(int count)
{
    return count;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking &lt;code&gt;/getdata/extmethod?count=10&lt;/code&gt;, will result in &lt;em&gt;10&lt;/em&gt; being returned, while invoking &lt;code&gt;/getdata/extmethod&lt;/code&gt; will result in the exception:&lt;br /&gt;
&lt;em&gt;BadHttpRequestException: Required parameter &amp;quot;int count&amp;quot; was not provided from query string&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="default-values"&gt;Default values&lt;/h2&gt;
&lt;p&gt;Once technique which &lt;strong&gt;partially&lt;/strong&gt; works, is to set the parameter to have a default value - however this only works when using a method, and &lt;code&gt;not when using a lambda&lt;/code&gt;.&lt;br /&gt;
This is due to the fact that &lt;code&gt;lambda parameters cannot have default values&lt;/code&gt; - this applies generally to lambda expression, and not specific to minimal api lambdas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// This is NOT VALID and will NOT compile
// The parameter count cannot have a default value
app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int count = 5) =&amp;gt;
{
    return count;
});

// ---

// This IS VALID and will WORK
int ExtMethod(int count = 5)
{
    return count;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, now if the method endpoint is invoked, &lt;code&gt;/getdata/extmethod?count=10&lt;/code&gt;, &lt;em&gt;10&lt;/em&gt; will be returned and if &lt;code&gt;/getdata/extmethod&lt;/code&gt; is invoked (with the parameter &lt;em&gt;count&lt;/em&gt; set), the default value of &lt;em&gt;5&lt;/em&gt; will be returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nullable-types"&gt;Nullable types&lt;/h2&gt;
&lt;p&gt;The solution for both cases, is to have the parameter type changed to a &lt;code&gt;nullable type&lt;/code&gt; and set it to a default value in the body, if null:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// int changed to int?
app.MapGet(&amp;quot;/getdata/lambda&amp;quot;, (int? count) =&amp;gt;
{
    return count ?? 5;
});

// ---

// int changed to int?
int ExtMethod(int? count)
{
    return count ?? 5;
}

app.MapGet(&amp;quot;/getdata/extmethod&amp;quot;, ExtMethod);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In both cases now, the parameter is allowed to be null, and if null, then the default value of 5 will be returned. If the parameter value is supplied, then it will be returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Thinking through the process in a general sense and comparing it to normal method invocations, it does make sense that this is how it would work - even if its not obvious initially:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of type &lt;code&gt;int&lt;/code&gt;, the value has to be explicitly supplied - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of type &lt;code&gt;int&lt;/code&gt; with a default value, the value can optionally be supplied - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When working with a lambda outside of minimal api, default values are not allowed - just like with minimal api.&lt;/li&gt;
&lt;li&gt;When invoking a traditional method which has a parameter of &lt;code&gt;nullable int&lt;/code&gt; (int?) - the value can optionally be supplied - just like with minimal api.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://wildermuth.com/2022/04/04/query-strings-optional-arguments-minimal-apis-aspnetcore/"&gt;How to Access Query Strings in Minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;88: 03-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>EF Core INSERT vs MERGE</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/02-ef-bulk-insert</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/02-ef-bulk-insert</guid>
			<pubDate>Wed, 01 Jun 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When inserting data into a table using Entity Framework Core (EF Core), by default, if three or less records are being inserted, &lt;code&gt;separate SQL INSERT&lt;/code&gt; statements will be used.&lt;br /&gt;
However if four or more records are being inserted, EF Core will batch up the records and perform a &lt;code&gt;single SQL MERGE&lt;/code&gt; statement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In all of the below samples, the following methods were used.&lt;/p&gt;
&lt;p&gt;A method to retrieve a list of &lt;em&gt;Songs&lt;/em&gt; some of which will be used to insert into the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Song[] GetSongs()
{
    return new Song[]
    {
        new Song
        {
            Name = &amp;quot;Everlong&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1997,
            LengthInSeconds = 250
        },
        new Song
        {
            Name = &amp;quot;Learn to Fly&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1999,
            LengthInSeconds = 238
        },
        new Song
        {
            Name = &amp;quot;Monkey Wrench&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1997,
            LengthInSeconds = 231
        },
        new Song
        {
            Name = &amp;quot;My Hero&amp;quot;,
            Artist = &amp;quot;Foo Fighters&amp;quot;,
            YearReleased = 1998,
            LengthInSeconds = 260
        },
        new Song
        {
            Name = &amp;quot;Clarity&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 268
        },
        new Song
        {
            Name = &amp;quot;Daughters&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 238
        },
        new Song
        {
            Name = &amp;quot;Bigger than my Body&amp;quot;,
            Artist = &amp;quot;John Mayer&amp;quot;,
            YearReleased = 2003,
            LengthInSeconds = 266
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A minimal endpoint which will insert a variable number of records into the database, based on the &lt;em&gt;count&lt;/em&gt; parameter passed to the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/insert/{count}&amp;quot;, async (int count) =&amp;gt;
{
    using (var db = new BulkContext())
    {
        var songs = GetSongs();

        // add 1 or many songs
        for(int i = 0; i &amp;lt; count; i++)
        {
            db.Add(songs[i]);
        }

        // only call save changes once
        await db.SaveChangesAsync();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from this, the setup of the &lt;em&gt;BulkContext&lt;/em&gt; and the &lt;em&gt;Song&lt;/em&gt; entity is standard EF Core setup, nothing custom or outside the typical setup.&lt;/p&gt;
&lt;p&gt;What's important here though, is that one or more entities are added to the db context, but the &lt;code&gt;SaveChangesAsync method is only called once&lt;/code&gt;, after all entities have been added.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="insert-statement"&gt;Insert statement&lt;/h3&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 1, 2, or 3 as &lt;em&gt;count&lt;/em&gt; value, results in the following SQL executed &lt;code&gt;1, 2 or 3 separate times&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SET NOCOUNT ON;
INSERT INTO [Song] ([Artist], [LengthInSeconds], [Name], [YearReleased])
VALUES (&amp;#64;p0, &amp;#64;p1, &amp;#64;p2, &amp;#64;p3);
SELECT [Id]
FROM [Song]
WHERE &amp;#64;&amp;#64;ROWCOUNT = 1 AND [Id] = scope_identity();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core generates SQL which will insert the relevant information, and then return the Id primary key generated for the record.&lt;/p&gt;
&lt;p&gt;If full logging is enabled, EF Core will even tell you what it's doing: &lt;em&gt;Executing update commands individually as the number of batchable commands (3) is smaller than the minimum batch size (4).&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="merge-statement"&gt;Merge statement&lt;/h3&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 4 or greater as a value for &lt;em&gt;count&lt;/em&gt; results in the following SQL executed &lt;code&gt;just once&lt;/code&gt; (the below example inserts 5 records):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SET NOCOUNT ON;
DECLARE &amp;#64;inserted0 TABLE ([Id] int, [_Position] [int]);
MERGE [Song] USING (
VALUES (&amp;#64;p0, &amp;#64;p1, &amp;#64;p2, &amp;#64;p3, 0),
(&amp;#64;p4, &amp;#64;p5, &amp;#64;p6, &amp;#64;p7, 1),
(&amp;#64;p8, &amp;#64;p9, &amp;#64;p10, &amp;#64;p11, 2),
(&amp;#64;p12, &amp;#64;p13, &amp;#64;p14, &amp;#64;p15, 3),
(&amp;#64;p16, &amp;#64;p17, &amp;#64;p18, &amp;#64;p19, 4)) AS i ([Artist], [LengthInSeconds], 
        [Name], [YearReleased], _Position) ON 1=0
WHEN NOT MATCHED THEN
INSERT ([Artist], [LengthInSeconds], [Name], [YearReleased])
VALUES (i.[Artist], i.[LengthInSeconds], i.[Name], i.[YearReleased])
OUTPUT INSERTED.[Id], i._Position
INTO &amp;#64;inserted0;

SELECT [i].[Id] FROM &amp;#64;inserted0 i
ORDER BY [i].[_Position];

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, EF Core has changed the strategy from multiple INSERT statements to a single MERGE statement.&lt;/p&gt;
&lt;p&gt;Again, with full logging turned on EF Core will inform you what it's doing: &lt;em&gt;Executing 5 update commands as a batch.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="custom-batch-size"&gt;Custom batch size&lt;/h3&gt;
&lt;p&gt;The default for when EF Core switches from multiple INSERTS to a MERGE statement is 4 records - this however can be overwritten.&lt;/p&gt;
&lt;p&gt;When configuring the connection, the min amd max batch size can be explicitly set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(
        &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=BulkInsert;Integrated Security=True&amp;quot;, options =&amp;gt;
        {
            options.MaxBatchSize(1);
        });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the max batch size is to 1, which means a single INSERT will be used for every statement, with no batching taking place at all (generally, this would &lt;em&gt;not&lt;/em&gt; be advisable).&lt;/p&gt;
&lt;p&gt;Calling the &lt;code&gt;/insert/{count}&lt;/code&gt; endpoint with 4 or greater will now result in multiple INSERTS and &lt;em&gt;not&lt;/em&gt; a MERGE statement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;In most cases, this is not something to worry about - the presumption being that the EF Core team have benchmarked and determined in &lt;em&gt;most&lt;/em&gt; cases, 4 is the threshold where doing a MERGE is more efficient that doing multiple INSERTS.&lt;/p&gt;
&lt;p&gt;However, if one determines that 4 is too high (or too low) for a specific use case, one can adjust the value up or down and benchmark how the performance of the code is impacted.&lt;/p&gt;
&lt;?# DailyDrop ?&gt;87: 02-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Listing all ASP.NET Core routes</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/01-endpoint-data-source</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/01-endpoint-data-source</guid>
			<pubDate>Tue, 31 May 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core has a build in class, &lt;code&gt;EndpointDataSource&lt;/code&gt;, which contains information about a route, while the &lt;code&gt;IEnumerable&amp;lt;EndpointDataSource&amp;gt;&lt;/code&gt; collection, available through dependency injection contains information about all endpoints of an application.&lt;/p&gt;
&lt;p&gt;Information about a specific endpoint can also be retrieved from the &lt;code&gt;HttpContext&lt;/code&gt; for a specific request.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="listing-routes"&gt;Listing routes&lt;/h2&gt;
&lt;p&gt;First, lets look at getting all the routes (endpoints) for an application - this can be done by injecting &lt;code&gt;IEnumerable&amp;lt;EndpointDataSource&amp;gt;&lt;/code&gt; into the relevant constructor (or endpoint delegate in the below example):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routes&amp;quot;, (IEnumerable&amp;lt;EndpointDataSource&amp;gt; routes) =&amp;gt;
        string.Join(Environment.NewLine, routes.SelectMany(es =&amp;gt; es.Endpoints)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/routes&lt;/code&gt; endpoint, the following is returned (the 4 endpoints which make up the sample api):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    HTTP: GET /routes
    HTTP: GET /user/{userId}
    HTTP: GET /routewithid/{id}
    HTTP: GET /routes/info
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="additional-route-data"&gt;Additional route data&lt;/h2&gt;
&lt;p&gt;Additional route metadata can also be retrieved from &lt;code&gt;EndpointDataSource&lt;/code&gt;. The below &lt;code&gt;/routes/info&lt;/code&gt; endpoint extends on the above basic endpoint adding additional data for each endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routes/info&amp;quot;, (IEnumerable&amp;lt;EndpointDataSource&amp;gt; endpointSources) =&amp;gt;
{
    var sb = new StringBuilder();
    var endpoints = endpointSources.SelectMany(es =&amp;gt; es.Endpoints);

    // iterate through each endpoint
    foreach (var endpoint in endpoints)
    {
        // get the display name
        sb.AppendLine($&amp;quot;Endpoint: {endpoint.DisplayName}&amp;quot;);

        // check if the endpoint is a RouteEndpoint
        if (endpoint is RouteEndpoint routeEndpoint)
        {
            // output route pattern information
            sb.AppendLine($&amp;quot;        - Segment Count: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.PathSegments.Count}&amp;quot;);
            
            sb.AppendLine($&amp;quot;        - Parameters: &amp;quot;);
            foreach(var param in routeEndpoint.RoutePattern.Parameters)
            {
                sb.AppendLine($&amp;quot;            - {param.Name}&amp;quot;);
            }
            
            sb.AppendLine($&amp;quot;        - Inbound Precedence: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.InboundPrecedence}&amp;quot;);
            sb.AppendLine($&amp;quot;        - Outbound Precedence: &amp;quot; +
                $&amp;quot;{routeEndpoint.RoutePattern.OutboundPrecedence}&amp;quot;);
        }

        // output meta data
        sb.AppendLine($&amp;quot;        - Meta Count: {endpoint.Metadata.Count()}&amp;quot;);
        foreach (var meta in endpoint.Metadata)
        {
            sb.AppendLine($&amp;quot;            - Meta Type: {meta}&amp;quot;);
        }
    }

    return sb.ToString();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/routes/info&lt;/code&gt; endpoint, one can see the additional information:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Endpoint: HTTP: GET /routes
            - Segment Count: 1
            - Parameters: 
            - Inbound Precedence: 1
            - Outbound Precedence: 5
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_0(System.Collections.Generic.IEnumerable`1[Microsoft.AspNetCore.Routing.EndpointDataSource])
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /user/{userId}
            - Segment Count: 2
            - Parameters: 
                - userId
            - Inbound Precedence: 1,3
            - Outbound Precedence: 5,3
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_1(System.String)
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /routewithid/{id}
            - Segment Count: 2
            - Parameters: 
                - id
            - Inbound Precedence: 1,3
            - Outbound Precedence: 5,3
            - Meta Count: 3
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_2(Microsoft.AspNetCore.Http.HttpContext, System.String)
                - Meta Type: System.Runtime.CompilerServices.NullableContextAttribute
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
    Endpoint: HTTP: GET /routes/info
            - Segment Count: 2
            - Parameters: 
            - Inbound Precedence: 1,1
            - Outbound Precedence: 5,5
            - Meta Count: 2
                - Meta Type: System.String &amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;b__0_3(System.Collections.Generic.IEnumerable`1[Microsoft.AspNetCore.Routing.EndpointDataSource])
                - Meta Type: Microsoft.AspNetCore.Routing.HttpMethodMetadata
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some examples of the type of information available:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The count and type of each segment making up the endpoint url (e.g. lines 2 and 10)&lt;/li&gt;
&lt;li&gt;The list of parameters for an endpoint (e.g. line 12)&lt;/li&gt;
&lt;li&gt;The lambda delegate for each endpoint (e.g lines 7 and 16)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The metadata information would need to be checked and cast to the specific type to retrieve additional information - but additional information is available.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="httpcontext-route-information"&gt;HttpContext route information&lt;/h2&gt;
&lt;p&gt;Information can also be received from the &lt;code&gt;HttpContext&lt;/code&gt; of a specific request, for the endpoint being called. The information is the same as is contained in the &lt;code&gt;EndpointDataSource.Endpoints&lt;/code&gt; collection used in the above examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/routewithid/{id}&amp;quot;, (HttpContext context, string id) =&amp;gt; 
        $&amp;quot;Route `{context.GetEndpoint()?.DisplayName}` with id = '{id}'&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling this endpoint with an &lt;em&gt;id&lt;/em&gt; of &lt;em&gt;&amp;quot;sampleId&amp;quot;&lt;/em&gt; (&lt;code&gt;/routewithid/sampleId&lt;/code&gt;) results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Route `HTTP: GET /routewithid/{id}` with id = 'sampleid'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;There are a number of useful outputs which could be done using this metadata information, such as outputting the information to be consumed into external api documentation, or &lt;a href="https://andrewlock.net/adding-an-endpoint-graph-to-your-aspnetcore-application/"&gt;adding an endpoint graph to the application&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/list-all-routes-in-an-asp-net-core-application.htm"&gt;How to list all routes in an ASP.NET Core application&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0"&gt;Routing in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;86: 01-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Generic attributes with C#11</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/31-generic-attribute</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/31-generic-attribute</guid>
			<pubDate>Mon, 30 May 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming in C# 11 (later this year with .NET 7) is the &lt;code&gt;generic attributes&lt;/code&gt; feature - the ability to define an attribute which takes a generic parameter. This is a more convenient style for attributes which require a &lt;code&gt;Type&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;Generic attribute code samples below were written using the .NET 7 preview release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre-c-11-type-parameter"&gt;Pre C# 11 - Type parameter&lt;/h2&gt;
&lt;p&gt;Sometimes an attribute needs to take a &lt;code&gt;Type&lt;/code&gt; parameter - currently (using any version prior to C# 11) the only way to do this is passing a &lt;code&gt;Type&lt;/code&gt; parameter to the constructor.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[System.AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
public class TypeAttribute : Attribute
{
    readonly Type _classType;

    public TypeAttribute(Type classType)
    {
        if(classType is not IMarkerInterface)
        {
             throw new Exception($&amp;quot;Parameter '{classType}'&amp;quot; +
                $&amp;quot; must implement `IMarkerInterface`&amp;quot;);
        }

        _classType = classType;
    }

    public Type ClassType
    {
        get { return _classType; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A drawback of this approach is that if there are any constraints on the type of &lt;code&gt;Type&lt;/code&gt; then a check needs to explicitly be done in the constructor - as is done above, ensuring that the type implements &lt;em&gt;IMarkerInterface&lt;/em&gt;. However this check is &lt;em&gt;only done at runtime&lt;/em&gt;, quite late in the development loop.&lt;/p&gt;
&lt;p&gt;Usage of the above attribute:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TypeParam(typeof(ImplementationType))]
public class UsingTypeAttribute
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="c-11-generic-attribute"&gt;C# 11 - Generic attribute&lt;/h2&gt;
&lt;p&gt;C# 11 introduces generic attributes - which use the same syntax as generic classes or methods. Below is the same attribute as above, but implemented using generics:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[System.AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
public class GenericTypeAttribute&amp;lt;T&amp;gt; : Attribute where T : IMarkerInterface
{
    public GenericTypeAttribute()
    {
    }

    public Type ClassType
    {
        get { return typeof(T); }
    }
}
``

As one can see, the code is a lot cleaner, with the type of `Type` being constrained as part of the generics - no need to manually check the type in the constructor. The check is also automatically performed at compile time so any issues with the `Type` are picked up earlier.

Usage of the above attribute is also cleaner:

``` csharp
[GenericType&amp;lt;ImplementationType&amp;gt;]
public class UsingGenericAttribute
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this may not be something used every day by everyone, for those which do use it, it will be an incredibly useful upgrade - bringing more standardization across the various parts of the C# language.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11#generic-attributes"&gt;Generic attributes&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;85: 31-05-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>LINQ First and Single performance</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/30-linq-first-performance</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/30-linq-first-performance</guid>
			<pubDate>Sun, 29 May 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using LINQ to retrieve a value from a collection, there are a number of different techniques - however not all are equal in terms of performance.&lt;/p&gt;
&lt;p&gt;Today we'll explore the various methods and their comparative performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="first-performance"&gt;First performance&lt;/h2&gt;
&lt;p&gt;First, we'll look at the various ways to retrieve a single value using variations of &lt;code&gt;First&lt;/code&gt;, when &lt;strong&gt;multiple&lt;/strong&gt; values match the condition:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// populate with 10000 values
int[] values = values = Enumerable.Range(0, 10000).ToArray();

// Only using First
var firstValue = values.First(v =&amp;gt; v &amp;gt; 400);

// Only FirstOrDefault
var firstDefaultValue = values.FirstOrDefault(v =&amp;gt; v &amp;gt; 400);

// Where and then First
var whereFirstValue = values.Where(v =&amp;gt; v &amp;gt; 400).First();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, an array of 10000 items is populated, and when we look at three ways to find the &lt;em&gt;First&lt;/em&gt; value greater than 400.&lt;/p&gt;
&lt;p&gt;Benchmarking the above scenario using BenchmarkDotNet, the results are as follows (using .NET6):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;First&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,330.2 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20.03 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;18.74 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FirstOrDefault&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,330.7 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.28 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;18.04 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WhereFirst&lt;/td&gt;
&lt;td style="text-align: right;"&gt;722.3 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.27 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.73 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Interestingly, the &lt;code&gt;Where().First()&lt;/code&gt; approach is 3 times faster than &lt;code&gt;First&lt;/code&gt; or &lt;code&gt;FirstOrDefault&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The benchmarks were also performed using a &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; as well as an &lt;code&gt;Array[100]&lt;/code&gt; (with the condition being &amp;gt; 40). The results were roughly the same, with the &lt;code&gt;WhereFirst&lt;/code&gt; approach &lt;code&gt;2-3 times&lt;/code&gt; faster than &lt;em&gt;First&lt;/em&gt; or &lt;em&gt;FirstOrDefault&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-performance"&gt;Single performance&lt;/h2&gt;
&lt;p&gt;Next, we'll look at the various ways to retrieve a single value using variations of &lt;code&gt;First/Single&lt;/code&gt;, when a &lt;strong&gt;single&lt;/strong&gt; value matches the condition:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// populate with 10000 values
int[] values = values = Enumerable.Range(0, 10000).ToArray();

// Only using First
var firstValue = values.First(v =&amp;gt; v == 450);

// Only FirstOrDefault
var firstDefaultValue = values.FirstOrDefault(v =&amp;gt; v == 450);

// Only Single
var singleValue = values.Single(v =&amp;gt; v == 450);

// Only SingleOrDefault
var singleOrDefaultValue = values.SingleOrDefault(v =&amp;gt; v == 450);

// Where and then First
var whereFirstValue = values.Where(v =&amp;gt; v == 450).First();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, an array of 10000 items is populated, and when we look at five ways to find the &lt;em&gt;First&lt;/em&gt; or &lt;em&gt;Single&lt;/em&gt; value equal to 450.&lt;/p&gt;
&lt;p&gt;Benchmarking the above scenario using BenchmarkDotNet, the results are as follows (using .NET6):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FirstOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,342.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;28.89 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;25.61 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FirstOrDefaultOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,341.8 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.82 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.34 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;53,322.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;403.26 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;357.48 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;22.77&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleOrDefaultOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;55,948.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;463.01 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;433.10 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;23.87&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WhereFirstOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;698.9 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.24 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.90 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As before, &lt;code&gt;Where().First()&lt;/code&gt; is the quickest approach being 3 times faster than &lt;em&gt;First&lt;/em&gt; or &lt;em&gt;FirstOrDefault&lt;/em&gt;, while using &lt;em&gt;Single&lt;/em&gt; is &lt;code&gt;22 times slower&lt;/code&gt; than &lt;em&gt;First&lt;/em&gt; and approximately &lt;code&gt;75 times slower&lt;/code&gt; than &lt;em&gt;Where().First()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The benchmarks were also performed using a &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; with 10000 items - the results were roughly the same, with the &lt;code&gt;WhereFirst&lt;/code&gt; approach &lt;code&gt;2-3 times&lt;/code&gt; faster than &lt;em&gt;First&lt;/em&gt; or &lt;em&gt;FirstOrDefault&lt;/em&gt; and &lt;code&gt;65 times faster&lt;/code&gt; than &lt;em&gt;Single&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, when performed with &lt;code&gt;Array[100]&lt;/code&gt; (with the condition being = 45) the differences between the various methods is not as drastic:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FirstOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;256.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.19 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.05 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FirstOrDefaultOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;258.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.02 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.89 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;574.3 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;11.07 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.24 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SingleOrDefaultOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;529.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.23 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.02 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.07&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WhereFirstOneValue&lt;/td&gt;
&lt;td style="text-align: right;"&gt;107.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.25 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.42&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;We've looked at various techniques to get a value from an enumeration of varying sizes - in all use cases performed for this post &lt;code&gt;Where().First()&lt;/code&gt; was the fastest approach. but this might not always be the same for all possible use cases.&lt;/p&gt;
&lt;p&gt;Keep in mind that the size of the collection, and the method used &lt;em&gt;does&lt;/em&gt; have a performance impact (admittedly nanoseconds, but in the right hot path it could make a material difference) and the various methods should be benchmarked with your specific use case to determine the correct method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leveluppp.ghost.io/content/images/size/w1000/2021/12/linq.png"&gt;LINQ optimizations in .NET can be surprising&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;84: 30-05-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Raw string literals in .NET7</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/27-raw-string-literals</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/27-raw-string-literals</guid>
			<pubDate>Thu, 26 May 2022 23:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The new &lt;code&gt;raw string literals&lt;/code&gt; feature coming as part of .NET7 (now available through the .NET7 preview) is a new format for dealing with strings, which allows for literals to contain  whitespace, new lines, embedded quotes and other special characters &lt;code&gt;without escape sequences&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This new feature is especially useful when working with embedded language strings JSON, XML, HTML etc.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="pre-raw-string-literals"&gt;Pre raw string literals&lt;/h2&gt;
&lt;p&gt;Prior to the raw string literal functionality (before C#11), if building up a JSON string, especially when using string interpolation, a large number of escape characters were required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var name = &amp;quot;Dave Grohl&amp;quot;;
var age = 42;
var isActive = true;
var addressLine1 = &amp;quot;1 Main Street&amp;quot;;
var addressLine2 = &amp;quot;Cape Town&amp;quot;;
var postalCode = &amp;quot;8000&amp;quot;;

var jsonString =
$&amp;#64;&amp;quot;{{
    &amp;quot;&amp;quot;Name&amp;quot;&amp;quot;: &amp;quot;&amp;quot;{name}&amp;quot;&amp;quot;,
    &amp;quot;&amp;quot;Age&amp;quot;&amp;quot;: {age},
    &amp;quot;&amp;quot;IsActive&amp;quot;&amp;quot;: {isActive.ToString().ToLower()},
    &amp;quot;&amp;quot;DateCreated&amp;quot;&amp;quot;: &amp;quot;&amp;quot;{DateTime.Now.ToString()}&amp;quot;&amp;quot;,
    &amp;quot;&amp;quot;Address&amp;quot;&amp;quot; : {{
        &amp;quot;&amp;quot;AddressLine1&amp;quot;&amp;quot;: &amp;quot;&amp;quot;{addressLine1}&amp;quot;&amp;quot;,
        &amp;quot;&amp;quot;AddressLine2&amp;quot;&amp;quot;: &amp;quot;&amp;quot;{addressLine2}&amp;quot;&amp;quot;,
        &amp;quot;&amp;quot;PostalCode&amp;quot;&amp;quot;: &amp;quot;&amp;quot;{postalCode}&amp;quot;&amp;quot;
    }}
}}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, each time a quote is required, it needs to be escaped with another quote. Each time a brace is required, it needs to be escaped with another brace. Depending on how complicated the embedded string is, this can lead to an unwieldy mess of escape characters.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="raw-string-literals"&gt;Raw string literals&lt;/h2&gt;
&lt;p&gt;A raw string literal starts with at least three double-quotes &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;, and ends with the same number of double quotes. Within these three double-quotes, single quotes &lt;code&gt;&amp;quot;&lt;/code&gt; are now considered content and included in the string.&lt;/p&gt;
&lt;p&gt;Any number of quotes &lt;code&gt;less than the number that opened the raw string literal&lt;/code&gt; will be considered content.&lt;/p&gt;
&lt;p&gt;A similar approach is used for string interpolation - the number of &lt;code&gt;$&lt;/code&gt; which prefixes the string, is the number of braces required to to indicate a nested code expression. &lt;code&gt;Any number less will be considered content.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let's look at a few examples.&lt;/p&gt;
&lt;p&gt;The same example from above, but now using raw string literals:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var name = &amp;quot;Dave Grohl&amp;quot;;
var age = 42;
var isActive = true;
var addressLine1 = &amp;quot;1 Main Street&amp;quot;;
var addressLine2 = &amp;quot;Cape Town&amp;quot;;
var postalCode = &amp;quot;8000&amp;quot;;

var rawLiteralJsonString = $$&amp;quot;&amp;quot;&amp;quot;
{
    &amp;quot;Name&amp;quot;: &amp;quot;{{name}}&amp;quot;,
    &amp;quot;Age&amp;quot;: {{age}},
    &amp;quot;IsActive&amp;quot;: {{isActive.ToString().ToLower()}},
    &amp;quot;DateCreated&amp;quot;: &amp;quot;{{DateTime.Now.ToString()}}&amp;quot;,
    &amp;quot;Address&amp;quot; : {
        &amp;quot;AddressLine1&amp;quot;: &amp;quot;{{addressLine1}}&amp;quot;,
        &amp;quot;AddressLine2&amp;quot;: &amp;quot;{{addressLine2}}&amp;quot;,
        &amp;quot;PostalCode&amp;quot;: &amp;quot;{{postalCode}}&amp;quot;
    }
}
&amp;quot;&amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The literal is opened with 3 double quotes, and hence 1 or 2 double-quotes (any number less than the number used to open the literal) inside the literal will be considered content&lt;/li&gt;
&lt;li&gt;The literal is prefixed with 2 dollar signs &lt;code&gt;$&lt;/code&gt;, and hence 1 brace will be considered content, while 2 will be considered the indication for nested code&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;If more than 1 or 2 double-quotes are required in the string, then the number of opening double-quotes can be increased:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var singleQuotes = &amp;quot;&amp;quot;&amp;quot;This string contains a &amp;quot;quoted&amp;quot; word&amp;quot;&amp;quot;&amp;quot;;
var doubleQuotes = &amp;quot;&amp;quot;&amp;quot;This string contains a doubled &amp;quot;&amp;quot;quoted&amp;quot;&amp;quot; word&amp;quot;&amp;quot;&amp;quot;;
var tripleQuotes = &amp;quot;&amp;quot;&amp;quot;&amp;quot;This string contains a triple &amp;quot;&amp;quot;&amp;quot;quoted&amp;quot;&amp;quot;&amp;quot; word&amp;quot;&amp;quot;&amp;quot;&amp;quot;;

Console.WriteLine(singleQuotes);
Console.WriteLine(doubleQuotes);
Console.WriteLine(tripleQuotes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, the first two strings only required 1 and 2 double-quotes respectively, so opening with 3 double-quotes works. In the third string, 3 double-quotes are required in the content, so the raw string literal is opened with 4 double-quotes.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A similar process can be used for braces:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var singleBraces = $$&amp;quot;&amp;quot;&amp;quot;This string contains a {braced} word&amp;quot;&amp;quot;&amp;quot;;
var doubleBraces = $$$&amp;quot;&amp;quot;&amp;quot;This string contains a doubled {{braced}} word&amp;quot;&amp;quot;&amp;quot;;
var tripleBraces = $$$$&amp;quot;&amp;quot;&amp;quot;This string contains a triple {{{braced}}} word&amp;quot;&amp;quot;&amp;quot;;

Console.WriteLine(singleBraces);
Console.WriteLine(doubleBraces);
Console.WriteLine(tripleBraces);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If braces are required in the string content, the number of &lt;code&gt;$&lt;/code&gt; prefixing the string needs to be &lt;code&gt;1 more&lt;/code&gt; than the number of consecutive braces in the string. In the third string example above, 3 braces are requires, so 4 &lt;code&gt;$&lt;/code&gt; are required. To use string interpolation and a nested code expression, 4 &lt;code&gt;$&lt;/code&gt; would need to be used to break out the string.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var tripleValue = &amp;quot;Triple&amp;quot;;
var tripleBracesInterpolation = $$$$&amp;quot;&amp;quot;&amp;quot;{{{{tripleValue}}}} {{{braced}}} word&amp;quot;&amp;quot;&amp;quot;;
Console.WriteLine(tripleBracesInterpolation);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While is may seem a bit convoluted at first, once the basics are understood, this is an incredibly powerful and useful feature, especially dealing with embedded string (such as JSON in the above example). It makes figuring out the correct sequence of escape characters much easier, as well as make the code more readable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11#raw-string-literals"&gt;Raw string literals&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;83: 27-05-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>IEnumerable count without enumeration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/26-trygetnonenumeratedcount</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/26-trygetnonenumeratedcount</guid>
			<pubDate>Thu, 26 May 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; method (introduced in .NET6) can be used to &lt;em&gt;attempt&lt;/em&gt; to determine the number of elements in a sequence without forcing an enumeration over the sequence.&lt;/p&gt;
&lt;p&gt;Some implementations of IEnumerable&amp;lt;&amp;gt; can have the count determined without enumerating over all the items, while other implementations require an enumeration. &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; will perform a series of type tests, identifying common types whose count can be determined without enumerating.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;Consider the following sample - first, a method which will return an &lt;code&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/code&gt; of shipping options:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public IEnumerable&amp;lt;string&amp;gt; GetShippingOptions()
{
    yield return &amp;quot;Pickup&amp;quot;;
    yield return &amp;quot;Express&amp;quot;;
    yield return &amp;quot;Overnight&amp;quot;;
    yield return &amp;quot;Standard&amp;quot;;
    yield return &amp;quot;Overseas shipping&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we have a method which accepts an &lt;code&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/code&gt; implementation, and will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try to get the count without enumerating using the &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;If unable to get the count without enumerating, then enumerate the sequence using the &lt;code&gt;Count&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;Return the count of items in the sequence&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int GetCount(IEnumerable&amp;lt;string&amp;gt; options)
{
    if (options.TryGetNonEnumeratedCount(out var count))
    {
        Console.WriteLine($&amp;quot;TryGetNonEnumeratedCount success! Count =&amp;gt; {count}&amp;quot;);
        return count;
    }
    else
    {
        var enumerateCount = options.Count();
        Console.WriteLine($&amp;quot;TryGetNonEnumeratedCount fail! &amp;quot; +
            $&amp;quot;Have to enumerate. Count =&amp;gt; {enumerateCount}&amp;quot;);
        return enumerateCount;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, lets call the &lt;em&gt;GetCount&lt;/em&gt; method with different implementations of &lt;code&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// options is IEnumerable&amp;lt;string&amp;gt; as per 
// GetShippingOptions return type
var options = GetShippingOptions();

var ienumerableCount = GetCount(options);
var listCount = GetCount(options.ToList());
var arrayCount = GetCount(options.ToArray());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing this, the output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;TryGetNonEnumeratedCount fail! Have to enumerate. Count =&amp;gt; 5
TryGetNonEnumeratedCount success! Count =&amp;gt; 5
TryGetNonEnumeratedCount success! Count =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When working with IEnumerable, and various implementations, it might be advantageous (with regards to performance) to first check if the count can be retrieved without enumerating, using the &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; method, and only if that's not possible then using a method (such as &lt;code&gt;Count&lt;/code&gt;) which enumerates over the sequence.&lt;/p&gt;
&lt;p&gt;As always, benchmark your specific use case and expected IEnumerable size, to determine which method makes sense and results in better performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1445465841491795975"&gt;Avoiding enumeration with 'TryGetNonEnumeratedCount'&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;82: 26-05-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Introduction to the SQL MERGE</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/25-sql-merged</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/25-sql-merged</guid>
			<pubDate>Wed, 25 May 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;SQL MERGE&lt;/code&gt; statement can be used to perform an INSERT, UPDATE and/or DELETE all in one statement.&lt;/p&gt;
&lt;p&gt;This post is just an introduction and does not address any performance issues or other bugs with the statement. See &lt;a href="https://www.mssqltips.com/sqlservertip/3074/use-caution-with-sql-servers-merge-statement/"&gt;here&lt;/a&gt; (although out of date) for a list of potential bugs.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the below examples, we have a main &lt;code&gt;Order&lt;/code&gt; table, which stores orders in our e-commerce system. However, orders placed via the mobile app are initially saved into a separate system - but then end up temporarily in the &lt;em&gt;Order_Incoming&lt;/em&gt; table, to then be &lt;em&gt;merged&lt;/em&gt; into the main &lt;code&gt;Order&lt;/code&gt; table to give a single view of customer orders.&lt;/p&gt;
&lt;p&gt;The below script will setup the various tables as well as some seed data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;IF EXISTS (SELECT 1 FROM SYS.TABLES where name ='Order')
BEGIN 
	DROP TABLE [Order]
END
 
IF EXISTS (SELECT 1 FROM SYS.TABLES where name ='Order_Incoming')
BEGIN 
	DROP TABLE [Order_Incoming]
END
GO
  
CREATE TABLE [dbo].[Order](
  [OrderId] [int] IDENTITY(1,1) NOT NULL,
  [OrderNumber] [varchar](100) NULL,
  [OrderTotal] int
) 
 
CREATE TABLE [dbo].[Order_Incoming](
  [OrderNumber] [varchar](100) NULL,
  [OrderTotal] int
) 

-- create some orders
INSERT INTO [Order]
SELECT 'ORD0001', 32 UNION
SELECT 'ORD0002', 654 UNION
SELECT 'ORD0003', 104
SELECT 'ORDAPP0001', 99

-- incoming orders, 1 existing and 2 new
INSERT INTO [Order_Incoming]
SELECT 'ORDAPP0001', 110 UNION
SELECT 'ORDAPP0002', 43 UNION
SELECT 'ORDAPP0003', 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The tables beforehand:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Order table:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/order_before.png" alt="Order table before"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Order_Incoming table:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/order_incoming.png" alt="Order_Incoming table before"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="non-merge-example"&gt;Non-MERGE example&lt;/h3&gt;
&lt;p&gt;First, lets look at an example where we are doing an INSERT and separate UPDATE to ensure that the data in &lt;em&gt;Order_Incoming&lt;/em&gt; is inserted or updated into &lt;em&gt;Order&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Insert where the data DOESN'T exist
INSERT INTO [Order]
SELECT OrderNumber, OrderTotal
FROM Order_Incoming oi
WHERE NOT EXISTS(
	SELECT o2.OrderId
    FROM [Order] o2
    WHERE oi.OrderNumber = o2.OrderNumber) 

-- update where the data DOES exist
UPDATE [Order]
SET OrderTotal = oi.OrderTotal
FROM Order_Incoming oi
WHERE [Order].OrderNumber = oi.OrderNumber
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After these statements, the &lt;em&gt;Order&lt;/em&gt; table is updated correct and is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/order_after_statements.png" alt="Order table after INSERT and UPDATE"&gt;&lt;/p&gt;
&lt;p&gt;These two statements clearly work and result in the desired state - but we have two different statements here to ensure the data in &lt;em&gt;Order&lt;/em&gt; table is updated and correct.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="merge"&gt;MERGE&lt;/h3&gt;
&lt;h4 id="merge-statement"&gt;MERGE statement&lt;/h4&gt;
&lt;p&gt;The format of the MERGE statement as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;MERGE target_table USING source_table
ON merge_condition
WHEN MATCHED
    THEN update_statement
WHEN NOT MATCHED
    THEN insert_statement
WHEN NOT MATCHED BY SOURCE
    THEN DELETE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target table&lt;/code&gt; is specified, as well as &lt;code&gt;how to match data&lt;/code&gt; between the two tables, and what action should be performed when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;there is a &lt;code&gt;match of data&lt;/code&gt; between the two tables&lt;/li&gt;
&lt;li&gt;there is &lt;code&gt;no match&lt;/code&gt;, and the data exists in the &lt;code&gt;target table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;there is &lt;code&gt;no match&lt;/code&gt;, and the data exists in the &lt;code&gt;source table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="merge-example"&gt;MERGE example&lt;/h4&gt;
&lt;p&gt;Let's rewrite the non-merge example from above to use the SQL MERGE statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;MERGE [Order] o USING [Order_Incoming] oi
ON o.[OrderNumber] = oi.[OrderNumber]
WHEN MATCHED THEN 
	UPDATE SET o.OrderTotal = oi.OrderTotal
WHEN NOT MATCHED BY TARGET
	THEN 
	INSERT (OrderNumber, OrderTotal)
	VALUES (oi.OrderNumber, oi.OrderTotal);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are specifying the &lt;em&gt;Order&lt;/em&gt; table as the target, and the &lt;em&gt;Order_Incoming&lt;/em&gt; table as the source - with the data matched on the &lt;em&gt;OrderNumber&lt;/em&gt; column.
Where there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is a &lt;code&gt;match&lt;/code&gt;: update the &lt;em&gt;Order&lt;/em&gt; table with the total from the &lt;em&gt;Order_Incoming&lt;/em&gt; table&lt;/li&gt;
&lt;li&gt;is &lt;code&gt;no match in the target&lt;/code&gt; &lt;em&gt;Order&lt;/em&gt; table: insert data from &lt;em&gt;Order_Incoming&lt;/em&gt; into &lt;em&gt;Order&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;is &lt;code&gt;no match in the source&lt;/code&gt; &lt;em&gt;Order_Incoming&lt;/em&gt; table: do nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This SQL statement has the same results as the INSERT and UPDATE statements as above - however is simpler to read and understand as well as being more concise.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Even though I've been working with SQL for approximately 20 years - I've only come across the MERGE statement recently. This would have been incredibly useful earlier in my career when all data access statements were written by hand. More recently though, all (most) data access I've done has been through Entity Framework, which abstracts most of the SQL statements away.&lt;/p&gt;
&lt;p&gt;However knowing MERGE exists and what it can do, can be very useful in situations where you have to write the SQL manually. As with most things, the MERGE statement is not the solution to every problem, and should be benchmarked against other possible solutions (such as a INSERT + UPDATE).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.sqlservertutorial.net/sql-server-basics/sql-server-merge/"&gt;SQL Server MERGE&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;81: 25-05-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Value type default values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/05/24-value-type-default-value</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/05/24-value-type-default-value</guid>
			<pubDate>Tue, 24 May 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Value Types&lt;/code&gt; by default, have to have a value and cannot be null in C# - even if uninitialized. This can lead to unexpected results if comparing a value type to null instead of the default value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="null-comparison"&gt;Null comparison&lt;/h2&gt;
&lt;p&gt;Consider the below example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program
{
    static Point pointValue;
    static int IntValue;

    static void Main(string[] args)
    {
        // comparing an uninitialized Point to null
        Console.WriteLine(pointValue == null);  
        Console.WriteLine(IntValue == null);  
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    False
    False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both the Point and int types are &lt;code&gt;value types&lt;/code&gt; and as such have default values of (0, 0) and 0 respectively (&lt;strong&gt;not null&lt;/strong&gt;), even if uninitialized.&lt;/p&gt;
&lt;p&gt;So instead of comparing to &lt;strong&gt;null&lt;/strong&gt;, we need to check if they are &lt;code&gt;empty&lt;/code&gt; or have the &lt;code&gt;default value&lt;/code&gt; for the type.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="isempty-comparison"&gt;IsEmpty comparison&lt;/h2&gt;
&lt;p&gt;Some value types (not but all), have a &lt;code&gt;IsEmpty&lt;/code&gt; property which will return true if uninitialized or explicitly set to the default value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program
{
    static Point pointValue;
    static Point pointValue2 = new Point(0,0);
    static int IntValue;
    
    static void Main(string[] args)
    {
        Console.WriteLine(pointValue.IsEmpty);    
        Console.WriteLine(pointValue2.IsEmpty);   
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this is now:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    True
    True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both variables are considered empty as they both have the default value. &lt;code&gt;int&lt;/code&gt; does not have an &lt;em&gt;IsEmpty&lt;/em&gt; property, so cannot be checked using this method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="default-comparison"&gt;default comparison&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;default&lt;/code&gt; keyword (which will produced the default value of a type) can be compared to a value type to determine if it has the default value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program
{
    static Point pointValue;
    static Point pointValue2 = new Point(0,0);
    static int IntValue;
    
    static void Main(string[] args)
    {
        Console.WriteLine(pointValue == default);  
        Console.WriteLine(pointValue2 == default); 
        Console.WriteLine(IntValue == default); 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this is now:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    True
    True
    True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, &lt;code&gt;default&lt;/code&gt; works for &lt;em&gt;Point&lt;/em&gt; and &lt;em&gt;int&lt;/em&gt;, and in fact it will work with all types.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nullable-types"&gt;Nullable types&lt;/h2&gt;
&lt;p&gt;A value type can made &lt;code&gt;nullable&lt;/code&gt; indicating it &lt;em&gt;can&lt;/em&gt; have a null value. This is done using the &lt;code&gt;?&lt;/code&gt; indicator. In the below sample, each variable is now marked with &lt;code&gt;?&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program
{
    static Point? pointValue;
    static Point? pointValue2 = new Point(0,0);
    static int? IntValue;
    
    static void Main(string[] args)
    {
        Console.WriteLine(pointValue == null);
        Console.WriteLine(pointValue2 == null);
        Console.WriteLine(IntValue == null);    
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when comparing these values to &lt;code&gt;null&lt;/code&gt; the output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    True
    False
    True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a nullable value type is not initialized, it will have a null value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Value type comparison&lt;/code&gt; is a small detail in a large application, but if done incorrectly can lead to unexpected results. Its important to understand how the value type variables are set (or not set) and how each one can be checked for a null or default value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make"&gt;Common C# Programming Mistake #2: Misunderstanding default values for uninitialized variables&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;80: 24-05-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>