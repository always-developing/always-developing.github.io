<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2023</copyright>
		<pubDate>Mon, 23 Jan 2023 03:38:37 GMT</pubDate>
		<lastBuildDate>Mon, 23 Jan 2023 03:38:37 GMT</lastBuildDate>
		<item>
			<title>Task.Delay accuracy</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</guid>
			<pubDate>Mon, 23 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Task.Delay&lt;/code&gt; relies on the underlying operating system's internal timer, which for most Windows environments, takes about 15ms to resolve. This means that the &lt;em&gt;minimum amount of time that can be accurately used with Task.Delay is approximately 15ms (on Windows)&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Diagnostics.StopWatch&lt;/code&gt; can be used to benchmark how long a &lt;code&gt;Task.Delay&lt;/code&gt; call actually takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(100);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, the result (which may vary each execution and per machine):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 110 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the code is specifying a 100ms delay, and actual delay is close to 110ms.&lt;/p&gt;
&lt;p&gt;The same &lt;em&gt;inaccurate&lt;/em&gt; delay is seen when trying to delay for a small precise time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(5);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 19 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results may vary, but (in my case) the true delay was never less than 17ms. As mentioned, this is due to the underlying operating system's internal timer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If requiring small precise waiting times, &lt;code&gt;Task.Delay&lt;/code&gt; is not the way to go. In fact there are no &amp;quot;easy&amp;quot; ways to wait for such small precise times - there are ways to do it (which will not be shown here), but they are involved and are often not very performant when it comes to resource usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/#dont-use-taskdelay-for-small-precise-waiting-times"&gt;Don’t use Task.Delay for small precise waiting times&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;240: 23-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>LINQ Any/All over Count</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/20-linq-count</guid>
			<pubDate>Fri, 20 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In most scenarios, the LINQ &lt;code&gt;All&lt;/code&gt; or &lt;code&gt;Any&lt;/code&gt; methods should be used instead of the &lt;code&gt;Count&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; should be avoided, as it &lt;em&gt;enumerates through every single entry in the collection to get the count&lt;/em&gt;, where &lt;code&gt;Any/All&lt;/code&gt; will &lt;em&gt;return as soon as the predicate condition is not met anymore&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;All of the below examples, use the following collection:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var intList = Enumerable.Range(1, 10);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="no-predicate"&gt;No predicate&lt;/h3&gt;
&lt;p&gt;When required to check if a list contains &lt;em&gt;any&lt;/em&gt; items, the &lt;code&gt;Any&lt;/code&gt; method should be used instead of &lt;code&gt;Count&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() &amp;gt; 0);
// Good
Console.WriteLine(intList.Any());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, when &lt;code&gt;Count&lt;/code&gt; is used, 10 items needs to be enumerated to get the full count, however &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; after one iteration, as soon as one item is found.&lt;br /&gt;
With only 10 items, the difference is negligible, however as the number of items in the collection increased, the difference will become more noticeable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="with-predicate"&gt;With predicate&lt;/h3&gt;
&lt;p&gt;The same logic applies when a &lt;em&gt;predicate is supplied&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 5) &amp;gt; 0);
// Good
Console.WriteLine(intList.Any(i =&amp;gt; i &amp;gt; 5));

// Bad
Console.WriteLine(intList.Count(i =&amp;gt; i &amp;gt; 10) == 0);
// Good
Console.WriteLine(!intList.Any(i =&amp;gt; i &amp;gt; 10));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Count&lt;/code&gt; method will need to enumerable over all items in the collection, while &lt;code&gt;Any&lt;/code&gt; will return &lt;em&gt;true&lt;/em&gt; as soon as the first item which satisfies the predicate is reached.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="all-items"&gt;All items&lt;/h3&gt;
&lt;p&gt;Similar logic applies when &lt;code&gt;All&lt;/code&gt; items in the collection need to be checked:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Bad
Console.WriteLine(intList.Count() == intList.Count(i =&amp;gt; i  &amp;lt; 100));
// Good
Console.WriteLine(intList.All(i =&amp;gt; i &amp;lt; 100));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, with &lt;code&gt;Count&lt;/code&gt;, all items in the collection are enumerated over, while the &lt;code&gt;All&lt;/code&gt; method will return &lt;em&gt;false&lt;/em&gt; as soon as one item is reached which does not satisfy the predicate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally, unless &lt;code&gt;Count&lt;/code&gt; specifically needs to be used, &lt;code&gt;Any&lt;/code&gt; or &lt;code&gt;All&lt;/code&gt; should be preferred, especially as the number of items in the collection increases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/linq/#using-count-instead-of-all-or-any"&gt;Using Count() instead of All or Any&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;239: 20-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Eliding await keyword</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/19-elide-await</guid>
			<pubDate>Thu, 19 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple &lt;em&gt;async method&lt;/em&gt; are called in a sequence, the &lt;code&gt;async methods should be elided&lt;/code&gt; and the &lt;em&gt;Tasks&lt;/em&gt; should be &lt;em&gt;awaited&lt;/em&gt; and not passed up the call stack.&lt;/p&gt;
&lt;p&gt;If a &lt;em&gt;Task&lt;/em&gt; is passed up the stack, and an exception occurs - the Task which is not &lt;em&gt;awaited&lt;/em&gt; will not be part of the error stack trace.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-await-exception"&gt;No await exception&lt;/h2&gt;
&lt;p&gt;In the below code snippet, we have a call stack where a &lt;em&gt;Task&lt;/em&gt; is &lt;code&gt;not awaited immediately&lt;/code&gt;, but passed up the call stack to be awaited:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await NoAwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

// return a Task
static Task NoAwaitMethod()
{
    // call a method which returns a Task but 
    // do NOT await
    return ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoAwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, but &lt;strong&gt;does not await the call&lt;/strong&gt;. The method returns the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns - which is the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Running the above code, the call stack generated from the exception is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The stack trace has &lt;code&gt;no mention that the call stack went through the NoAwaitMethod method!&lt;/code&gt;. This is due to the fact that the method is basically just a &lt;em&gt;pass through method&lt;/em&gt; for the &lt;em&gt;Task&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To get a more accurate stack trace, the &lt;em&gt;async method needs to be awaited&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="await-exception"&gt;await exception&lt;/h2&gt;
&lt;p&gt;As mentioned above, instead of a method like &lt;em&gt;NoAwaitMethod&lt;/em&gt;, which serves as a pass through for the &lt;em&gt;Task&lt;/em&gt;, the &lt;code&gt;Task should be awaited&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;wait CallStackStart();

static async Task CallStackStart()
{
    try
    {
        // call a method which returns a task
        await AwaitMethod();
    }
    catch (Exception e)
    {
        Console.WriteLine(&amp;quot;Stacktrace for the exception:&amp;quot;);
        Console.WriteLine(e);
    }
}

static async Task AwaitMethod()
{
    // await the task returned instead
    // of just returning the Task
    await ThrowExceptionAsync();
}

static async Task ThrowExceptionAsync()
{
    await Task.Delay(1);
    throw new Exception(&amp;quot;Manual exception has been thrown&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, starting from the bottom of the call stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThrowExceptionAsync&lt;/code&gt; is an &lt;em&gt;async&lt;/em&gt; method in which an exception could (will in this example) be thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AwaitMethod&lt;/code&gt; calls into &lt;em&gt;ThrowExceptionAsync&lt;/em&gt;, and &lt;strong&gt;awaits the call&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallStackStart&lt;/code&gt; calls into &lt;em&gt;NoAwaitMethod&lt;/em&gt; and &lt;em&gt;awaits&lt;/em&gt; the &lt;em&gt;Task&lt;/em&gt; the method returns.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now running the above code, the full complete stack trace is part of the exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Stacktrace for the exception:
System.Exception: Manual exception has been thrown
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__ThrowExceptionAsync|0_2() in C:\Development\Blog\ElideAwait\Program.cs:line 28
   at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__AwaitMethod|0_1() in C:\Development\Blog\ElideAwait\Program.cs:line 21
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Development\Blog\ElideAwait\Program.cs:line 6 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time we have a &lt;code&gt;full, complete stack trace!&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When &lt;em&gt;await async&lt;/em&gt; is used in conjunction with any &lt;em&gt;exceptions&lt;/em&gt;, the Tasks in question should be elided and &lt;em&gt;awaited&lt;/em&gt; and not passed up the stack trace as it can cause certain methods to be omitted from exception stack traces.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/"&gt;Elide await keyword - Exceptions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;238: 19-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Accurate string length</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/18-string-length</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/18-string-length</guid>
			<pubDate>Wed, 18 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;String.Length&lt;/code&gt; does &lt;em&gt;not always return a &amp;quot;true&amp;quot; accurate length&lt;/em&gt; of the string - instead, the &lt;code&gt;StringInfo.LengthInTextElements&lt;/code&gt; method should be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="string-length"&gt;String Length&lt;/h2&gt;
&lt;p&gt;Generally, for most common string usage, the &lt;code&gt;String.Length&lt;/code&gt; will return the correct length of the string - the number of characters in the string object. However, the number of characters in the string object &lt;code&gt;does not always correspond to the number of characters which reflect on the screen&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.Write(&amp;quot;This string '👍' has the length of: &amp;quot;);
Console.WriteLine(&amp;quot;👍&amp;quot;.Length);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This string '??' has the length of: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The terminal window is unable to render the 👍 emoji, so it is reflected as '??' - but this also gives insight into its length (two question marks, and no one). Even though 👍 reflects as &lt;code&gt;one character when output, it actually consists of two characters in the string object&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="stringinfo-lengthintextelements"&gt;StringInfo LengthInTextElements&lt;/h2&gt;
&lt;p&gt;To get a more accurate string length, the &lt;code&gt;StringInfo.LengthInTextElements&lt;/code&gt; property can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.Write(&amp;quot;This string '👍' has the true length of: &amp;quot;);
Console.WriteLine(new StringInfo(&amp;quot;👍&amp;quot;).LengthInTextElements);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This string '??' has the length of: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;LengthInTextElements&lt;/em&gt; property will return the number of text elements displayed in the terminal.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the length of the string is required for display purposes, and the string could contain &amp;quot;non-traditional&amp;quot; characters, such as emoji's - then the &lt;em&gt;StringInfo.LengthInTextElements&lt;/em&gt; property should be used for more accurate results.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/strings/#getting-the-printable-length-of-a-string-or-character"&gt;Getting the printable length of a string or character&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;237: 18-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Non-generic to generic method call</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/17-non-to-generic</guid>
			<pubDate>Tue, 17 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;dynamic&lt;/code&gt; type can be used in the use case when required to call into a &lt;em&gt;generic method, from a non-generic method&lt;/em&gt;. This is a fairly niche use case, but when required, the &lt;code&gt;dynamic&lt;/code&gt; technique explained below can be of great benefit.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generic-method"&gt;Generic method&lt;/h2&gt;
&lt;p&gt;Assume we have the following simple generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static void GenericMethod&amp;lt;T&amp;gt;(T parameter)
{
    Console.WriteLine($&amp;quot;T is of type: {typeof(T).Name}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method needs to be called from another non-generic method which contains an &lt;code&gt;object&lt;/code&gt; variable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="object-technique"&gt;Object technique&lt;/h3&gt;
&lt;p&gt;Calling into the generic method with an &lt;code&gt;object&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // call into the generic method with the
        // object type
        GenericMethod(randomObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this will compile and &amp;quot;work&amp;quot;, calling the &lt;code&gt;ObjectMethod&lt;/code&gt; method with various types, will result in the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: Object
T is of type: Object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an &lt;code&gt;Object&lt;/code&gt; is being passed to the generic method (even though the underlying types are different), the values are &lt;em&gt;boxed&lt;/em&gt; into that type, and that is what is output.&lt;/p&gt;
&lt;p&gt;If we would like to know the &lt;em&gt;actual&lt;/em&gt; type output, then the &lt;code&gt;dynamic technique&lt;/code&gt; can be used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dynamic-technique"&gt;Dynamic technique&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;dynamic technique&lt;/code&gt; involves casting the &lt;code&gt;object to dynamic&lt;/code&gt; before calling the generic method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Converter
{
    public static void ObjectMethod(object randomObj)
    {
        // cast the object to dynamic
        dynamic dynObj = randomObj;
        GenericMethod(dynObj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, calling the generic method with the same variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Converter.ObjectMethod(&amp;quot;string value&amp;quot;);
Converter.ObjectMethod(1001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;T is of type: String
T is of type: Int32
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A fairly niche use case, and a small difference in code but one which can make a big difference when the use case is encountered. There might be a performance impact with the &lt;em&gt;dynamic technique&lt;/em&gt; (as dynamic generally is less performant), but this might be out-weighed by the benefit the technique gives. As always, if performance is an issue, benchmark and and make an informed decision which technique to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/RogerAlsing/status/1609955500363333632"&gt;Roger Johansson Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;236: 17-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Cancelling a collection iteration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/16-for-cancellation</guid>
			<pubDate>Mon, 16 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When iterating over a collection or items, the &lt;code&gt;TakeWhile&lt;/code&gt; method can be used in conjunction with a &lt;code&gt;CancellationToken&lt;/code&gt; to successfully stop iterating if the parent process is cancelled.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="no-cancellationtoken"&gt;No CancellationToken&lt;/h2&gt;
&lt;p&gt;Generally, when iteration through a collection, a &lt;code&gt;foreach&lt;/code&gt; (or &lt;code&gt;for&lt;/code&gt;) loop is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task ExecuteLoopNoCancel()
{
    // generate a collection of 100 items
    var iterationItems = Enumerable.Range(0, 100);

    // iterate through the 100 items
    foreach (var item in iterationItems)
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the above &lt;code&gt;/ExecuteLoopNoCancel&lt;/code&gt; endpoint has the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processing item: 0
Processing item: 1
Processing item: 2
Processing item: 3
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, and &lt;em&gt;especially in an endpoint which can be cancelled at any time&lt;/em&gt;, is that if the parent process is cancelled, the &lt;code&gt;iteration of the collection will continue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;loop will continue to execute in the background&lt;/em&gt; (and output to the console), as it is being executed &lt;code&gt;asynchronously&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="with-cancellationtoken"&gt;With CancellationToken&lt;/h2&gt;
&lt;p&gt;To correctly &lt;code&gt;cancel the iteration&lt;/code&gt; when the parent process is cancelled, a &lt;code&gt;CancellationToken&lt;/code&gt; should be passed from the top of the stack all the way down to the loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// pass in a CancellationToken
async Task ExecuteLoop(CancellationToken cnlTkn)
{
    var iterationItems = Enumerable.Range(0, 100);

    // only loop while the CancellationToken is not cancelled
    foreach(var item in iterationItems
        .TakeWhile(_ =&amp;gt; !cnlTkn.IsCancellationRequested))
    {
        Console.WriteLine($&amp;quot;Processing item: {item}&amp;quot;);
        await Task.Delay(500);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; token is passed into the endpoint - this is &lt;em&gt;linked&lt;/em&gt; to client, so if the request is &lt;em&gt;cancelled from the client side, the CancellationToken is &amp;quot;notified&amp;quot;&lt;/em&gt; of the cancellation&lt;/li&gt;
&lt;li&gt;In the &lt;em&gt;foreach&lt;/em&gt; loop, the &lt;code&gt;TakeWhile&lt;/code&gt; method is called, with a &lt;code&gt;CancellationToken&lt;/code&gt; passed in as a parameter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, when the endpoint is called (from Postman, for example), and the request is &lt;code&gt;cancelled&lt;/code&gt;, the &lt;em&gt;CancellationToken is marked as cancelled (IsCancellationRequested is set to true), and the iteration will stop&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When performing iterations over a collection, where it makes sense (in situations when the calling process can be cancelled, such as in an endpoint), a &lt;code&gt;CancellationToken&lt;/code&gt; instance should always be used. This ensures any iterations being done asynchronously will be cancelled, ensuring resources are not being unessacary used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/vekzdran/status/1610197203901091840"&gt;&amp;#64;vekzdran&amp;#64;hachyderm.io Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;235: 16-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Naming minimal endpoints</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/13-endpoint-withname</guid>
			<pubDate>Fri, 13 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A minimal endpoint can be &lt;code&gt;given a name&lt;/code&gt;, which can then be leveraged to &lt;code&gt;automatically generate a link to the endpoint&lt;/code&gt; making it easier to be invoked.&lt;/p&gt;
&lt;p&gt;The endpoint name metadata is also treated as the &lt;em&gt;operation Id&lt;/em&gt; in the OpenAPI specification, which is used by tools which use the swagger file to generate a client.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint"&gt;Named endpoint&lt;/h2&gt;
&lt;p&gt;The first step is to give the endpoint a name - this is very simply and involves using the &lt;em&gt;WithName&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the default sample endpoint
app.MapGet(&amp;quot;/weatherforecast&amp;quot;, () =&amp;gt;
{
    WeatherForecast[]? forecast = Enumerable.Range(1, 5).Select(index =&amp;gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
// give it a name
.WithName(&amp;quot;GetWeatherForecast&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the body of the minimal API is defined, the &lt;em&gt;WithName&lt;/em&gt; method is called, with the endpoint name supplied. In this example the sample &lt;em&gt;/weatherforecast&lt;/em&gt; endpoint is given the name &lt;code&gt;GetWeatherForecast&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="link-generation"&gt;Link generation&lt;/h2&gt;
&lt;p&gt;This &lt;em&gt;endpoint name&lt;/em&gt; can now be used to generate a URL to the endpoint - this is done using the &lt;code&gt;LinkGenerator&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject LinkGenerator from DI
app.MapGet(&amp;quot;/generateUrl&amp;quot;, (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    // use the name to get a link to the GetWeatherForecast endpoint
    return generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code defines an endpoint, which when invoked will return the URL of the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint. Browsing to the &lt;code&gt;/generateUrl&lt;/code&gt; endpoint returns the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;http://localhost:5276/weatherforecast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The full URL (including port etc) is automatically calculated by the &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; method, based on the &lt;em&gt;HttpContext&lt;/em&gt; and the &lt;em&gt;endpoint name&lt;/em&gt;. &lt;em&gt;LinkGenerator&lt;/em&gt; is available through the dependency injection container and can just be injected into the relevent constructor/delegate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="named-endpoint-invocation"&gt;Named endpoint invocation&lt;/h2&gt;
&lt;p&gt;A practical use of this functionality is &lt;em&gt;when an endpoint is required to call another endpoint in the same application&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/weatherforecastproxy&amp;quot;, async (HttpContext context, LinkGenerator generator) =&amp;gt;
{
    HttpClient? client = new HttpClient();

    // get the URL for the &amp;quot;GetWeatherForecast&amp;quot; endpoint
    // and create an HttpRequestMessage for it
    HttpRequestMessage? request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;GET&amp;quot;),
        generator.GetUriByName(context, &amp;quot;GetWeatherForecast&amp;quot;, null)
    );

    // invoke it
    HttpResponseMessage? response = client.Send(request);
    return await response.Content.ReadAsStringAsync();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, calling &lt;code&gt;/weatherforecastproxy&lt;/code&gt; will proxy the call to the &lt;code&gt;GetWeatherForecast&lt;/code&gt; endpoint and returns the result - this proxy endpoint is not adding much value in this sample, but it could do more complicated logic, such as calling multiple endpoints and reconciling the results, for example.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;named endpoints&lt;/code&gt; and &lt;code&gt;LinkGenerator.GetUriByName&lt;/code&gt; is a safer approach to generating the URL, instead of manually trying to build up the URL based on the information extracted from the &lt;em&gt;HttpContext&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A simple and easy way to name, and then generate a link using the name. If the code is required to call another endpoint in the same application, or will be used with a client generation tool - then all endpoints should be named, and &lt;em&gt;LinkGenerator&lt;/em&gt; used when generating the links.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;234: 13-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Request binding with IParseable</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/12-endpoint-iparseable</guid>
			<pubDate>Thu, 12 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In a &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post&lt;/a&gt; we had a look at the &lt;code&gt;IParseable interface&lt;/code&gt; which allows for a &lt;code&gt;string to be parsed into a type&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This functionality can be leveraged with minimal API's to &lt;em&gt;automatically parse a query string to a complex type&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="iparseable-request"&gt;IParseable request&lt;/h2&gt;
&lt;p&gt;In this example, the &lt;em&gt;Song&lt;/em&gt; entity implements the &lt;em&gt;IParsable&amp;lt;Song&amp;gt;&lt;/em&gt; interface (more details in the &lt;a href="https://alwaysdeveloping.net/2022/12/05-iparseable"&gt;previous post about IParseable&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song : IParsable&amp;lt;Song&amp;gt;
{
    public string Name { get; set; }
    public string Artist { get; set; }
    public int LengthInSeconds { get; set; }

    private Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }

    public static Song Parse(string s, IFormatProvider? provider)
    {
        string[] songPortions = s.Split(new[] { '|' });

        if (songPortions.Length != 3) 
        { 
            throw new OverflowException("Expect format: Name|Artist|LengthInSeconds"); 
        }

        return new Song(songPortions[0], songPortions[1], Int32.Parse(songPortions[2]));
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
    {
        result = null;
        if (s == null) 
        { 
            return false; 
        }

        try
        {
            result = Parse(s, provider);
            return true;
        }
        catch { return false; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This interface implementation allows for a string value (in a specific format), to be converted to a &lt;code&gt;Song instance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Song song = "Everlong|Foo Fighters|326".Parse&amp;lt;Song&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="minimal-endpoint"&gt;Minimal endpoint&lt;/h2&gt;
&lt;h3 id="manual-parsing"&gt;Manual parsing&lt;/h3&gt;
&lt;p&gt;If we want an endpoint which accepts a &lt;em&gt;Song&lt;/em&gt; as a parameter, one option is to have the request entity &lt;code&gt;as a string&lt;/code&gt; and perform the conversion to &lt;em&gt;Song&lt;/em&gt; manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/song", ([FromQuery]string song) =&amp;gt;
{
    // perform the conversion from string
    // to Song manually, using the IParsable
    // interface
    return details.Parse&amp;lt;Song&amp;gt;();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a valid approach, but because the &lt;em&gt;Song class&lt;/em&gt; implements &lt;em&gt;IParseable&lt;/em&gt;, the conversion can be done automatically!&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="automatic-parsing"&gt;Automatic parsing&lt;/h3&gt;
&lt;p&gt;A slightly easier approach that manually doing the conversions, is allowing it to happen automatically. Changing the parameter type from &lt;em&gt;string&lt;/em&gt; to &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// parameter is Song instead of string
app.MapGet("/song", ([FromQuery] Song song) =&amp;gt;
{
    return song;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the same endpoint with a &lt;em&gt;song query string&lt;/em&gt; &lt;code&gt;/song?song=Everlong|Foo Fighters|326&lt;/code&gt;, results in the same response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{"name":"Everlong","artist":"Foo Fighters","lengthInSeconds":326}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As &lt;code&gt;Song implement IParsable, the string parameter is automatically parsed to a Song instance&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small quality of life feature which makes working with the &lt;em&gt;IParsable&lt;/em&gt; interface and minimal endpoints easier and more streamline.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/5-new-mvc-features-in-dotnet-7/#1-iparseable-tryparse-for-primitive-binding"&gt;5 new MVC features in .NET 7&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;233: 12-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>SQL: IS DISTINCT FROM</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/11-is-disinct-from</guid>
			<pubDate>Wed, 11 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;SQL Server 2022 introduced a new predicate &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt;, which allows for two expressions to be compared, but takes &lt;code&gt;NULL&lt;/code&gt; values into account.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="data-setup"&gt;Data setup&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Blog&lt;/em&gt; table, with a &lt;code&gt;nullable DateCreated column&lt;/code&gt; - this column &lt;em&gt;could&lt;/em&gt; have a valid &lt;em&gt;DateTime value&lt;/em&gt;, but could also contain NULL values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pre-sql-2022"&gt;Pre SQL 2022&lt;/h3&gt;
&lt;p&gt;Prior to SQL 2022, when comparing two values, &lt;code&gt;NULL&lt;/code&gt; values were, by default, not taken into account.&lt;/p&gt;
&lt;p&gt;Assume the &lt;em&gt;Blog&lt;/em&gt; table &lt;code&gt;DOES&lt;/code&gt; contain rows which have &lt;em&gt;NULL&lt;/em&gt; DateCreated values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE DateCreated = &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;0 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Even though &lt;code&gt;&amp;#64;createdDate&lt;/code&gt; is &lt;em&gt;NULL&lt;/em&gt;, and there are rows in the table with &lt;em&gt;NULL&lt;/em&gt;, &lt;code&gt;no rows are returned&lt;/code&gt; - &lt;em&gt;NULL&lt;/em&gt; values are not taken into account.&lt;/p&gt;
&lt;p&gt;To successfully return rows which do contain &lt;em&gt;NULL&lt;/em&gt; values, both expressions need to be converted to the same default value in case of a &lt;em&gt;NULL&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT *
FROM Blog
WHERE ISNULL(DateCreated, '1900-01-01') = 
	ISNULL(&amp;#64;createdDate, '1900-01-01')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With this technique, &lt;em&gt;NULL&lt;/em&gt; values on either expression is converted to &lt;code&gt;'1900-01-01'&lt;/code&gt;, which is then successfully compared.&lt;/p&gt;
&lt;p&gt;With SQL Server 2022, performing this comparison becomes much easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="sql-2022"&gt;SQL 2022&lt;/h3&gt;
&lt;p&gt;SQL Server 2022 introduces the new &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate - this allows the comparison of values while taking &lt;em&gt;NULL&lt;/em&gt; values into account.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DECLARE &amp;#64;createdDate datetime

SELECT &amp;#64;createdDate = NULL

SELECT * 
FROM Blog
WHERE DateCreated IS NOT DISTINCT FROM &amp;#64;createdDate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10 rows returned&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IS [NOT] DISTINCT FROM&lt;/code&gt; predicate &lt;em&gt;compares the equality of two expressions and guarantees a true or false result, even if one or both operands are NULL&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively minor update, but for a developer which writes a good amount SQL this small update definitely does make things simpler and easier.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.sqlservercentral.com/blogs/cool-stuff-in-sql-server-2022-is-distinct-from"&gt;Cool Stuff in SQL Server 2022 – IS DISTINCT FROM&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;232: 11-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Caching MVC responses</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/10-mvc-cache</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/10-mvc-cache</guid>
			<pubDate>Tue, 10 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core has out of the box &lt;code&gt;configurable response caching&lt;/code&gt; functionality which can be leveraged to improve the performance of a service using &lt;code&gt;controllers&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The functionality described in this post is only for caching responses from &lt;em&gt;an MVC controller&lt;/em&gt; - to cache responses from a &lt;em&gt;minimal API&lt;/em&gt;, have a look at &lt;a href="https://alwaysdeveloping.net/2022/09/07-output-cache"&gt;this post which details output caching on minimal APIs&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="code"&gt;Code&lt;/h2&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;The default template &lt;em&gt;Weather API&lt;/em&gt; project is used for the below example, with the &lt;code&gt;Use Controllers&lt;/code&gt; options checked.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="startup"&gt;Startup&lt;/h3&gt;
&lt;p&gt;First step, &lt;code&gt;enabling the caching functionality&lt;/code&gt; in the service - this is done in the &lt;em&gt;program.cs&lt;/em&gt;, and involves adding two lines of code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
// setup caching with the DI container
builder.Services.AddResponseCaching();

var app = builder.Build();

// setup caching in the pipeline
app.UseResponseCaching();
app.UseAuthorization();
app.MapControllers();

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This follows a fairly standard pattern when it comes to adding functionality to an ASP.NET Core application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;AddResponseCaching&lt;/code&gt; method is called to register the required services with the dependency injection container&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;UseResponseCaching&lt;/code&gt; method is called to insert the caching logic into the middleware pipeline&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next step, enabling caching on a controller.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="controller"&gt;Controller&lt;/h3&gt;
&lt;p&gt;Now that we have the base caching functionality configured in the service, the next step is to actual enable caching for a specific endpoint/controller. This is done by &lt;code&gt;adding an attribute to the relevent controller method&lt;/code&gt;. In the &lt;em&gt;WeatherForecastController.cs&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[HttpGet]
[ResponseCache(Duration = 30, Location = ResponseCacheLocation.Any)]
public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
{
    Console.WriteLine($"{nameof(Get)} method in {nameof(WeatherForecastController)} called");

    return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = Random.Shared.Next(-20, 55),
        Summary = Summaries[Random.Shared.Next(Summaries.Length)]
    })
    .ToArray();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ResponseCache&lt;/code&gt; attribute is added to the &lt;em&gt;Get&lt;/em&gt; method (the method called when the endpoint is called). In this example, the cache is set to expire every 30 seconds.&lt;/p&gt;
&lt;p&gt;And thats it! We now have basic caching functionality working on the service.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="output"&gt;Output&lt;/h3&gt;
&lt;p&gt;If we run the service and browse to the &lt;code&gt;/weatherforecast&lt;/code&gt; endpoint, the weather payload will be returned, and logging at the console, the following will be output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Get method in WeatherForecastController called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Refreshing the endpoint within 30 seconds (the duration of the cache), will yield the same payload, and cause no output to the console - the &lt;code&gt;results are returned from the cache, and the controller is never called.&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="vary"&gt;Vary&lt;/h3&gt;
&lt;p&gt;Not explicitly show in the above example, but it is also possible to &lt;code&gt;vary the cache response&lt;/code&gt; by a specific key.&lt;/p&gt;
&lt;p&gt;If the attribute parameters were changed to include the &lt;code&gt;VaryByHeader&lt;/code&gt; parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[HttpGet]
[ResponseCache(Duration = 30, Location = ResponseCacheLocation.Any, VaryByHeader = "User-Agent")]
public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
{
    Console.WriteLine($"{nameof(Get)} method in {nameof(WeatherForecastController)} called");

    return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = Random.Shared.Next(-20, 55),
        Summary = Summaries[Random.Shared.Next(Summaries.Length)]
    })
    .ToArray();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then a different cache is created for each distinct &lt;code&gt;User-Agent&lt;/code&gt; header value sent on a request, each cache independent of one another. This way, the cache of one called will operate independently from the cache of a different caller. It is also possible to vary the cache by a specific &lt;code&gt;query string key&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When simple caching is required, the built-in functionality is an easy to implement, low effort option to enhance the performance of a service.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ryansouthgate.com/asp.net-core-response-caching/"&gt;ASP.NET Core Response Caching&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;231: 10-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>