<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Wed, 05 Oct 2022 04:26:35 GMT</pubDate>
		<lastBuildDate>Wed, 05 Oct 2022 04:26:35 GMT</lastBuildDate>
		<item>
			<title>Manually passing parameters to a middleware component</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/10/05-middleware-parameter</guid>
			<pubDate>Wed, 05 Oct 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;It is possible to &lt;code&gt;manually pass parameters to a middleware component&lt;/code&gt; when configuring the component and middleware pipeline on startup. &lt;em&gt;Manually passed parameters&lt;/em&gt; can be used in conjunction with parameters provided by the &lt;em&gt;dependency injection&lt;/em&gt; container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="middleware-configuration"&gt;Middleware configuration&lt;/h2&gt;
&lt;p&gt;In the below examples, to demonstrate a parameter provided by the DI container, a simple &lt;em&gt;ApplicationConfiguration&lt;/em&gt; class has been configured with the dependency injection container as &lt;em&gt;transient&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient(typeof(ApplicationConfiguration));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="distinct-parameters"&gt;Distinct parameters&lt;/h3&gt;
&lt;p&gt;If a middleware component has &lt;code&gt;parameters which are of distinct types&lt;/code&gt; then when adding the component to the middleware pipeline, the parameters can be specified in &lt;code&gt;any order&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below, the &lt;em&gt;DistinctParamMiddleware&lt;/em&gt; constructor has distinct types as parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DistinctParamMiddleware 
{
    private readonly int _version;
    private readonly string _name;
    private readonly ApplicationConfiguration _setup;
    private readonly RequestDelegate _next;

    // all distinct parameters
    public DistinctParamMiddleware(RequestDelegate next, string name, 
        int version, ApplicationConfiguration setup)
    {
        _version = version;
        _name = name;
        _setup = setup;
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        Console.WriteLine($&amp;quot;In {nameof(DistinctParamMiddleware)} with&amp;quot; +
            $&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

        await _next(context);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parameters can manually be passed in when using the &lt;code&gt;UseMiddleware&lt;/code&gt; method on startup, and because the parameter types are distinct, the manually supplied parameters can be passed in any order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;DistinctParamMiddleware&amp;gt;( 1, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, &lt;code&gt;RequestDelegate&lt;/code&gt; and &lt;code&gt;ApplicationConfiguration&lt;/code&gt; are supplied from the &lt;em&gt;dependency injection container&lt;/em&gt;, while the &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; parameters are supplied &lt;code&gt;manually&lt;/code&gt;. Even though the constructor has the &lt;em&gt;string parameter&lt;/em&gt; specified first, and then the &lt;em&gt;int parameter&lt;/em&gt;, when invoking the &lt;em&gt;UseMiddleware&lt;/em&gt; method, the values are not supplied in that order.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="non-distinct-parameters"&gt;Non-distinct parameters&lt;/h3&gt;
&lt;p&gt;When dealing with a middleware component which does &lt;code&gt;not have parameters which are of distinct types&lt;/code&gt;, then the parameter values need to be supplied in order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DuplicateTypeParamMiddleware
{
	private readonly ApplicationConfiguration _setup;
	private readonly RequestDelegate _next;
	private readonly string _name;
	private readonly string _version;

    // two string parameters
	public DuplicateTypeParamMiddleware(RequestDelegate next, string name, 
        string version, ApplicationConfiguration setup)
	{
		_setup = setup;
		_next = next;
		_name = name;
		_version = version;
	}

	public async Task Invoke(HttpContext context)
	{
		Console.WriteLine($&amp;quot;In {nameof(DuplicateTypeParamMiddleware)} with&amp;quot; +
			$&amp;quot;application name: '{_name}' and version: '{_version}'&amp;quot;);

		await _next(context);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As there are two &lt;code&gt;string parameters&lt;/code&gt;, the first string value supplied is assigned to the &lt;em&gt;name&lt;/em&gt; parameter, and the second string value supplied is assigned to the &lt;em&gt;version&lt;/em&gt; parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Correct
app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;MiddlewareParamDemo&amp;quot;, &amp;quot;2&amp;quot;);

// Incorrect
// app.UseMiddleware&amp;lt;DuplicateTypeParamMiddleware&amp;gt;(&amp;quot;2&amp;quot;, &amp;quot;MiddlewareParamDemo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This functionality is especially useful in cases when a value determined at runtime (for example, &lt;em&gt;application startup datetime&lt;/em&gt;) needs to be passed into middleware - having the ability to manually pass the value in instead of creating new entities to hold the values, and registering them with the dependency injection container, can save time and simplify code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/middleware/middleware-8/Program.cs"&gt;Inject dependency to your middleware class manually&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;175: 05-10-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Map all urls with IApplicationBuilder.Run</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/10/04-app-run</guid>
			<pubDate>Tue, 04 Oct 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method on the &lt;code&gt;WebApplication&lt;/code&gt; (which implements &lt;em&gt;IApplicationBuilder&lt;/em&gt;) can be used to map &lt;strong&gt;any and all&lt;/strong&gt; urls to the specific delegate.&lt;/p&gt;
&lt;p&gt;This can be leveraged in the case where the api doesn't expose any functional endpoints (such as with a &lt;em&gt;Background Service&lt;/em&gt;) to always display a consistent message to the caller.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="root-endpoint"&gt;Root endpoint&lt;/h2&gt;
&lt;p&gt;Usually when a web application doesn't expose any endpoints, the root endpoint might be mapped so when browsing to the url, a message is returned to at least inform the caller that the service is up and running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;/&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to &lt;code&gt;/&lt;/code&gt; will display:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The downside of this approach, is that if the user browses to any URL other than &lt;code&gt;/&lt;/code&gt;, nothing will be returned. For example, browsing to &lt;code&gt;/api&lt;/code&gt; just returns a blank page.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="run-method"&gt;Run method&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Run&lt;/code&gt; method can be leveraged to map a &lt;em&gt;delegate&lt;/em&gt; to &lt;strong&gt;all&lt;/strong&gt; endpoints:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.Run(async context =&amp;gt;
{
   await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, browsing to &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/api&lt;/code&gt; or &lt;strong&gt;any&lt;/strong&gt; other url, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Sample application - no endpoints exposed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, no matter the endpoint called - the &lt;code&gt;same message&lt;/code&gt; is returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="endpoint-override"&gt;Endpoint override&lt;/h2&gt;
&lt;p&gt;A word of warning - using the &lt;code&gt;Run&lt;/code&gt; method will cause the specific delegate to be called on all endpoints - even if another endpoint has specifically been defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&amp;lt;RunMiddleware&amp;gt;();

WebApplication? app = builder.Build();

app.MapGet(&amp;quot;hello&amp;quot;, async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;World&amp;quot;);
});

app.Run(async context =&amp;gt;
{
    await context.Response.WriteAsync(&amp;quot;Sample application - no endpoints exposed&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, browsing to &lt;code&gt;/hello&lt;/code&gt; will return &lt;code&gt;Sample application - no endpoints exposed&lt;/code&gt; and &lt;strong&gt;NOT&lt;/strong&gt; &lt;code&gt;World&lt;/code&gt; - the &lt;em&gt;Run&lt;/em&gt; method delegate overrides all over endpoint delegates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not a technique to be used for every application, but in the cases where the application is running as a background service (for example) which doesn't expose any specific endpoints, this technique can be leveraged to always display &lt;em&gt;something&lt;/em&gt; to the user.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/application-environment/Program.cs"&gt;Application Environment&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;174: 04-10-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Obtaining a list of app URLs</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/10/03-server-addresses</guid>
			<pubDate>Mon, 03 Oct 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IServerAddressesFeature&lt;/code&gt; or &lt;code&gt;IServer&lt;/code&gt; implementations can be used to get a list of URLs your application is responding to. In a landscape with a large number of applications which serve on multiple URLs, this could be leveraged to easily self-document all URLs currently in use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-urls"&gt;Multiple urls&lt;/h2&gt;
&lt;p&gt;For the samples below, the application has been configured to use multiple urls using the &lt;code&gt;UseUrls&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.WebHost.UseUrls(&amp;quot;http://*:5096;http://*:5097;http://localhost:5098&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we had a &lt;em&gt;&amp;quot;hello&amp;quot;&lt;/em&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/hello&amp;quot;, () =&amp;gt;
{
    return &amp;quot;world&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would get a &lt;em&gt;&amp;quot;world&amp;quot;&lt;/em&gt; response by browsing to any of the below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://localhost:5096/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5097/hello&lt;/li&gt;
&lt;li&gt;http://localhost:5098/hello&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="address-list"&gt;Address list&lt;/h2&gt;
&lt;h3 id="iserveraddressesfeature"&gt;IServerAddressesFeature&lt;/h3&gt;
&lt;p&gt;The first method to get a list of addresses is by casting the &lt;code&gt;WebApplication&lt;/code&gt; instance to &lt;code&gt;IApplicationBuilder&lt;/code&gt; and leveraging the &lt;em&gt;ServerFeatures&lt;/em&gt; method available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// app is obtained from var app = builder.Build();
// in this example, serverAddress is a free variable
var serverAddress = (app as IApplicationBuilder)
    .ServerFeatures.Get&amp;lt;IServerAddressesFeature&amp;gt;();

app.MapGet(&amp;quot;/addresses&amp;quot;, (context) =&amp;gt;
{
    // get all addresses and output
    foreach(var address in serverAddress.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="iserver"&gt;IServer&lt;/h3&gt;
&lt;p&gt;When &lt;code&gt;IApplicationBuilder&lt;/code&gt; is not available (outside of application startup), the information is also available by injecting &lt;code&gt;IServer&lt;/code&gt; into the required constructor or delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/iserver&amp;quot;, (HttpContext context, IServer server) =&amp;gt;
{
    // get the address from IServer instead of IApplicationBuilder
    // otherwise everything else is the same
    var addressFeature = server.Features.Get&amp;lt;IServerAddressesFeature&amp;gt;();

    foreach (var address in addressFeature.Addresses)
    {
        context.Response.WriteAsync($&amp;quot;- {address}{Environment.NewLine}&amp;quot;);
    }

    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from browsing to the above endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;- http://[::]:5096
- http://[::]:5097
- http://localhost:5098
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;We've looked at two different ways to get a list of addresses the application is serving on. For most applications, this might never be useful as most applications serve on a single address. However in the case where there &lt;em&gt;are&lt;/em&gt; multiple addresses, this could be used to self document and easily keep track of application's addresses.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/blob/net6.0/projects/features/features-server-addresses"&gt;Server Addresses Feature&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/features/features-server-addresses-2"&gt;Server Addresses Feature - 2&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;173: 03-10-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Minimal api's and cancellation tokens</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/30-min-api-cancellation</guid>
			<pubDate>Fri, 30 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; can be passed into a minimal api endpoint to be used to &lt;em&gt;cancel processing executed by the endpoint&lt;/em&gt; - the cancellation token will automatically be marked as cancelled if the caller either cancels the request or navigates away from the endpoint (if being accessed from the browser)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="process-cancellation"&gt;Process cancellation&lt;/h2&gt;
&lt;h3 id="no-token"&gt;No token&lt;/h3&gt;
&lt;p&gt;Consider the following minimal api endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/long&amp;quot;, async () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    // simulate a long running process
    await Task.Delay(5000);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the application is executed, and the endpoint called, the output would be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;02: Starting long process
07: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, it takes approximately 5 seconds for the endpoint to execute and finish.&lt;/p&gt;
&lt;p&gt;If the endpoint is called again, and during those 5 seconds of &amp;quot;processing&amp;quot;, the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button is clicked on the browser (wording may differ slightly depending on browser) we see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;52: Starting long process
57: Finishing long process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the &lt;code&gt;request from the browser to the endpoint is cancelled, the processing done by the endpoint is not cancelled!&lt;/code&gt;. The endpoint isn't aware of the fact the request was cancelled, which results in unnecessary CPU and memory usage, no longer required as the user has decided to cancel the request.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellationtoken"&gt;CancellationToken&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CancellationToken&lt;/code&gt; to the rescue - a &lt;em&gt;cancellation token&lt;/em&gt; can be used to convey information to the endpoint about the status of the request.&lt;/p&gt;
&lt;p&gt;Let's update the endpoint to use a cancellation token:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// add cancellation token, which is automatically populated
app.MapGet(&amp;quot;/long&amp;quot;, async (CancellationToken token) =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Starting long process&amp;quot;);

    //forward the token onto the method
    await Task.Delay(5000, token);

    Console.WriteLine($&amp;quot;{DateTime.Now.ToString(&amp;quot;ss&amp;quot;)}: &amp;quot; +
        $&amp;quot;Finishing long process&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a &lt;code&gt;CancellationToken&lt;/code&gt; is specified to be passed into the endpoint - this automatically gets instantiated and is &lt;em&gt;&amp;quot;linked&amp;quot;&lt;/em&gt; to the HTTP context of the request. If the request is cancelled by the caller, the &lt;code&gt;CancellationToken&lt;/code&gt; will indicate this fact.&lt;/p&gt;
&lt;p&gt;Most &lt;em&gt;async&lt;/em&gt; methods (such as &lt;code&gt;Task.Delay&lt;/code&gt; in this instance) have an optional &lt;code&gt;CancellationToken&lt;/code&gt; parameter which can be used to pass a token all the way down the call stack to the code doing the actual work/processing, which will then in turn monitor and check if the token has been cancelled.&lt;/p&gt;
&lt;p&gt;Invoking this endpoint now, and clicking the &lt;em&gt;&amp;quot;Stop loading this page&amp;quot;&lt;/em&gt; button on the browser while the endpoint is still processing will result in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;27: Starting long process
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]
      An unhandled exception has occurred while executing the request.
      System.Threading.Tasks.TaskCanceledException: A task was canceled.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a &lt;code&gt;CancellationToken&lt;/code&gt; is used to cancel a process, it is up to the library author to decide if cancelling means an exception be thrown (such as in the above example with &lt;em&gt;Task.Delay&lt;/em&gt;), or if processing simply just stops.&lt;/p&gt;
&lt;p&gt;While the endpoint &lt;code&gt;process is now successfully&lt;/code&gt; cancelled when the request is cancelled, not using unnecessary resources - we now have to deal with and cater for the &lt;code&gt;TaskCanceledException&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="cancellation-middleware"&gt;Cancellation middleware&lt;/h3&gt;
&lt;p&gt;A &lt;em&gt;custom middleware&lt;/em&gt; component can be written to catch any exceptions of type &lt;code&gt;TaskCanceledException&lt;/code&gt;, log it and return a different response to the caller (which they will not care about, as they have cancelled the request):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CancellationMiddleware
{
    private readonly RequestDelegate _next;

    public CancellationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        // catch any canceled exceptions
        // TaskCanceledException inherits from OperationCanceledException
        catch (OperationCanceledException)
        {
            Console.WriteLine($&amp;quot;Cancelled request handled by {nameof(CancellationMiddleware)}&amp;quot;);
            // the called has cancelled the request
            // so doesn't care about the response
            // Totally legit HTTP response code
            context.Response.StatusCode = StatusCodes.Status418ImATeapot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware is then registered on startup:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;CancellationMiddleware&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now when invoking the endpoint and cancelling we see the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;18: Starting long process
Cancelled request handled by CancellationMiddleware
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Process successfully cancelled&lt;/code&gt; and &lt;code&gt;no more unhandled exception errors&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Adding &lt;code&gt;CancellationToken&lt;/code&gt; support to a minimal endpoint is a fairly low effort improvement, with a (depending on how the endpoint gets used) potential high reward - processing which is no longer required by the caller gets cancelled, freeing up CPU and memory usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/using-cancellationtokens-in-asp-net-core-minimal-apis/"&gt;Using CancellationTokens in ASP.NET Core minimal APIs &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;172: 30-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Native AOT compilation with .NET 7</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/29-aot-improvements</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/29-aot-improvements</guid>
			<pubDate>Thu, 29 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;New functionality is being introduced with .NET 7 adds the ability to do &lt;code&gt;native ahead-of-time (AOT)&lt;/code&gt; compilation - this results in the application starting up faster, and using less memory than the traditional non-AOT alternative.&lt;/p&gt;
&lt;p&gt;While native AOT is supported in .NET 7, only a limited number of libraries are fully compatible and the functionality is currently targeted towards console-type applications, not web applications.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="aot"&gt;AOT&lt;/h2&gt;
&lt;p&gt;Publishing an application with native AOT compilation produces an app that is self-contained and that has been ahead-of-time (AOT) compiled to the native code of the architecture specified.&lt;br /&gt;
When an application is not using AOT, then &lt;em&gt;just-in-time&lt;/em&gt; compilation is used, where the code is compiled into native machine code on the fly as it is being used.&lt;/p&gt;
&lt;p&gt;From the official documentation:&lt;br /&gt;
&lt;em&gt;The benefit of native AOT is most significant for workloads with a high number of deployed instances, such as cloud infrastructure and hyper-scale services. It is currently not supported with ASP.NET Core, but only console apps.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;AOT in the broader sense is entirely not new to .NET, which currently makes use of &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/ready-to-run"&gt;ReadyToRun Compilation&lt;/a&gt; which is a form of AOT.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="publish"&gt;Publish&lt;/h2&gt;
&lt;p&gt;Let's test the AOT functionality on a simple .NET 7 console application which writes a message to the console, and then waits for a key to be pressed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the entire application
Console.WriteLine(&amp;quot;Learning about Native AOT with alwaysdeveloping.net&amp;quot;);
Console.ReadKey();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="non-aot"&gt;Non AOT&lt;/h3&gt;
&lt;p&gt;To start, we'll get a base benchmark, without using AOT:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is a &lt;code&gt;149 KB&lt;/code&gt; &lt;em&gt;AlwaysDeveloping.exe&lt;/em&gt; which took &lt;code&gt;3 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="runtime-specified"&gt;Runtime specified&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Native AOT&lt;/em&gt; requires a specific runtime architecture be specified, so let's add that into the publish command to get a better comparison. When specifying the &lt;em&gt;runtime&lt;/em&gt; architecture, &lt;em&gt;self-contained&lt;/em&gt; or &lt;em&gt;no-self-contained&lt;/em&gt; argument needs to also be specified. AOT compiled code will be self contained, so we can specify the publish as &lt;em&gt;self-contained&lt;/em&gt; as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 --self-contained
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is a &lt;code&gt;67 MB folder&lt;/code&gt;, containing &lt;em&gt;AlwaysDeveloping.exe, as well as all other dependencies&lt;/em&gt; required to run the application, and took &lt;code&gt;1.5 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="single-file"&gt;Single file&lt;/h4&gt;
&lt;p&gt;When using &lt;em&gt;Native AOT&lt;/em&gt;, the output will be a single file, so next we include that:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;62 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;3.3 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="trimming"&gt;Trimming&lt;/h4&gt;
&lt;p&gt;Next up, &lt;em&gt;Native AOT&lt;/em&gt;, will perform &lt;em&gt;trimming&lt;/em&gt; (removal of specific portions of code never called):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;11 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;5 seconds to compile.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="readytorun"&gt;ReadyToRun&lt;/h4&gt;
&lt;p&gt;The final step before comparing to &lt;em&gt;Native AOT&lt;/em&gt; is to specify the existing form of AOT, &lt;code&gt;ReadyToRun&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishSingleFile=true -p:PublishTrimmed=true -p:PublishReadyToRun=true --self-contained true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;14 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;10 seconds to compile&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="aot-1"&gt;AOT&lt;/h3&gt;
&lt;p&gt;FInally let's compile using &lt;em&gt;Native AOT&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet publish -c Release -r win-x64 -p:PublishAot=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is now a &lt;code&gt;3.6 MB&lt;/code&gt; AlwaysDeveloping.exe file, which took &lt;code&gt;3-12 seconds to compile&lt;/code&gt; (I ran this a few times, and the compile time was variable between 3 and 12 seconds)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limitations"&gt;Limitations&lt;/h2&gt;
&lt;p&gt;There are &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot#limitations-of-native-aot-deployment"&gt;limitations&lt;/a&gt; when working with &lt;em&gt;native AOT&lt;/em&gt; which need to be kept in mind, and may limit the ability to leverage the &lt;em&gt;native AOT&lt;/em&gt; functionality:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No dynamic loading&lt;/li&gt;
&lt;li&gt;No runtime code generation&lt;/li&gt;
&lt;li&gt;Trimming is required (quick has its own limitations)&lt;/li&gt;
&lt;li&gt;Single file is required (which has known incompatibilities)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;Native AOT&lt;/code&gt; compilation results in a &lt;strong&gt;much&lt;/strong&gt; smaller output compared with the equivalent (as much as possible) configuration using non-AOT (3.6MB vs 14MB). With the improved startup performance and memory usage, if the limitations allow it, &lt;em&gt;Native AOT&lt;/em&gt; should definitely be considered. This is just the start, and I am sure there will be more improvements to come with future releases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot"&gt;Native AOT Deployment&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://code.soundaranbu.com/trying-out-native-aot-in-net-7-preview-7/"&gt;Trying out Native AOT in .NET 7 Preview 7&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;171: 29-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Strongly typed middleware with IMiddleware</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/28-typed-middleware</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/28-typed-middleware</guid>
			<pubDate>Wed, 28 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;To create &lt;code&gt;custom ASP.NET Core middleware&lt;/code&gt;, all that is required is a class with an &lt;code&gt;Invoke or InvokeAsync method&lt;/code&gt;. However, if configured incorrectly, the error will not be apparent until &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IMiddleware&lt;/code&gt; interface can be used to ensure custom middleware contains the correct method, through the implementation of the interface, ensuring any configuration errors are apparent at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="weakly-typed"&gt;Weakly typed&lt;/h2&gt;
&lt;p&gt;To define a &lt;em&gt;working&lt;/em&gt; middleware component, a class with an &lt;code&gt;Invoke&lt;/code&gt; or &lt;code&gt;InvokeAsync&lt;/code&gt; method needs to be defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class WeakTypeMiddleware
{
    private readonly RequestDelegate _next;

    public WeakTypeMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(WeakTypeMiddleware)}&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the components must be added to the middleware pipeline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseMiddleware&amp;lt;WeakTypeMiddleware&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, &lt;code&gt;nothing is preventing the middleware component from accidentally being configured incorrectly&lt;/code&gt; - in the below example the class doesn't contain a method with the correct name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class WeakTypeMiddleware
{
    private readonly RequestDelegate _next;

    public WeakTypeMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    // incorrect method name used
    public async Task InvokePipeline(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(WeakTypeMiddleware)}&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above class is a &lt;em&gt;valid class&lt;/em&gt;, but not a valid &lt;em&gt;middleware component&lt;/em&gt;. The above code will compile, but an exception will occur when trying to call an endpoint which makes use of the component:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;System.InvalidOperationException: 'No public 'Invoke' or 'InvokeAsync' 
    method found for middleware of type 'WeakTypeMiddleware'.'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception tells us exactly what the problem is, and how to resolve it - it is easily fixed. However a better and cleaner approach is to &lt;em&gt;never encounter the exception in the first place&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="strongly-typed"&gt;Strongly typed&lt;/h2&gt;
&lt;p&gt;A middleware component can be strongly typed by using the &lt;code&gt;IMiddleware&lt;/code&gt; interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class StrongTypeMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(StrongTypeMiddleware)}&amp;quot;);

        await next.Invoke(context);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interface enforces the &lt;code&gt;InvokeAsync&lt;/code&gt; method on the implementation, ensuring it will be configured correctly.&lt;/p&gt;
&lt;p&gt;A slight difference between the two,is that with the &lt;em&gt;weakly typed&lt;/em&gt; implementation, the &lt;code&gt;next delegate is passed into the constructor&lt;/code&gt;, however with the &lt;em&gt;strongly typed&lt;/em&gt; implementation, the &lt;code&gt;next delegate is passed into the InvokeAsync method&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Implementing &lt;em&gt;strongly typed&lt;/em&gt; middleware using &lt;code&gt;IMiddleware&lt;/code&gt; instead of having the components &lt;em&gt;weakly typed&lt;/em&gt; is a minor code change, and may not offer any immediately obvious benefits - however, using the interface will ensure code uniformity across all middleware components, as well as make it easier to find and identify middleware components in a large code base.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mikesdotnetting.com/article/359/strongly-typed-middleware-in-asp-net-core"&gt;Strongly Typed Middleware in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;170: 28-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>dynamic, ExpandoObject and INotifyPropertyChanged</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/27-expando-property-change</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/27-expando-property-change</guid>
			<pubDate>Tue, 27 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExpandoObject&lt;/code&gt; implements &lt;em&gt;INotifyPropertyChanged&lt;/em&gt; - a callback delegate can be added to be invoked when a property value on the &lt;code&gt;ExpandoObject&lt;/code&gt; instances changes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="expandoobject"&gt;ExpandoObject&lt;/h2&gt;
&lt;p&gt;A quick overview of &lt;code&gt;ExpandoObject&lt;/code&gt; - it represents an object whose members can be dynamically added and removed at run time.&lt;/p&gt;
&lt;p&gt;In the examples below, it is being used to represent a &lt;em&gt;product&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic product = new ExpandoObject();
product.Name = &amp;quot;Green Shirt&amp;quot;;
product.Rating = 4.3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The properties &lt;em&gt;Name&lt;/em&gt; and &lt;em&gt;Rating&lt;/em&gt; are added at runtime. The properties can then be accessed as if they were traditional class properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(product.Name);
Console.WriteLine(product.Rating);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="calculation"&gt;Calculation&lt;/h2&gt;
&lt;p&gt;In the examples below, we have a collection of &lt;em&gt;Products&lt;/em&gt;, each with a customer rating:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public dynamic[] GetProducts()
{
    dynamic prod1 = new ExpandoObject();
    prod1.Name = &amp;quot;Green Shirt&amp;quot;;
    prod1.Rating = 4.3;

    dynamic prod2 = new ExpandoObject();
    prod2.Name = &amp;quot;Blue Shirt&amp;quot;;
    prod2.Rating = 4.9;

    dynamic prod3 = new ExpandoObject();
    prod3.Name = &amp;quot;Shoes&amp;quot;;
    prod3.Rating = 3.8;

    dynamic prod4 = new ExpandoObject();
    prod4.Name = &amp;quot;Jeans&amp;quot;;
    prod4.Rating = 5.0;

    dynamic prod5 = new ExpandoObject();
    prod5.Name = &amp;quot;Peak cap&amp;quot;;
    prod5.Rating = 1.7;

    return new dynamic[] { prod1, prod2, prod3, prod4, prod5 };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to find the &lt;code&gt;average rating for all products&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ComputeAverageRating()
{
    avgRating = products.Average(p =&amp;gt; (double)p.Rating);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-invocation"&gt;Manual invocation&lt;/h3&gt;
&lt;p&gt;Getting the average for all products is straight forward - call the &lt;code&gt;ComputeAverageRating&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();

var avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, every time a rating on one of the &lt;em&gt;Products&lt;/em&gt; changes, the method needs to manually be called again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();

var avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);

// the product rating changed from 5 to 4.5
products[3].Rating = 4.5;

avgRating = products.Average(p =&amp;gt; (double)p.Rating);
Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Average product rating is: 3,94
Average product rating is: 3,84
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this method works without issue, as mentioned, it requires manually recalculating the average every time one of the &lt;em&gt;Rating&lt;/em&gt; property values changes.&lt;/p&gt;
&lt;p&gt;A different method, requiring less manual work - is to leverage the &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; functionality of &lt;code&gt;ExpandoObject&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="inotifypropertychanged"&gt;INotifyPropertyChanged&lt;/h3&gt;
&lt;p&gt;With this method, once we have the list of &lt;em&gt;Products&lt;/em&gt; we can &lt;code&gt;register a method to be called whenever a property on the Product changes&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void RegisterPropertyChange(dynamic[] products)
{
    foreach(var product in products)
    {
        // cast each product to INotifyPropertyChanged
        // and register a callback method to be called
        // every time a property changes.
        // The cast is valid as ExpandoObject implements
        // INotifyPropertyChanged
        ((INotifyPropertyChanged)product).PropertyChanged += 
            new PropertyChangedEventHandler(
                (sender, e) =&amp;gt;
                {
                    // when a property changes, call this method
                    ComputeAverageRating();
                }
            );
    }

    // calculate the average for the first time once 
    // the callbacks have all been registered
    ComputeAverageRating();
}

public void ComputeAverageRating()
{
    // avgRating is defined on the parent class
    avgRating = products.Average(p =&amp;gt; (double)p.Rating);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can now be utilized as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var products = GetProducts();
RegisterPropertyChange(products);

Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);

products[3].Rating = 4.5;

Console.WriteLine($&amp;quot;Average product rating is: {avgRating}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the average rating calculation doesn't have to be called manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Average product rating is: 3,94
Average product rating is: 3,84
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the &lt;code&gt;ExpandoObject&lt;/code&gt; is a very useful class, it does have it's drawbacks, performance being a big one. However, when it is required it can prove to be invaluable - with the bonus advantage of being able to leverage the &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; functionality if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/create-class-dynamically-csharp/"&gt;How to Create a Class Dynamically in C#?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;169: 27-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Delaying injected dependency instantiation</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/26-lazy-injection</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/26-lazy-injection</guid>
			<pubDate>Mon, 26 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Lazy&lt;/code&gt; class can be leveraged to delay instantiation of implementations &lt;code&gt;injected via dependency injection&lt;/code&gt;. This is especially useful if the &lt;em&gt;instantiation is high cost&lt;/em&gt; (it has a nigh number of dependencies) and the &lt;em&gt;functionality of the dependency is not used in every code path&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We have previously looked at the &lt;a href="https://alwaysdeveloping.net/03/09-lazy-class"&gt;Lazy class&lt;/a&gt;, but not how its functionality can be used in conjunction with &lt;em&gt;dependency injection&lt;/em&gt;, covered by this post.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="methods"&gt;Methods&lt;/h2&gt;
&lt;h3 id="normal-injection"&gt;Normal injection&lt;/h3&gt;
&lt;p&gt;In the examples below, we have a &lt;code&gt;IDatabaseAccess&lt;/code&gt; interface, and a &lt;code&gt;SqlDatabaseAccess&lt;/code&gt; implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// basic interface
public interface IDatabaseAccess 
{
    void PerformDatabaseUpdate();
}

// the SQL implementation of the interface
public class SqlDatabaseAccess : IDatabaseAccess 
{
    public SqlDatabaseAccess()
    {
        Console.WriteLine($"In constructor of '{nameof(SqlDatabaseAccess)}'");
    }

    public void PerformDatabaseUpdate()
    {
        Console.WriteLine($"Database update performed");
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also have an endpoint, where only on &lt;em&gt;some paths&lt;/em&gt; is the database accessed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/maybe-do-work", (IDatabaseAccess databaseAccess) =&amp;gt;
{
    // perform a random check
    var rando = new Random();
    if(rando.Next(10) &amp;gt; 5)
    {
         databaseAccess.PerformDatabaseUpdate();
    }

    return "'maybe-do-work' endpoint successfully called";
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the dependency injection container setup as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IDatabaseAccess, SqlDatabaseAccess&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem here is that the &lt;code&gt;IDatabaseAccess implementation is always initialized even if not used&lt;/code&gt;. This might be fine if the implementation construction is low cost, but if the &lt;em&gt;IDatabaseAccess&lt;/em&gt; implementation is high cost, and and itself has many dependencies, this could have an impact on performance.&lt;/p&gt;
&lt;p&gt;Let's look at how the &lt;code&gt;Lazy&lt;/code&gt; class can be used to achieve a delayed instantiation.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="lazy-injection"&gt;Lazy injection&lt;/h3&gt;
&lt;p&gt;To leverage the &lt;code&gt;Lazy&lt;/code&gt; class, the first step involves setting up the dependency injection container with &lt;code&gt;Lazy&amp;lt;IDatabaseAccess&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IDatabaseAccess, SqlDatabaseAccess&amp;gt;();
builder.Services.AddTransient&amp;lt;Lazy&amp;lt;IDatabaseAccess&amp;gt;&amp;gt;(
    provider =&amp;gt;
    {
        Console.WriteLine("In 'Lazy&amp;lt;IDatabaseAccess&amp;gt;' implementation factory");

        // be sure to use the "valueFactory" constructor and 
        // NOT the "value" constructor
        return new Lazy&amp;lt;IDatabaseAccess&amp;gt;(
            () =&amp;gt; provider.GetRequiredService&amp;lt;IDatabaseAccess&amp;gt;());
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then injecting &lt;code&gt;Lazy&amp;lt;IDatabaseAccess&amp;gt;&lt;/code&gt; into the delegate, instead of &lt;code&gt;IDatabaseAccess&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/maybe-do-work-lazy", (Lazy&amp;lt;IDatabaseAccess&amp;gt; databaseAccess) =&amp;gt;
{
    var rando = new Random();

    if (rando.Next(10) &amp;gt; 5)
    {
        databaseAccess.Value.PerformDatabaseUpdate();
    }

    return "'maybe-do-work-lazy' endpoint successfully called";
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the code and calling the endpoint, results in the following (example output):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In Lazy&amp;lt;IDatabaseAccess&amp;gt; implementation factory
In Lazy&amp;lt;IDatabaseAccess&amp;gt; implementation factory
In Lazy&amp;lt;IDatabaseAccess&amp;gt; implementation factory
In constructor of 'SqlDatabaseAccess'
Database update performed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, &lt;code&gt;SqlDatabaseAccess is only initialized when it is being used&lt;/code&gt; - exactly what we are after.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="serviceprovider-injection"&gt;ServiceProvider injection&lt;/h3&gt;
&lt;p&gt;Another option is to &lt;code&gt;inject IServiceProvider directly&lt;/code&gt; and get the service only when required - however this is considered by some to be an &lt;em&gt;anti-pattern&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The above example is updated to look as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/maybe-do-work-provider", (IServiceProvider provider) =&amp;gt;
{
    Console.WriteLine("In `maybe-do-work-provider` endpoint");
    var rando = new Random();

    if (rando.Next(10) &amp;gt; 5)
    {
        var databaseAccess = provider.GetRequiredService&amp;lt;IDatabaseAccess&amp;gt;();
        databaseAccess.PerformDatabaseUpdate();
    }

    return "'maybe-do-work-provider' endpoint successfully called";
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And calling the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In `maybe-do-work-provider` endpoint
In `maybe-do-work-provider` endpoint
In constructor of 'SqlDatabaseAccess'
Database update performed
In `maybe-do-work-provider` endpoint
In `maybe-do-work-provider` endpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, &lt;code&gt;SqlDatabaseAccess is only initialized when it is being used&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful technique to use when the instantiation of an object has a large overhead, but it not used in all code paths. The constructor in general should be kept as quick and performant as possible, but sometimes its unavoidable to have to use a &lt;em&gt;high cost&lt;/em&gt; constructor (if using a 3rd party package, for example).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://thecodeblogger.com/2021/04/28/delayed-instantiation-using-dependency-injection-in-net/"&gt;Delayed Instantiation Using Dependency Injection In .NET&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;168: 26-09-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Bulk update (and delete) in EF7</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/23-ef-bulk-update</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/23-ef-bulk-update</guid>
			<pubDate>Fri, 23 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;New functionality is being introduced with Entity Framework 7 which enables the ability to perform &lt;code&gt;bulk updates and deletes&lt;/code&gt; on the database, without having to first load the relevent records into memory. This results in &lt;code&gt;better memory usage&lt;/code&gt;, as well as &lt;code&gt;increased performance&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="availability"&gt;Availability&lt;/h2&gt;
&lt;p&gt;As of the time of this post, this functionality is only available via the EF nightly builds for &lt;code&gt;Microsoft.EntityFrameworkCore&lt;/code&gt; and &lt;code&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/code&gt; available at the &lt;a href="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json"&gt;following NuGet feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This URL can be added as a package source in the &lt;em&gt;NuGet Package Manager -&amp;gt; Package Sources&lt;/em&gt; in Visual Studio to enable access to the nightly build NuGet packages.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the sample below, we have a table of 10 000 &lt;em&gt;Blog&lt;/em&gt; records - we want to update the &lt;em&gt;Description&lt;/em&gt; column value for all records which have an &lt;code&gt;Id value of 20 or less&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In both EF6 and EF7 examples, the &lt;em&gt;OnConfiguring&lt;/em&gt; method of the DbContext has been updated to enable &lt;em&gt;sensitive logging&lt;/em&gt; and &lt;em&gt;console logging&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;optionsBuilder.EnableSensitiveDataLogging(true);
    optionsBuilder.LogTo((string query) =&amp;gt;
    {
        Console.WriteLine(query);
    }, LogLevel.Information);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="prior-to-ef7"&gt;Prior to EF7&lt;/h3&gt;
&lt;p&gt;In existing versions of Entity Framework, the relevent records have to be selected into memory (so the change tracker is tracking them), updated, and then the changes saved back to the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get all blogs into memory/change tracker
var updateBlogs = context.Blogs.Where(b =&amp;gt; b.Id &amp;lt;= 20).ToList();

// update the value
updateBlogs.ForEach(ub =&amp;gt; ub.Description = &amp;quot;EF6 Bulk Update&amp;quot;);

// save...multiple updates
context.Blogs.UpdateRange(updateBlogs);
var result = await context.SaveChangesAsync();

Console.WriteLine($&amp;quot;Numbers of records updated: {result}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the update code, results in the following output (abbreviated in places):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt; Executed DbCommand (90ms) [Parameters=[&amp;#64;p3='1', &amp;#64;p0='2022-07-12T06:47:24.1400000', 
 &amp;#64;p1='EF6 Bulk Update' (Size = 4000), &amp;#64;p2='DD50AA26-FB55-4985-B5D5-C9D2DE98AFB3' (Size = 4000), 
 &amp;#64;p7='2', &amp;#64;p4='2022-07-12T06:47:24.1400000', &amp;#64;p5='EF6 Bulk Update' (Size = 4000), 
 &amp;#64;p6='4BF98BB3-A4BD-4652-AC29-F6A6EE1BE524' (Size = 4000), &amp;#64;p11='3', &amp;#64;p8='2022-07-12T06:47:24.1400000', 
 &amp;#64;p9='EF6 Bulk Update' (Size = 4000), &amp;#64;p10='3C41C714-1670-4978-85DF-956F14FB8863' (Size = 4000), 
 &amp;#64;p15='4', &amp;#64;p12='2022-07-12T06:47:24.1430000', &amp;#64;p13='EF6 Bulk Update' (Size = 4000), 
 &amp;#64;p14='91929DC9-BE25-4027-9554-1B6EEF108E12' (Size = 4000), &amp;#64;p19='5', &amp;#64;p16='2022-07-12T06:47:24.1430000', 
 &amp;#64;p17='EF6 Bulk Update' (Size = 4000), &amp;#64;p18='28DAF144-2ADB-42F4-9838-64F2DC192480' (Size = 4000), &amp;#64;p23='6' 
 .... 
 ....
SET NOCOUNT ON;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p0, [Description] = &amp;#64;p1, [Title] = &amp;#64;p2
OUTPUT 1
WHERE [Id] = &amp;#64;p3;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p4, [Description] = &amp;#64;p5, [Title] = &amp;#64;p6
OUTPUT 1
WHERE [Id] = &amp;#64;p7;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p8, [Description] = &amp;#64;p9, [Title] = &amp;#64;p10
OUTPUT 1
...
...
Numbers of records updated: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output, we can see that multiple &lt;em&gt;UPDATE&lt;/em&gt; statements are executed, &lt;code&gt;one UPDATE for each record&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ef7"&gt;EF7&lt;/h3&gt;
&lt;p&gt;With EF 7, an &lt;code&gt;ExecuteUpdateAsync extension method&lt;/code&gt; is now available on &lt;code&gt;IQueryable&lt;/code&gt;, enabling bulk updates.&lt;/p&gt;
&lt;p&gt;The syntax is a little more complex than using the EF6 technique:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var updatedCount = await context
    .Blogs
    // filter records to be updated
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    // execute the bulk update
    .ExecuteUpdateAsync(record =&amp;gt; record
        // specify which column to update
        // as well as the value
        .SetProperty(blog =&amp;gt; blog.Description, desc =&amp;gt; &amp;quot;EF7 Bulk Update&amp;quot;)
    );

Console.WriteLine($&amp;quot;Numbers of records updated: {updatedCount}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the output when executed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;UPDATE [b]
    SET [b].[Description] = N'EF7 Bulk Update'
FROM [Blog] AS [b]
WHERE [b].[Id] &amp;lt;= 20

Numbers of records updated: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The generated SQL is &lt;code&gt;much simpler and more concise&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is possible to also &lt;em&gt;update multiple columns&lt;/em&gt; at the same time by &lt;code&gt;chaining SetProperty methods together&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var updatedCount = await context
    .Blogs
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    .ExecuteUpdateAsync(record =&amp;gt; record
        // update the description and date modified
        .SetProperty(blog =&amp;gt; blog.Description, desc =&amp;gt; &amp;quot;EF7 Bulk Update&amp;quot;)
        .SetProperty(blog =&amp;gt; blog.DateModified, date =&amp;gt; DateTime.Now)
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Benchmarking the two samples above using BenchmarkDotnet::&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EF6Update&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,222.8 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;126.60 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;367.29 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;302 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EF7Update&lt;/td&gt;
&lt;td style="text-align: right;"&gt;428.9 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.23 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.81 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.19&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12.6953&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.9766&lt;/td&gt;
&lt;td style="text-align: right;"&gt;79 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, we can see that the EF7 methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is &lt;code&gt;5 times faster than EF6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;uses almost &lt;code&gt;4 times less memory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="bulk-delete"&gt;Bulk Delete&lt;/h2&gt;
&lt;p&gt;For completeness, a &lt;code&gt;bulk delete method&lt;/code&gt; is also available as part of EF7. It can be leveraged as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var deletedCount = await context
    .Blogs
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    .ExecuteDeleteAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will result in SQL similar to that of the bulk update - a &lt;em&gt;single bulk delete statement&lt;/em&gt; instead of multiple, one per record.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very welcome addition to the Entity Framework libraries, greatly speeding up specific uses cases. A specific use case I'm personally interested in, is &lt;em&gt;extracting data for publishing, and then flagging the data as &amp;quot;published&amp;quot;&lt;/em&gt;. Currently this involves having to load the data into memory, so the change tracker is tracking it, updating the records, and then having EF update each record as &amp;quot;published&amp;quot; individually.&lt;/p&gt;
&lt;p&gt;With EF7, the data can be retrieved without tracking, thus saving on memory usage, and then updated as &amp;quot;published&amp;quot; in bulk.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://timdeschryver.dev/blog/new-in-entity-framework-7-bulk-operations-with-executedelete-and-executeupdate#number-of-rows-affected"&gt;New in Entity Framework 7: Bulk Operations with ExecuteDelete and ExecuteUpdate&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;167: 23-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Extend the middleware pipeline with IStartupFilter</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/22-startup-filters</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/22-startup-filters</guid>
			<pubDate>Thu, 22 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IStartupFilter&lt;/code&gt; interface can be used to extend either the &lt;em&gt;start&lt;/em&gt; or the &lt;em&gt;end&lt;/em&gt; the middleware pipeline.&lt;/p&gt;
&lt;p&gt;Any implementations of &lt;code&gt;IStartupFilter&lt;/code&gt; will automatically be called on application build &lt;code&gt;before any other middleware configuration&lt;/code&gt; is called.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="manual-middleware"&gt;Manual middleware&lt;/h2&gt;
&lt;p&gt;In the below example the basic &lt;em&gt;weatherforecast&lt;/em&gt; template is being extended to contain a manually added middleware component:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var summaries = new[]
{
    &amp;quot;Freezing&amp;quot;, &amp;quot;Bracing&amp;quot;, &amp;quot;Chilly&amp;quot;, &amp;quot;Cool&amp;quot;, &amp;quot;Mild&amp;quot;, &amp;quot;Warm&amp;quot;, &amp;quot;Balmy&amp;quot;, &amp;quot;Hot&amp;quot;, &amp;quot;Sweltering&amp;quot;, &amp;quot;Scorching&amp;quot;
};

app.MapGet(&amp;quot;/weatherforecast&amp;quot;, () =&amp;gt;
{
    // print out a message
    Console.WriteLine(&amp;quot;Weatherforecast endpoint called&amp;quot;);

    var forecast = Enumerable.Range(1, 5).Select(index =&amp;gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
});

// add the custom middleware manually
app.UseMiddleware&amp;lt;ManualMiddleware&amp;gt;();

app.Run();

internal record WeatherForecast(DateTime Date, int TemperatureC, string? Summary)
{
    public int TemperatureF =&amp;gt; 32 + (int)(TemperatureC / 0.5556);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The definition of &lt;code&gt;ManualMiddleware&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ManualMiddleware
{
    private readonly RequestDelegate _next;

    public ManualMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
       // this should be output before the request to 
       // forwarded onto the next component in the pipeline
       Console.WriteLine($&amp;quot;In the manually added &amp;quot; +
            $&amp;quot;middleware: {nameof(ManualMiddleware)}. &amp;quot; +
            $&amp;quot;The current datetime is '{DateTime.Now}'&amp;quot;);

        // call the next component with the context
        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling the endpoint, the console output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In the manually added middleware: ManualMiddleware. The current datetime is '2022/09/20 06:40:23'
Weatherforecast endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the component added to the middleware is invoked before forwarding the request onto the next component, and eventually the endpoint.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="istartupfilter-middleware"&gt;IStartupFilter middleware&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IStartupFilter&lt;/code&gt; only has one method to implement, &lt;code&gt;Configure&lt;/code&gt;, which takes an &lt;code&gt;Action&amp;lt;IApplicationBuilder&amp;gt;&lt;/code&gt; as an argument, and also return an &lt;code&gt;Action&amp;lt;IApplicationBuilder&amp;gt;&lt;/code&gt;. Below is our custom implementation of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CustomFilter : IStartupFilter
{
    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        return builder =&amp;gt;
        {
            // perform the custom build configuration
            Console.WriteLine($&amp;quot;Configured via {nameof(CustomFilter)}&amp;quot;);
            builder.UseMiddleware&amp;lt;HelloMiddleware&amp;gt;();

            // call the next item in the build pipeline
            next(builder);

            // add here to  change the end of the middleware pipeline
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;build pipeline&lt;/code&gt; operates similarly to how the &lt;code&gt;middleware pipeline&lt;/code&gt; operates - the custom component performs its build logic, before passing on the &lt;em&gt;build request&lt;/em&gt; to the next item in the build pipeline.&lt;/p&gt;
&lt;p&gt;In the above, the custom logic is writing a message to the console and then adding &lt;code&gt;another custom middleware component&lt;/code&gt; to the middleware pipeline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class HelloMiddleware
{
    private readonly RequestDelegate _next;

    public HelloMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(HelloMiddleware)}. &amp;quot; +
            $&amp;quot;The current datetime is '{DateTime.Now}'&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final step to putting it all together is to add the &lt;code&gt;CustomFilter&lt;/code&gt; implementation to the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IStartupFilter, CustomFilter&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the application start, the following is output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Configured via CustomFilter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then when calling the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Hello from HelloMiddleware. The current datetime is '2022/08/25 06:48:35'
In the manually added middleware: ManualMiddleware. The current datetime is '2022/08/25 06:48:35'
Weatherforecast endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output we can see, that the &lt;code&gt;middleware added using the IStartupFilter is invoked before the manually added middleware&lt;/code&gt;. We have used the &lt;em&gt;IStartupFilter&lt;/em&gt; implementation to add an item to the start of the middleware pipeline , achieved by only adding the &lt;em&gt;IStartupFilter&lt;/em&gt; implementation to the dependency injection container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="flow-summary"&gt;Flow summary&lt;/h2&gt;
&lt;p&gt;A summary of what we have covered so far, and how the various pieces fit together&lt;/p&gt;
&lt;h3 id="application-startup"&gt;Application startup&lt;/h3&gt;
&lt;p&gt;On application startup:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;em&gt;IStartupFilter&lt;/em&gt; implementation &lt;em&gt;CustomFilter&lt;/em&gt; is &lt;code&gt;added to the dependency injection&lt;/code&gt; container.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;WebApplication instance is run&lt;/code&gt;, with the &lt;em&gt;app.Run()&lt;/em&gt; command:
&lt;ol&gt;
&lt;li&gt;All implementations of &lt;em&gt;IStartupFilter&lt;/em&gt; are retrieved from the dependency injection container, and the &lt;code&gt;Configure&lt;/code&gt; method on the implementation invoked
In this above sample, the &lt;code&gt;Configure&lt;/code&gt; adds the &lt;em&gt;HelloMiddleware&lt;/em&gt; component to the start of the middleware pipeline.&lt;/li&gt;
&lt;li&gt;All other middleware components are configured
In this above sample, the &lt;em&gt;ManualMiddleware&lt;/em&gt; component is added to the middleware pipeline&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The middleware pipeline is now ready to receive requests.&lt;/p&gt;
&lt;h3 id="request-received"&gt;Request received&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;When a request is received, it will flow through the middleware pipeline, component by component in the order in which they were added to the pipeline:
&lt;ol&gt;
&lt;li&gt;The request is passed to the &lt;em&gt;HelloMiddleware&lt;/em&gt; component and the &amp;quot;hello&amp;quot; message is output (added via &lt;em&gt;IStartupFilter&lt;/em&gt; implementation)&lt;/li&gt;
&lt;li&gt;The request is passed to the &lt;em&gt;ManualMiddleware&lt;/em&gt; components and the relevent message is output (added explicitly)&lt;/li&gt;
&lt;li&gt;The request is then passed to the endpoint handler, to return generate the weather data (defined explicitly)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally most applications would not have a need for this functionality, but there are a couple of cases where it could be especially useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As a library author, and the library needs to inject middleware at the beginning or the end of the middleware pipeline&lt;/li&gt;
&lt;li&gt;Conversely, if a library is injecting middleware at the beginning or end of the pipeline and you as the application author needs to inject a component before/after the library.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-istartupfilter-in-asp-net-core/"&gt;Exploring IStartupFilter in ASP.NET Core &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;166: 22-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>