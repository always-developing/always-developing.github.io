<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Fri, 09 Dec 2022 03:40:54 GMT</pubDate>
		<lastBuildDate>Fri, 09 Dec 2022 03:40:54 GMT</lastBuildDate>
		<item>
			<title>Fast, potentially unsafe iteration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add</guid>
			<pubDate>Fri, 09 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CollectionsMarshal&lt;/code&gt;, &lt;code&gt;MemoryMarshal&lt;/code&gt; and &lt;code&gt;Unsafe&lt;/code&gt; can be used in conjunction to create a &lt;em&gt;very fast&lt;/em&gt; &lt;code&gt;method of iteration&lt;/code&gt; (possibly the fastest method of performing for loops in C#)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iteration"&gt;Iteration&lt;/h2&gt;
&lt;p&gt;The technique may look a bit complex and complicated at first glance (or at least more complex than a normal &lt;code&gt;for&lt;/code&gt; loop) - but going through it step-by-step it is actually relatively simple. This technique is also not as &lt;code&gt;safe&lt;/code&gt; as the traditional method, due to the way memory is being handled in a potentially &lt;code&gt;unsafe&lt;/code&gt; way.&lt;/p&gt;
&lt;p&gt;The full code snippet is at the bottom of the section, but for now we'll have a look at it step-by-step.&lt;/p&gt;
&lt;p&gt;Assume we have a list of 50 items we want to iterate through:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="list-to-span"&gt;List to Span&lt;/h3&gt;
&lt;p&gt;The first step is to convert the &lt;code&gt;List&lt;/code&gt; to a &lt;code&gt;Span&lt;/code&gt;, using the &lt;em&gt;System.Runtime.InteropServices.CollectionsMarshal.AsSpan&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the &lt;code&gt;Span&lt;/code&gt; is in use, (as per the documentation) &lt;em&gt;items should not be added or removed from List&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="span-reference"&gt;Span reference&lt;/h3&gt;
&lt;p&gt;The next step is to get a reference to the &lt;em&gt;element of the span at index 0&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref int searchLocation = ref MemoryMarshal.GetReference(itemsAsSpan);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;em&gt;searchLocation&lt;/em&gt; is effectively now pointing to the first item in the &lt;em&gt;Span&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="iterate"&gt;Iterate&lt;/h3&gt;
&lt;p&gt;Next, we can perform the actual iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// for loop as per usual
for (int i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    // Instead of using itemsAsSpan[i], which is still fast
    // we start with the first item (searchLocation)
    // and offset it by i items
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop is defined as per normal, but instead of accessing the &lt;code&gt;Span&lt;/code&gt; item at position &lt;em&gt;i&lt;/em&gt; as one usually would (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), the &lt;code&gt;Unsafe.Add&lt;/code&gt; method is used.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unsafe.Add&lt;/code&gt; &lt;em&gt;adds an element offset to the given reference&lt;/em&gt; - in this case it will use &lt;em&gt;searchLocation&lt;/em&gt;, the first item in the Span as the given reference, and offset by &lt;em&gt;i items&lt;/em&gt; each time.
Each iteration, the offset is larger (as i increases) and as the given reference, &lt;em&gt;searchLocation&lt;/em&gt;, stays the same the item being referenced each loop is different.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="code-snippet"&gt;Code snippet&lt;/h3&gt;
&lt;p&gt;The full code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);

for (var i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;A full breakdown of the performance can be seen on Nick Chapsas's video, &lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8&amp;amp;t=490s"&gt;right here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But in short, using &lt;code&gt;the above method is the fastest way to iterate&lt;/code&gt;, slightly beating out using the index on the span (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), but significantly faster than all other methods (for loop, foreach loop etc)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This should probably not be the go-to iteration method for all applications in all use cases - however, when performance is critical and every fraction of a second is important, then this kind of optimization could make a difference.
As mentioned, this technique is less &amp;quot;safe&amp;quot; than the usual &lt;em&gt;for&lt;/em&gt; or &lt;em&gt;foreach&lt;/em&gt; methods, so should be used with caution.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8"&gt;The weirdest way to loop in C# is also the fastest&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;219: 09-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>EF7 GroupBy support</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by</guid>
			<pubDate>Thu, 08 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Prior to Entity Framework 7, having a LINQ &lt;code&gt;GroupBy&lt;/code&gt; as the final operator in a query would result in an exception being thrown - EF7 adds support for this scenario, allowing &lt;code&gt;GroupBy&lt;/code&gt; to be the final operator.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;In this scenario, we have a simple &lt;em&gt;Blog&lt;/em&gt; class, setup as a &lt;em&gt;DbSet&lt;/em&gt; in a &lt;em&gt;DbContext&lt;/em&gt;, configured to connect to SQL Server:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we want to &lt;em&gt;select all Blogs&lt;/em&gt;, but &lt;code&gt;group them by the DateCreated&lt;/code&gt; - lets see how this can be done.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="before-ef7"&gt;Before EF7&lt;/h3&gt;
&lt;p&gt;If we try perform the &lt;em&gt;GroupBy&lt;/em&gt; as the final operation &lt;code&gt;prior to EF7&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we're not querying the actual database
// just getting the query which would be 
// generated
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

Console.WriteLine(query);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An exception is thrown!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The LINQ expression 'DbSet&amp;lt;Blog&amp;gt;().GroupBy(b =&amp;gt; b.DateCreated)' could not be translated. 
Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To perform this, the &lt;em&gt;group by&lt;/em&gt; logic would need to be done in code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// get all relevent blogs, ungrouped
var List&amp;lt;Blog&amp;gt; = context.Blogs.ToList();

// group the blogs by date in code
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? blogByDate = 
    blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the requirement to group by &lt;em&gt;DateCreated&lt;/em&gt; is definitely do-able, just maybe not as simple and intuitive to do as it should be.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ef7"&gt;EF7&lt;/h3&gt;
&lt;p&gt;EF7 makes implementing the same requirement a little bit easier. Upgrading to EF7, and executing the exact same code as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we not querying the actual database
// just getting the query the following would
// generate
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now yields the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;SELECT [b].[DateCreated], [b].[Id], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
ORDER BY [b].[DateCreated]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;GroupBy&lt;/em&gt; is not perform on the database itself, but is again, performed in code - just this time it is done automatically by EF.&lt;/p&gt;
&lt;p&gt;The output type is the same as when the operation is performed manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small enhancement to EF, but one which makes building up queries in EF using LINQ more intuitive, and results in the developer having to do slightly less work overall.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1595887786535575554"&gt;Oleg Kyrylchuk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 08-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Unreachable code and UnreachableException</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/07-unreachable-exception</guid>
			<pubDate>Wed, 07 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; was introduced in .NET 7, which is used in situations &lt;em&gt;when the application executes code thought to be unreachable&lt;/em&gt;. If this exception does occur, then there is an error in the flow or data of the application causing the, previous thought, unreachable code to be executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unreachable-code-setup"&gt;Unreachable code setup&lt;/h2&gt;
&lt;p&gt;Consider the follow example of example - we have an &lt;code&gt;enum&lt;/code&gt; of &lt;em&gt;OrderStatus&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum OrderStatus
{
    New = 0,
    Processing = 1,
    Fulfilled = 2,
    OutOnDelivery = 3,
    Delivered = 4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As well as a switch expression to convert the &lt;code&gt;enum&lt;/code&gt; value to a &lt;code&gt;string description&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;UnreachableException&lt;/code&gt; is used if the code tries to convert an &lt;code&gt;OrderStatus which does not exist&lt;/code&gt; to a string - in theory a situation which should never occur.&lt;/p&gt;
&lt;p&gt;We also have a method to retrieve the order status, &lt;code&gt;stored as an int&lt;/code&gt;, from the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public OrderStatus GetOrderStatusFromDatabase()
{
    // simulate getting the value from the database
    return (OrderStatus)2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="executing-unreachable-code"&gt;Executing unreachable code&lt;/h2&gt;
&lt;p&gt;If the database stores a valid &lt;em&gt;OrderStatus&lt;/em&gt; int value, everything will execute as expected.&lt;/p&gt;
&lt;p&gt;In this example, the database &lt;code&gt;stores an OrderStatus value of 2&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 2
OrderStatus currentStatus = GetOrderStatusFromDatabase();

var currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException()
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Order: Processing Order
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if the &lt;em&gt;OrderStatus&lt;/em&gt; was manually, incorrectly &lt;code&gt;updated to be 5&lt;/code&gt; in the database - this is a situation which &lt;em&gt;should never happen, but in reality it could&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// currentStatus is 5
OrderStatus currentStatus = GetOrderStatusFromDatabase();

string currentStatusText = currentStatus switch
{
    OrderStatus.New =&amp;gt; &amp;quot;Order Placed&amp;quot;,
    OrderStatus.Processing =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.Fulfilled =&amp;gt; &amp;quot;Processing Order&amp;quot;,
    OrderStatus.OutOnDelivery =&amp;gt; &amp;quot;Order is out on delivery&amp;quot;,
    OrderStatus.Delivered =&amp;gt; &amp;quot;Order is delivered&amp;quot;,
    _ =&amp;gt; throw new UnreachableException($&amp;quot;OrderStatus enum &amp;quot; +
        $&amp;quot;value {currentStatus} invalid&amp;quot;)
};

Console.WriteLine($&amp;quot;Order status: {currentStatusText}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The C# code &lt;code&gt;allows the currentStatus variable to be set to a value of 5, an enum value which doesn't exist&lt;/code&gt; - and only when it comes time to convert to a string (in the  switch expression), will there be no match to any of the options and the &lt;code&gt;UnreachableException&lt;/code&gt; be thrown.&lt;/p&gt;
&lt;p&gt;Monitoring tools or logs can now be checked for the presence of &lt;code&gt;UnreachableException&lt;/code&gt; and if such an exception occurs, something has gone wrong.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful tool at a developers disposal to assist in tracking down completely unexpected issues which may arise - but a tool which should hopefully never actually be reached to be used!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=s_NrqRI7Gnc&amp;amp;t=308s"&gt;The new .NET Exception that should NEVER be thrown&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 07-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Determining bytes of memory allocated</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/06-getallocatedbytes</guid>
			<pubDate>Tue, 06 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;em&gt;Garbage Collector&lt;/em&gt; class &lt;code&gt;GC&lt;/code&gt; contains a &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; method which can be used to &lt;em&gt;get the number of bytes allocated&lt;/em&gt; in the current thread (as the name implies).&lt;/p&gt;
&lt;p&gt;This can be leveraged to discover some interesting facts about how the application is allocated &lt;em&gt;unessacary memory&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getallocatedbytes-usage"&gt;GetAllocatedBytes usage&lt;/h2&gt;
&lt;p&gt;The usage of &lt;code&gt;GetAllocatedBytesForCurrentThread&lt;/code&gt; is very simple and straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get the bytes allocated at the start of the process
long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declare a string and use it
string strValue = &amp;quot;This is a string&amp;quot;;
Console.WriteLine(strValue);

// get the bytes allocated after
long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

// output the results
Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A snapshot of the bytes used is taken before the work, and then again after.&lt;/p&gt;
&lt;p&gt;The result of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a string
Before allocation: 1761952 | After allocation: 1764552
Bytes used: 2600
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="interesting-findings"&gt;Interesting findings&lt;/h2&gt;
&lt;h3 id="unused-variable"&gt;Unused variable&lt;/h3&gt;
&lt;p&gt;In some instances, if a variable is defined, but never used, the compiler will remove it and no memory will be allocated.&lt;/p&gt;
&lt;p&gt;Below is the same example as above, but &lt;em&gt;without the variable &amp;quot;strValue&amp;quot; ever being used&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// declared, but never used
string strValue = &amp;quot;This is a string&amp;quot;;

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output here:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768144 | After allocation: 1768144
Bytes used: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler is performing optimizations to remove unused code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="empty-array"&gt;Empty array&lt;/h3&gt;
&lt;p&gt;Declaring an empty array, will still allocated memory - this is because the array itself is of type &lt;code&gt;Array&lt;/code&gt; and contains information about what the array itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768112
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Declaring multiple empty arrays, will use memory in multiples of 24 bytes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

int[] list = new int[0];
int[] list1 = new int[0];
int[] list2 = new int[0];

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output for this, 24 bytes x 3:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1768088 | After allocation: 1768160
Bytes used: 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use less memory, the static &lt;code&gt;Array.Empty&lt;/code&gt; method is used. This will assign the same empty static array to each instance, thus not allocated additional memory each time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long beforeAllocation = GC.GetAllocatedBytesForCurrentThread();

// use Array.Empty instead of new []
int[] list = Array.Empty&amp;lt;int&amp;gt;();
int[] list1 = Array.Empty&amp;lt;int&amp;gt;();
int[] list2 = Array.Empty&amp;lt;int&amp;gt;();

long afterAllocation = GC.GetAllocatedBytesForCurrentThread();

Console.WriteLine($&amp;quot;Before allocation: {beforeAllocation} | &amp;quot; +
    $&amp;quot;After allocation: {afterAllocation}&amp;quot;);
Console.WriteLine($&amp;quot;Bytes used: {afterAllocation - beforeAllocation}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output, only 24 bytes used in total:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before allocation: 1761896 | After allocation: 1761920
Bytes used: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful method which can help benchmark memory usage in an application, as well as just provide an insight into interesting aspects of how the compiler allocates (or doesn't allocated) memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/db43d6f4-4b93-415f-be03-600ee358cdfd"&gt;How to get allocations in .NET? And how big is an empty array?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;217: 06-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Parse a string to anything</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/05-iparseable</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/05-iparseable</guid>
			<pubDate>Mon, 05 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# 11 introduced the ability to define &lt;code&gt;static abstract member&lt;/code&gt; (read more about those &lt;a href="https://blog.ndepend.com/c-11-static-abstract-members/"&gt;here&lt;/a&gt;) - this allowed for the introduction of the &lt;code&gt;IParseable&amp;lt;TSelf&amp;gt;&lt;/code&gt;, which allows for a &lt;code&gt;string to be parsed into any type&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iparseable-interface"&gt;IParseable interface&lt;/h2&gt;
&lt;p&gt;A quick look at the interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IParsable&amp;lt;TSelf&amp;gt; where TSelf : IParsable&amp;lt;TSelf&amp;gt;?
{
    static abstract TSelf Parse(string s, IFormatProvider? provider);
    static abstract bool TryParse([NotNullWhen(true)] string? s, 
        IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the interface defines two &lt;code&gt;Parse&lt;/code&gt; methods - both for &lt;em&gt;parsing a string&lt;/em&gt; into the &lt;code&gt;TSelf&lt;/code&gt; type. To leverage this functionality, as with other interfaces, the class which is to be &lt;em&gt;converted from a string needs to implement IParsable&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iparseable-implementation"&gt;IParseable implementation&lt;/h2&gt;
&lt;p&gt;In this example we have a simple &lt;code&gt;Song&lt;/code&gt; class which implements &lt;code&gt;IParsable&amp;lt;Song&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song : IParsable&amp;lt;Song&amp;gt;
{
    public string Name { get; set; }
    public string Artist { get; set; }
    public int LengthInSeconds { get; set; }

    private Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }

    public static Song Parse(string s, IFormatProvider? provider)
    {
        // implementation detailed below
    }

    public static bool TryParse([NotNullWhen(true)] string? s, 
        IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
    {
        // implementation detailed below
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we'll write the methods to do the parsing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="parse-implementation"&gt;Parse implementation&lt;/h3&gt;
&lt;p&gt;The simple &lt;code&gt;Parse&lt;/code&gt; method implementation will perform the conversion from &lt;em&gt;string to song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static Song Parse(string s, IFormatProvider? provider)
{
    string[] songPortions = s.Split(new[] { '|' });

    // make sure the string is in the correct format
    if (songPortions.Length != 3) 
    { 
        throw new OverflowException(&amp;quot;Expect format: Name|Artist|LengthInSeconds&amp;quot;); 
    }

    return new Song(songPortions[0], songPortions[1], Int32.Parse(songPortions[2]));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is straight-forward - the string representation is expected in a specific format, and once it is confirmed all information is present, a new &lt;code&gt;Song&lt;/code&gt; instance is declared and returned based on this information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tryparse-implementation"&gt;TryParse implementation&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;TryParse&lt;/code&gt; implementation leveraged the &lt;code&gt;Parse&lt;/code&gt; method to &lt;em&gt;try&lt;/em&gt; parse the string, and returns &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt; indicating if the parsing was successful or not, as well as a &lt;code&gt;Song&lt;/code&gt; instance if the string was able to be parsed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static bool TryParse([NotNullWhen(true)] string? s, 
    IFormatProvider? provider, [MaybeNullWhen(false)] out Song result)
{
    // do some checks
    result = null;
    if (s == null) 
    { 
        return false; 
    }

    // parse the string 
    try
    {
        result = Parse(s, provider);
        return true;
    }
    catch { return false; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IParsable&amp;lt;TSelf&amp;gt;&lt;/code&gt; interface allows for any class to use a generic interface to define how it can be instantiated from a string. Leveraging the interface and functionality is simple and easy to implement (the parsing logic might not always be though).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This may seem like a relatively small enhancement (and it is) - but it provides a very convenient way to parse string information. The new C# 11 &lt;code&gt;static abstract member&lt;/code&gt; functionality also opens the door for new techniques and coding possibilities.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/the-new-net-7-0-iparsable-interface/"&gt;The new .NET 7.0 IParsable&lt;TSelf&gt; interface&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://blog.ndepend.com/c-11-static-abstract-members/"&gt;C# 11 static abstract members&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;216: 05-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Compiler Warning CS8981</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/02-compiler-warning</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/02-compiler-warning</guid>
			<pubDate>Fri, 02 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# 11 introduced a new compiler warning CS8981, which is raised when a type is declared &lt;code&gt;consisting of only lowercase letters&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="the-warning"&gt;The warning&lt;/h2&gt;
&lt;p&gt;Considering the following class declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class myclass
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When using C# 11, this will raise the following warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The type name 'myclass' only contains lower-cased ascii characters. 
    Such names may become reserved for the language.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code will still compiled and execute, but the compiler is &lt;em&gt;warning&lt;/em&gt; the developer about potential future issues.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-reason"&gt;The reason&lt;/h2&gt;
&lt;p&gt;There are a couple of reasons for the warning (and I am sure other's I have not mentioned here):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Encourages best practices for class declarations, which should be declared using &lt;em&gt;PascalCase&lt;/em&gt; as a default&lt;/li&gt;
&lt;li&gt;As explicitly mentioned in the warning, it prevents potential future conflicts with potential reserved language names - this allows future versions of the language to include new keywords, limiting the impact on existing applications&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, almost inconsequential language feature - but personally I am big fan of these kinds of initiatives, and hope to see more in future versions. They help guide developers down the &amp;quot;pit of success&amp;quot; path (which not forcing it outright), and they also allow the developers of the language to enhance and grow it, with limited naming conflicts.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://newdevsguide.com/2022/11/13/the-best-csharp-11-feature/"&gt;The Best C# 11 Feature You Don’t Need&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;215: 02-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Custom feature filters</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/01-context-feature</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/01-context-feature</guid>
			<pubDate>Thu, 01 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Microsoft.FeatureManagement&lt;/code&gt; library, allows for a custom &lt;code&gt;context&lt;/code&gt; to be defined, and evaluated to &lt;code&gt;determine if specific functionality should be enabled or not&lt;/code&gt;, &lt;em&gt;for the specific context&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This functionality has no dependency on ASP.NET or &lt;em&gt;HttpContext&lt;/em&gt;, and as such can be used in any application type (such as console app).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;There are a number of moving pieces to the setup, which requires some classes be defined and some configuration specified to leverage the &lt;em&gt;custom feature filter management&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="define-the-context"&gt;Define the context&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;code&gt;context&lt;/code&gt; - this is a simple class which will contain all the information which will be evaluated to determine if the feature or functionality should be enabled or not.&lt;/p&gt;
&lt;p&gt;In this example, the context will just contain the user's email address:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class User
{
    public string Email { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In short - a &lt;code&gt;context&lt;/code&gt; will be created containing the supplied email address, which will be evaluated against &lt;em&gt;settings&lt;/em&gt; to determine if &lt;em&gt;normal&lt;/em&gt; or &lt;em&gt;enhanced&lt;/em&gt; processing is to occur.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-settings"&gt;Define the settings&lt;/h3&gt;
&lt;p&gt;The next step is to define a &lt;em&gt;settings&lt;/em&gt; class, which will contain properties against which the &lt;code&gt;context&lt;/code&gt; values will be evaluated.&lt;/p&gt;
&lt;p&gt;In this example, we want the &lt;em&gt;user email address domain&lt;/em&gt;, defined in the &lt;code&gt;User&lt;/code&gt; context, to be compared with a &lt;em&gt;company domain&lt;/em&gt;, defined in the settings class, &lt;code&gt;EnhancedUserSettings&lt;/code&gt;, to determine if the user should be processed using the &lt;em&gt;enhanced/preview feature&lt;/em&gt;, or the &lt;em&gt;standard existing feature&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedUserSettings
{
    public string EmailDomain { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essentially what it comes down to, is evaluating if the &lt;code&gt;email address defined in the User context has the same domain defined in the settings EnhancedUserSettings&lt;/code&gt;. If so, then the &lt;em&gt;feature&lt;/em&gt; is enabled, otherwise the feature is not enabled.&lt;/p&gt;
&lt;p&gt;The usage of this and how each class fits together will become apparent in the steps below.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-filter"&gt;Define the filter&lt;/h3&gt;
&lt;p&gt;Next, we have to define the &lt;code&gt;filter&lt;/code&gt; - this piece of code will do the actual logic to evaluate and determine if the feature should be enabled or not, based on the &lt;code&gt;context&lt;/code&gt; and &lt;code&gt;settings&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EmailDomainFilter : IContextualFeatureFilter&amp;lt;User&amp;gt;
{
    public Task&amp;lt;bool&amp;gt; EvaluateAsync(FeatureFilterEvaluationContext featureFilterContext, 
        User appContext)
    {
        // get the value from the parameters configured
        var settings = featureFilterContext.Parameters.Get&amp;lt;EnhancedUserSettings&amp;gt;();

        // perform the check
        return Task.FromResult(appContext.Email?.Split(&amp;quot;&amp;#64;&amp;quot;).Last() == 
            settings.EmailDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filter implements &lt;code&gt;IContextualFeatureFilter&amp;lt;Context&amp;gt;&lt;/code&gt;, which contains one method &lt;em&gt;EvaluateAsync&lt;/em&gt;. &lt;em&gt;EvaluateAsync&lt;/em&gt; takes a generic &lt;em&gt;FeatureFilterEvaluationContext&lt;/em&gt; context, as well as the specific &lt;em&gt;User&lt;/em&gt; context defined for this filter.&lt;/p&gt;
&lt;p&gt;In the above, the &lt;code&gt;EnhancedUserSettings&lt;/code&gt; instance is obtained from the generic &lt;em&gt;FeatureFilterEvaluationContext&lt;/em&gt; context - this retrieves the values based on the configuration defined in the next section.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="define-the-configuration"&gt;Define the configuration&lt;/h3&gt;
&lt;p&gt;In the &lt;code&gt;appsettings.json&lt;/code&gt; the filter feature functionality needs to be configured:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;&amp;quot;FeatureManagement&amp;quot;: {
    &amp;quot;EnhancedUserProcessing&amp;quot;: {
      &amp;quot;EnabledFor&amp;quot;: [
        {
          &amp;quot;Name&amp;quot;: &amp;quot;EmailDomain&amp;quot;,
          &amp;quot;Parameters&amp;quot;: {
            &amp;quot;EmailDomain&amp;quot;: &amp;quot;mycompany.co.za&amp;quot;
          }
        }
      ]
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The configuration defines the filter and how it should be used:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There is a feature called &lt;code&gt;EnhancedUserProcessing&lt;/code&gt; (the name of this is important, which we will see when it comes time to use the functionality)&lt;/li&gt;
&lt;li&gt;This feature uses a filter called &lt;code&gt;EmailDomain&lt;/code&gt; - the name of the class which implements &lt;code&gt;IContextualFeatureFilter&lt;/code&gt;, &lt;em&gt;EmailDomainFilter&lt;/em&gt; in this example (the name of the class plus &lt;em&gt;Filter&lt;/em&gt; as a suffix to the class name),&lt;/li&gt;
&lt;li&gt;The parameters for this filter, &lt;code&gt;EnhancedUserSettings&lt;/code&gt;, will have a property called &lt;em&gt;EmailDomain&lt;/em&gt; which will have a value set to &lt;code&gt;mycompany.co.za&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id="setup-recap"&gt;Setup Recap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Define the &lt;code&gt;context&lt;/code&gt; - this will be the information which is dynamic (each user/request/etc will have different context values) and which is compared to the &lt;code&gt;settings&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;settings&lt;/code&gt; - this is the class which will contain the information the &lt;code&gt;context&lt;/code&gt; is compared against, to determine if the feature is enabled or not. This is static information, and is the same for all evaluations&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;filter&lt;/code&gt; - this specified exactly &lt;em&gt;how&lt;/em&gt;, the &lt;code&gt;context&lt;/code&gt; values are compared with the &lt;code&gt;settings&lt;/code&gt; values&lt;/li&gt;
&lt;li&gt;Define the &lt;code&gt;configuration&lt;/code&gt; - gives the filter a name, and specifies the &lt;code&gt;settings&lt;/code&gt; values&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Finally, let's look at the usage of the &lt;code&gt;filter feature&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below a minimal API endpoint is defined to demonstrate the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// add feature management to DI container
// and add the specific filter
builder.Services.AddFeatureManagement()
       .AddFeatureFilter&amp;lt;EmailDomainFilter&amp;gt;();

var app = builder.Build();

// inject IFeatureManager implementation from the DI container
// get the email from the URL route 
app.MapGet(&amp;quot;/process/{email}&amp;quot;, async ([FromServices]IFeatureManager featureManager,
    [FromRoute]string email) =&amp;gt;
{
    // check if the feature with the name `EnhancedUserProcessing` is enabled
    // or not for the specific context (the user email)
    if(await featureManager.IsEnabledAsync(&amp;quot;EnhancedUserProcessing&amp;quot;, 
        new User { Email = email }))
    {
        return &amp;quot;Processed using ENHANCED features&amp;quot;;
    }

    return &amp;quot;Processed using NORMAL features&amp;quot;;
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IFeatureManager&lt;/code&gt; is injected into the relevent class/method, and the &lt;em&gt;IsEnabledAsync&lt;/em&gt; method is called. The specific feature to use (specified by name) is supplied along  with the relevent &lt;code&gt;context&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Browsing to the endpoint &lt;code&gt;/process/alwaysdevelpoping&amp;#64;mycompany.co.za&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processed using ENHANCED features
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While using an email with any other domain will result in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Processed using NORMAL features
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a simple example, but the library does offer more sophisticated functionality around the configuration and options available to evaluate the filter (see the links available under references)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The ability to turn off/on specific features for a specific subset of users/records is a valuable tool when trying to roll out useful, experimental or preview functionality quickly to get &amp;quot;real world&amp;quot; feedback before it gets rolled out completely.
There are other more sophisticated 3rd party feature management tool available (LaunchDarkly for example), but the &lt;code&gt;Microsoft.FeatureManagement&lt;/code&gt; library is entirely adequate, especially as a starting point.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://coderethinked.com/contextual-feature-filters-in-asp-net-core/"&gt;Contextual Feature Filters in ASP.NET Core&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/use-feature-flags-dotnet-core?tabs=core5x"&gt;Tutorial: Use feature flags in an ASP.NET Core app&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;214: 01-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Short and arithmetic operations</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/30-short-support</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/30-short-support</guid>
			<pubDate>Wed, 30 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When performing arithmetic operations on &lt;code&gt;short&lt;/code&gt; data types, their values are converted to the &lt;code&gt;int&lt;/code&gt; types, which is also the type of the result of the operation.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;When working with integral types which could be an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;short&lt;/code&gt;, the compiler will infer &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the compiler will infer than intValue is 
// an int (even though it could be a short)
// in this specific example
var intValue = 32 / 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when specifying the variable type explicitly, the compiler will infer the value as a &lt;code&gt;short&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;short shortValue = 32 / 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the value &lt;em&gt;32&lt;/em&gt; is inferred as a &lt;code&gt;short&lt;/code&gt;, and the output of the operator is explicitly declared as a &lt;code&gt;short&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All good so far - but now is where the are a bit unexpected.&lt;/p&gt;
&lt;p&gt;Operations on an &lt;em&gt;explicitly defined&lt;/em&gt; short value, will result in a &lt;code&gt;int result&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// short value is definitely a short
short shortValue = 32 / 2;

// int response, all good
int intOutput = shortValue / 2;

// ERROR: this gives a compiler error
//short shortOutput = (shortValue / 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the last operation, even though it is being performed on a short value, the result is an &lt;code&gt;int&lt;/code&gt; and the above results in the error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot implicitly convert type 'int' to 'short'. An explicit conversion exists (are you missing a cast?)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thankfully, the error is very easy to resolve - as the error states, an explicit conversion needs to be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// All good!
short shortOutput = (short)(shortValue / 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small quirk of the language, which if encountered just needs to be managed and handled. Before being aware of this knowledge, I would have assumed that a &lt;code&gt;short&lt;/code&gt; would be returned from an operation where the operands were defined as &lt;code&gt;short&lt;/code&gt; - this assumption would be incorrect though!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/ysm6lx/why_am_i_being_forced_to_cast_to_shorts_when_i_am/"&gt;Reddit Post&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;213: 30-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Dynamic LINQ with System.Linq.Dynamic.Core</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/29-dyanmic-linq</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/29-dyanmic-linq</guid>
			<pubDate>Tue, 29 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The third-party, &lt;em&gt;open source&lt;/em&gt; library &lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; extends LINQ functionality allowing &lt;em&gt;dynamic, string based LINQ queries&lt;/em&gt; to be parsed, resulting in operations identical to regular LINQ.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In all of the below examples, the following snippet of code is used to get a sample collection of &lt;em&gt;Song&lt;/em&gt; entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;Song&amp;gt; GetSongs()
{
    return new[]
    {
        new Song(&amp;quot;Learn to Fly&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 245),
        new Song(&amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 312),
        new Song(&amp;quot;Bigger than my Body&amp;quot;, &amp;quot;John Mayer&amp;quot;, 281),
    };
};

public record Song(string Name, string Artist, int LengthInSeconds);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The extension methods &lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; offer are available on the &lt;em&gt;IQueryable&lt;/em&gt; interface. As such in the examples the &lt;em&gt;IEnumerable&amp;lt;Song&amp;gt;&lt;/em&gt; returned from the &lt;code&gt;GetSongs&lt;/code&gt; method is required to be converted to &lt;em&gt;IQueryable&amp;lt;Song&amp;gt;&lt;/em&gt; using the &lt;code&gt;AsQueryable&lt;/code&gt; method before the extension methods are available.&lt;/p&gt;
&lt;p&gt;Below come common use cases are shown, but the library does offer a lot more functionality - see the references links below for more information on the library.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="select"&gt;Select&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; can be used to dynamically &lt;em&gt;Select&lt;/em&gt; a property value from a collection of entities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// using traditional LINQ
List&amp;lt;string&amp;gt; namesLinq = songs
  .Select(s =&amp;gt; s.Name)
  .ToList();

// dynamically specifying the property to be returned
List&amp;lt;string&amp;gt; nameDynamic = songs
  .AsQueryable()
  .Select(&amp;quot;Name&amp;quot;)
  .ToDynamicList&amp;lt;string&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;em&gt;anonymous or dynamic&lt;/em&gt; entity can also be &lt;em&gt;Selected&lt;/em&gt; out of the collection dynamically:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional
var nameArtistLinq = songs
  .Select(s =&amp;gt; new { s.Name, s.Artist })
  .ToList();

// dynamic
List&amp;lt;dynamic&amp;gt; nameArtistDynamic = songs
  .AsQueryable()
  .Select(&amp;quot;new { Name, Artist}&amp;quot;)
  .ToDynamicList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very powerful, allowing the columns to be selected to be determined &lt;em&gt;at runtime&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="filtering"&gt;Filtering&lt;/h3&gt;
&lt;p&gt;The library also provides the ability to dynamically filter a collection of records:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional
List&amp;lt;Song&amp;gt; filterLinq = songs
  .Where(x =&amp;gt; x.Artist == &amp;quot;Foo Fighters&amp;quot;)
  .ToList();

// dynamic
string column = &amp;quot;Artist&amp;quot;;
string value = &amp;quot;Foo Fighters&amp;quot;;
List&amp;lt;Song&amp;gt; filterDynamic = songs
  .AsQueryable()
  .Where($&amp;quot;{column} == \&amp;quot;{value}\&amp;quot;&amp;quot;)
  .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, very powerful as it allows the filter criteria to be be generated &lt;em&gt;at runtime&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Outputting the result of the filtering for each technique yields the same result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(filterLinq.Count());
Console.WriteLine(filterDynamic.Count());

// ouput:
// 2
// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="ordering"&gt;Ordering&lt;/h3&gt;
&lt;p&gt;The library also offers the ability to dynamically order a collection:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// traditional LINQ ordering
List&amp;lt;Song&amp;gt; orderLinq = songs
  .OrderBy(s =&amp;gt; s.LengthInSeconds)
  .ToList();
  
List&amp;lt;Song&amp;gt; orderDescLinq = songs
  .OrderByDescending(s =&amp;gt; s.LengthInSeconds)
  .ToList();

// dynamic ordering
List&amp;lt;Song&amp;gt; orderDynamic = songs
  .AsQueryable()
  .OrderBy(&amp;quot;LengthInSeconds&amp;quot;)
  .ToList();

List&amp;lt;Song&amp;gt; orderDescDynamic = songs
  .AsQueryable()
  .OrderBy(&amp;quot;LengthInSeconds desc&amp;quot;)
  .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The functionality the library offers is very easy and intuitive to use, as one can see from the above examples.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very powerful library, and more functionality than described here. If dynamic LINQ is not required, I do not recommend replacing traditional strongly-typed LINQ with this as a based, however in cases where flexibility to change the LINQ at runtime is required, this library is incredibly powerful.&lt;/p&gt;
&lt;p&gt;If this is of interest it is definitely recommended to check out the &lt;em&gt;Dynamic LInq&lt;/em&gt; reference link below for more information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/using-dynamic-linq/"&gt;Using Dynamic LINQ With System.Linq.Dynamic.Core Library&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://dynamic-linq.net/"&gt;Dynamic LINQ&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;212: 29-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Null-coalescing operator and associativity</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/28-null-coalescing-assoc</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/28-null-coalescing-assoc</guid>
			<pubDate>Mon, 28 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;null-coalescing operator&lt;/code&gt; (&lt;code&gt;??&lt;/code&gt;) is right-associative, and can be chained together to check multiple values, in order, to eventually arrive at a non-null value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;The example for this situation is fairly simple - the operator &lt;code&gt;??&lt;/code&gt; can be used in a chain to check (and return) the &lt;em&gt;first non-null value&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int? GetValue(int? value1, int? value2, int? value3, int defaultValue)
{
  // chain the operator and return the first non-null value
    return value1 ?? value2 ?? value3 ?? defaultValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The values are evaluated left to right to check if they are &lt;code&gt;null&lt;/code&gt;, and the first non-null value is returned. In this example &lt;em&gt;defaultValue&lt;/em&gt; is an &lt;code&gt;int&lt;/code&gt; and as such cannot be null, so the method will always return a value.&lt;/p&gt;
&lt;p&gt;Invoking this with a variety of permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(GetValue(null, null, 0, 0));
Console.WriteLine(GetValue(null, 1, 2, 0));
Console.WriteLine(GetValue(2, 5, null, 0));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results in the following, expected output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;0
1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each each case the first non-null value is returned. If all &lt;em&gt;nullable&lt;/em&gt; values are null, then the default is returned.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This small, but useful piece of information for today might seem obvious, and it is once you think about it - personally I've just never encountered the technique or the need to chain together multiple null checks using the &lt;code&gt;null-coalescing&lt;/code&gt; operator. However, if I ever do, I now know that chaining is possible.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/null-coalescing-operator-null-coalescing-assignment-operator-csharp/"&gt;Null-Coalescing Operators’ Associativity&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;211: 28-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>