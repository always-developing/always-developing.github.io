<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2023</copyright>
		<pubDate>Thu, 21 Sep 2023 03:35:48 GMT</pubDate>
		<lastBuildDate>Thu, 21 Sep 2023 03:35:48 GMT</lastBuildDate>
		<item>
			<title>Introducing the Source Generator Toolkit</title>
			<link>https://alwaysdeveloping.net/p/2023-07-source-gen-toolkit</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/p/2023-07-source-gen-toolkit</guid>
			<pubDate>Mon, 24 Jul 2023 03:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Ever wanted to try leverage &lt;em&gt;Roslyn Source Generators&lt;/em&gt;, but the process seemed too complex? The &lt;a href="https://www.nuget.org/packages/SourceGeneratorToolkit"&gt;&lt;code&gt;Source Generator Toolkit&lt;/code&gt;&lt;/a&gt; aims to make this process easier, but providing two pieces of core functionality:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Code Generation&lt;/code&gt;: this can be leveraged in conjunction with the Roslyn Source Generator process, or standalone and allows for the easy generation of C# source code using a &lt;em&gt;fluent builder pattern&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Code Qualification&lt;/code&gt;: this is leverage as part of the Roslyn Source Generator process, and make the process of &lt;em&gt;determining if a syntax node qualifies for source generation&lt;/em&gt; easier and more stream-lined.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="reason-for-the-library"&gt;Reason for the library&lt;/h2&gt;
&lt;p&gt;The main aim of the code generation functionality of the library is to &lt;code&gt;remove as much of the hard-coded C# strings required when creating a source generator as possible&lt;/code&gt;. Some hard-coded &lt;em&gt;strings of code&lt;/em&gt; will still be required for specific logic, however the main scaffolding of the classes, methods etc can be done through the library using a &lt;em&gt;fluent builder pattern&lt;/em&gt;. This pattern makes it easy to build up the source code logically, with each component building on the previous one.&lt;/p&gt;
&lt;p&gt;While the initial idea was for the &lt;code&gt;Source Generator Toolkit&lt;/code&gt; to be used with &lt;em&gt;Roslyn Source Generators&lt;/em&gt;, the code generation functionality can be leveraged outside of this process to just generate a string representation of C# code.&lt;/p&gt;
&lt;p&gt;When creating a &lt;em&gt;Roslyn Source Generators&lt;/em&gt; in most cases, before source code is generated, &lt;em&gt;qualification checks&lt;/em&gt; need to be performed to determine &lt;em&gt;if&lt;/em&gt; the source code should be generated, and to determine the values to be used in the generated code. Here the aim of the &lt;code&gt;Source Generator Toolkit&lt;/code&gt; was to make working the the syntax nodes and syntax tree as easy as possible, by &lt;code&gt;providing a variety of extension methods for qualification checks performed on syntax nodes&lt;/code&gt;. The qualification check functionality is done, again, through a &lt;em&gt;fluent builder&lt;/em&gt; which allows for the qualification check to logically be built up - easily to maintain and easier to understand.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generating-code-outside-of-the-roslyn-source-generator-process"&gt;Generating Code - outside of the Roslyn Source Generator process&lt;/h2&gt;
&lt;p&gt;First we'll look at how to generate c# source code, outside of the Roslyn Source Generator process.&lt;/p&gt;
&lt;p&gt;The static &lt;code&gt;SourceGenerator&lt;/code&gt; class is the starting point for building up the source code. No actual &lt;em&gt;true c# code&lt;/em&gt; is generated here - just a &lt;strong&gt;formatted string representation of c# code&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var strCode = SourceGenerator.GenerateSource(gen =&amp;gt;
{
    gen.WithFile(&amp;quot;file1&amp;quot;, file =&amp;gt;
    {
        file.WithNamespace(&amp;quot;SampleNamespace&amp;quot;, ns =&amp;gt;
        {
            ns.WithClass(&amp;quot;SampleClass&amp;quot;, cls =&amp;gt; { });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The string output of the above being (the value of &lt;code&gt;strCode&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace SampleNamespace
{
    [System.CodeDom.Compiler.GeneratedCode(&amp;quot;SourceGeneratorToolkit&amp;quot;, &amp;quot;0.0.0.1&amp;quot;)]
    class SampleClass
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see from this simple example, defining the code is easy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start with a &amp;quot;file&amp;quot; (in this case, it is an &amp;quot;in-memory&amp;quot; file which will hold the defined c# code)&lt;/li&gt;
&lt;li&gt;the file contains a single &lt;code&gt;namespace&lt;/code&gt;, &lt;em&gt;SampleNamespace&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;the namespace contains a single &lt;code&gt;class&lt;/code&gt;, &lt;em&gt;SampleClass&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each component is defined with its required properties (such as name in the above examples), and then an optional builder Action to define its child components.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generating-code-roslyn-source-generator-process-without-isyntaxreceiver"&gt;Generating Code - Roslyn Source Generator process (without ISyntaxReceiver)&lt;/h2&gt;
&lt;p&gt;Next, we look at leveraging the &lt;code&gt;Source Generator Toolkit&lt;/code&gt; as &lt;em&gt;part of the Roslyn Source Generator process&lt;/em&gt; - but when the &lt;code&gt;ISyntaxReceiver&lt;/code&gt; is not used. This use case is for the scenarios when the generated source code must always be output and is not reliant on a &lt;em&gt;qualification check&lt;/em&gt; being done.&lt;/p&gt;
&lt;p&gt;When used in conjunction with a Source Generator, the &lt;code&gt;GenerateSource&lt;/code&gt; extension method on the &lt;code&gt;GeneratorExecutionContext&lt;/code&gt; class can be leveraged.&lt;/p&gt;
&lt;p&gt;The below example shows how to generate source code &lt;code&gt;without any information from a SyntaxReceiver&lt;/code&gt; - see further down on how the &lt;code&gt;Source Generator Toolkit&lt;/code&gt; can be used to generate code in conjunction with a &lt;code&gt;ISyntaxReceiver&lt;/code&gt; implementation.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// a ISourceGenerator implementation
public class SampleGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        context.GenerateSource(&amp;quot;file1&amp;quot;, fileBuilder =&amp;gt;
        {
            fileBuilder.WithNamespace(&amp;quot;SampleNamespace&amp;quot;, nsBuilder =&amp;gt;
            {
                ns.WithClass(&amp;quot;SampleClass&amp;quot;, cls =&amp;gt; { });
            });
        });
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // no ISyntaxReceiver implementation registered here
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the case of a Source Generator, an actual file named &lt;code&gt;file1.cs&lt;/code&gt; will be output as part of the generation process.&lt;/p&gt;
&lt;p&gt;The output content of the file will be the same as in the previous example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace SampleNamespace
{
    [System.CodeDom.Compiler.GeneratedCode(&amp;quot;SourceGeneratorToolkit&amp;quot;, &amp;quot;0.0.0.1&amp;quot;)]
    class SampleClass
    {
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;fluent builder pattern&lt;/em&gt; is leveraged to build up the source code in exactly the same manner as in the previous example above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="generating-code-configuration"&gt;Generating Code - Configuration&lt;/h2&gt;
&lt;p&gt;There is optional configuration which can be specified when generating the code using either of the above two methods (when calling the &lt;code&gt;GenerateSource&lt;/code&gt; method). If no configuration is specified, the default configuration is used.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Configuration Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Default Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OutputGeneratedCodeAttribute&lt;/td&gt;
&lt;td&gt;Flag to indicate if the &lt;code&gt;System.CodeDom.Compiler.GeneratedCode&lt;/code&gt; attribute should be output with generated code. This attribute is used as an indicator to various tools that the code was auto generated&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OutputDebuggerStepThroughAttribute&lt;/td&gt;
&lt;td&gt;Flag to indicate if the &lt;code&gt;System.Diagnostics.DebuggerStepThrough&lt;/code&gt; attribute should be output with generated code. When set to true, this attribute allows stepping into the generated code when debugging&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="code-qualification-roslyn-source-generator-process-with-isyntaxreceiver-implementation"&gt;Code Qualification - Roslyn Source Generator process (with ISyntaxReceiver implementation)&lt;/h2&gt;
&lt;p&gt;When using the .NET Roslyn Source Generator process, the actual &lt;em&gt;generation&lt;/em&gt; of the source is only one step of the process - the other step is determining &lt;em&gt;if the source should be generated in the first place&lt;/em&gt;. This &lt;em&gt;qualification check&lt;/em&gt; is done in the &lt;code&gt;OnVisitSyntaxNode&lt;/code&gt; method of the &lt;code&gt;ISyntaxReceiver&lt;/code&gt; implementation.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;OnVisitSyntaxNode&lt;/code&gt; method takes a &lt;code&gt;SyntaxNode&lt;/code&gt; as an argument (this is part of the normal Roslyn Source Generator process) - the &lt;code&gt;Source Generator Toolkit&lt;/code&gt; provides an extension method (&lt;code&gt;NodeQualifiesWhen&lt;/code&gt;) which accepts a &lt;em&gt;qualification builder&lt;/em&gt; which is used to determine if the SyntaxNode qualifies to have source code generated.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;fluent builder&lt;/em&gt; pattern is again used to build up the qualification check for for the syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class SampleClassSyntaxReceiver : ISyntaxReceiver
{
    public List&amp;lt;SyntaxReceiverResult&amp;gt; Results { get; set; } = new List&amp;lt;SyntaxReceiverResult&amp;gt;();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        syntaxNode.NodeQualifiesWhen(Results, node =&amp;gt;
        {
            node.IsClass(c =&amp;gt; c
                .WithName(&amp;quot;SampleClass&amp;quot;)
                .IsNotStatic()
                .IsPublic()
                .Implements(&amp;quot;ISerializable&amp;quot;)
            );
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, if the qualification checks determines the node is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a class named &lt;code&gt;SampleClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;which is public&lt;/li&gt;
&lt;li&gt;and not static&lt;/li&gt;
&lt;li&gt;and also implements &lt;code&gt;ISerializable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;then the specific &lt;code&gt;SyntaxNode&lt;/code&gt; qualifies, and the &lt;em&gt;Results&lt;/em&gt; list will be populated and passed to the &lt;em&gt;Execute&lt;/em&gt; method of the generator.&lt;/p&gt;
&lt;p&gt;A most complex, but &lt;em&gt;less practical&lt;/em&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;syntaxNode.NodeQualifiesWhen(Results, node =&amp;gt;
{
    node.IsClass(c =&amp;gt; c
        .WithName(&amp;quot;SampleClass&amp;quot;)
        .IsNotStatic()
        .IsNotPrivateProtected()
        .IsPublic()
        .Implements(&amp;quot;ISerializable&amp;quot;)
        // the class must have the Obsolete attribute 
        .WithAttribute(a =&amp;gt;
        {
            a.WithName(&amp;quot;Obsolete&amp;quot;);
        })
        .WithMethod(m =&amp;gt;
        {
            // the class must have a method called &amp;quot;SampleMethod&amp;quot;
            m.WithName(&amp;quot;SampleMethod&amp;quot;)
            // which is async
            .IsAsync()
            // with the Obsolete attribute with a parameter in position 1 supplied
            .WithAttribute(a =&amp;gt;
            {
                a.WithName(&amp;quot;Obsolete&amp;quot;)
                .WithArgument(arg =&amp;gt;
                {
                    arg.WithPosition(1);
                });
            })
            // method must have a return type of Task
            .WithReturnType(typeof(Task));
        })
    );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="code-generation-roslyn-source-generator-process-with-isyntaxreceiver-implementation"&gt;Code Generation - Roslyn Source Generator process (with ISyntaxReceiver implementation)&lt;/h2&gt;
&lt;p&gt;When generating code based on the output of the &lt;em&gt;qualification process&lt;/em&gt; (&lt;code&gt;OnVisitSyntaxNode&lt;/code&gt; method in the &lt;code&gt;ISyntaxReceiver&lt;/code&gt; implementation, shown above), the &lt;code&gt;Results&lt;/code&gt; list is populated with the qualifying &lt;code&gt;SyntaxNode(s)&lt;/code&gt;, and passed to the &lt;code&gt;Execute&lt;/code&gt; method of the &lt;code&gt;ISourceGenerator&lt;/code&gt; implementation.&lt;/p&gt;
&lt;p&gt;Using the same &lt;code&gt;ISyntaxReceiver&lt;/code&gt; implementation as above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class SampleClassSyntaxReceiver : ISyntaxReceiver
{
    public List&amp;lt;SyntaxReceiverResult&amp;gt; Results { get; set; } = new List&amp;lt;SyntaxReceiverResult&amp;gt;();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        syntaxNode.NodeQualifiesWhen(Results, node =&amp;gt;
        {
            node.IsClass(c =&amp;gt; c
                .WithName(&amp;quot;SampleClass&amp;quot;)
                .IsNotStatic()
                .IsPublic()
                .Implements(&amp;quot;ISerializable&amp;quot;)
            );
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each qualifying node, the &lt;code&gt;Results&lt;/code&gt; property is populated with the qualifying &lt;code&gt;SyntaxNode&lt;/code&gt; in question.&lt;/p&gt;
&lt;p&gt;Below is a sample of a &lt;code&gt;ISourceGenerator&lt;/code&gt; which used the &lt;em&gt;Results&lt;/em&gt; output from the &lt;code&gt;OnVisitSyntaxNode&lt;/code&gt; method to generate source code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Generator]
public class PartialMethodGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register our custom syntax receiver
        context.RegisterForSyntaxNotifications(() =&amp;gt; new PartialClassSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver == null)
        {
            return;
        }

        PartialClassSyntaxReceiver syntaxReceiver = (PartialClassSyntaxReceiver)context.SyntaxReceiver;

        if (syntaxReceiver != null &amp;amp;&amp;amp; syntaxReceiver.Results != null &amp;amp;&amp;amp; syntaxReceiver.Results.Any())
        {
            foreach (SyntaxReceiverResult result in syntaxReceiver.Results)
            {
                // based on the qualification process
                // we know the qualifying node will be a class
                ClassDeclarationSyntax cls = result.Node.AsClass();

                context.GenerateSource($&amp;quot;{cls.GetNamespace()}_file&amp;quot;, fileBuilder =&amp;gt;
                {
                    fileBuilder.WithNamespace($&amp;quot;{cls.GetNamespace()}&amp;quot;, nsBuilder =&amp;gt;
                    {
                        nsBuilder.WithClass($&amp;quot;{cls.GetName()}_generated&amp;quot;, clsBuilder =&amp;gt;
                        {
                            clsBuilder.AsPublic();

                            clsBuilder.WithMethod(&amp;quot;Hello&amp;quot;, &amp;quot;void&amp;quot;, mthBuilder =&amp;gt;
                            {
                                mthBuilder.AsPublic()
                                .WithBody(&amp;#64;&amp;quot;Console.WriteLine($&amp;quot;&amp;quot;Generator says: Hello&amp;quot;&amp;quot;);&amp;quot;);
                            });
                        });
                    });
                });
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Initialize&lt;/code&gt; method is used to register the custom &lt;code&gt;ISyntaxReceiver&lt;/code&gt; implementation containing the qualification rules - this is part of the normal Roslyn source generation processes (not specific to the &lt;code&gt;Source Generator Toolkit&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;GeneratorExecutionContext&lt;/code&gt; parameter passed to the &lt;code&gt;Execute&lt;/code&gt; method contains a &lt;em&gt;ISyntaxReceiver&lt;/em&gt; implementation property - &lt;code&gt;PartialClassSyntaxReceiver&lt;/code&gt; in this example, which contains the &lt;em&gt;Results&lt;/em&gt; property with the qualifying SyntaxNode(s). A number of checks are performed to ensure the &lt;em&gt;SyntaxReceiver&lt;/em&gt; is not null, and that the &lt;em&gt;Results&lt;/em&gt; property on it is not null.&lt;/li&gt;
&lt;li&gt;The code then iterates over each &lt;code&gt;SyntaxReceiverResult&lt;/code&gt; in the &lt;em&gt;Results&lt;/em&gt; property. In other words, &lt;em&gt;iterating through each qualifying node&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;AsClass&lt;/code&gt; extension method (part of the &lt;code&gt;Source Generator Toolkit&lt;/code&gt;) will convert the generic SyntaxNode to the specific syntax type ('ClassDeclarationSyntax' in this example)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;GenerateSource&lt;/code&gt; extension method (again, part of the &lt;code&gt;Source Generator Toolkit&lt;/code&gt;) then allows for the building up of the required source code as described above. However, now, instead of explicitly supplying the values for the code (the &lt;em&gt;file name&lt;/em&gt;,  &lt;em&gt;namespace&lt;/em&gt; and &lt;em&gt;class name&lt;/em&gt; in this example), the provided extension methods are used to extract the values from the qualifying syntax node.&lt;/li&gt;
&lt;li&gt;In this example, the &lt;code&gt;GetNamespace&lt;/code&gt; and &lt;code&gt;GetName&lt;/code&gt; extension methods on &lt;code&gt;ClassDeclarationSyntax&lt;/code&gt; are used to get the relevent details from the syntax to populate the generated source code&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="custom-syntax-qualifiers"&gt;Custom syntax qualifiers&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Source Generator Toolkit&lt;/code&gt; allows for custom qualification checks using the &lt;code&gt;WithQualifyingCheck&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;syntaxNode.NodeQualifiesWhen(Results, node =&amp;gt;
{
    node.WithQualifyingCheck(customNode =&amp;gt;
    {
        // completely un-useful check
        return customNode.ChildNodes().Count() == 10;
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here instead of checking if the node is a &lt;em&gt;class or attribute&lt;/em&gt; for example, the qualification check is to see if the node contains 10 child nodes (a not very useful check)&lt;/p&gt;
&lt;h2 id="future-enhancements"&gt;Future enhancements&lt;/h2&gt;
&lt;p&gt;The library is a work in progress, with common source generator functionality added initially, but with more to come over time.  Some future enhancements include (but not limited to):&lt;/p&gt;
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" /&gt; SyntaxNode &lt;code&gt;AsAttribute&lt;/code&gt; extension method&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" /&gt; Additional extension methods to be used on &lt;em&gt;ClassDeclarationSyntax&lt;/em&gt; and &lt;em&gt;AttributeDeclarationSyntax&lt;/em&gt; to be leverage when doing code generation in a source generator&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" /&gt; Ability to determine qualification with generics and generic types&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" /&gt; Ability to determine qualification based on a code comment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feel free to log a request or bug if you have a specific requirement and I'll try to implement asap.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="useful-links"&gt;Useful links&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.nuget.org/packages/SourceGeneratorToolkit"&gt;Source Generator Toolkit&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/JoanComasFdz/dotnet-how-to-debug-source-generator-vs2022"&gt;Debugging a source generator&lt;/a&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Sharing a common method across classes</title>
			<link>https://alwaysdeveloping.net/p/2023-05-interface-extension</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/p/2023-05-interface-extension</guid>
			<pubDate>Fri, 26 May 2023 03:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Have you needed to add the same method to multiple classes? To have a single method in the code applied to multiple classes, instead of duplicating the code in multiple places?&lt;/p&gt;
&lt;p&gt;This article will detail a technique (which I have personally been using extensively) which &lt;code&gt;allows for a single extension method to easily be added to any class&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="inheritance"&gt;Inheritance&lt;/h2&gt;
&lt;p&gt;Before getting to the extension method technique, we are going to have a quick look at using inherence to solve the problem. A common method in a base class can be used to add the functionality to child classes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// BaseClass which has common functionality
public class BaseClass
{
    public BaseClass ExecuteBaseFunctionality()
    {
        Console.WriteLine(&amp;quot;Executing Common functionality&amp;quot;);
        return this;
    }
}

// Class1 which can execute Class1 specific functionality
// as well as the common functionality
public class Class1 : BaseClass
{
    public Class1 ExecuteClass1Functionality()
    {
        Console.WriteLine(&amp;quot;Executing Class1 functionality&amp;quot;);
        return this;
    }
}

// Class2 which can execute Class2 specific functionality
// as well as the common functionality
public class Class2 : BaseClass
{
    public Class2 ExecuteClass2Functionality()
    {
        Console.WriteLine(&amp;quot;Executing Class2 functionality&amp;quot;);
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason for returning the &lt;strong&gt;class type&lt;/strong&gt; from the methods, is to allow for &lt;strong&gt;method chaining&lt;/strong&gt; to take place:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Class1 c1 = new Class1();

c1.ExecuteClass1Functionality()
    .ExecuteBaseFunctionality();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if the common functionality (a call to the base class method) is required to be executed first, then a cast is required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Class1 c1 = new Class1();

((Class1)c1.ExecuteBaseFunctionality())
            .ExecuteBaseFunctionality();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not ideal, but also not a big issue.&lt;/p&gt;
&lt;p&gt;One big limitation of the inheritance approach is that if the class (&lt;code&gt;Class1&lt;/code&gt; or &lt;code&gt;Class2&lt;/code&gt; in this example) already inherits from another class, then the inheritance method simple will not work as C# does not allow for multiple inheritance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Already inherits, cannot inherit from &amp;quot;BaseClass&amp;quot;
public class Class1 : AnotherBaseClass
{
    public Class1 ExecuteClass1Functionality()
    {
        Console.WriteLine(&amp;quot;Executing Class1 functionality&amp;quot;);
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Interfaces combined with extension methods&lt;/code&gt; to the rescue!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="interfaces-extension-methods"&gt;Interfaces + Extension Methods&lt;/h2&gt;
&lt;p&gt;This technique may seem a bit complicated initially, and once the foundations have been setup it is incredibly easy and quick to add the common method to any class.&lt;/p&gt;
&lt;h3 id="defining-the-interface"&gt;Defining the interface&lt;/h3&gt;
&lt;p&gt;The first step is to define a &lt;code&gt;marker interface&lt;/code&gt; which will be used as the base for the extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IHasCommonFunctionality&amp;lt;TParent&amp;gt; 
    where TParent : class
{    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interface uses a &lt;em&gt;generic parameter&lt;/em&gt; to indicate the parent type - this is so the specific type can be returned from the extension methods to &lt;em&gt;enable method chaining&lt;/em&gt; (shown further down in the post). If method chaining is not required, the generic parameter can be removed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IHasCommonFunctionality
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="defining-the-extension-method"&gt;Defining the extension method&lt;/h3&gt;
&lt;p&gt;The next step, is to define an extension method, which &lt;code&gt;extends the functionality of the interface&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class BaseFunctionalityExtensions
{
    // Extension method on IHasCommonFunctionality with a specific generic type parameter
    public static TParent ExecuteBaseFunctionality&amp;lt;TParent&amp;gt;(this IHasCommonFunctionality&amp;lt;TParent&amp;gt; parent)
        where TParent : class
    {
        Console.WriteLine(&amp;quot;Executing Common functionality&amp;quot;);

        // returns the parent, cast to the actual parent type
        return (TParent)parent;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first glace, there is a lot going on - but broken down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is an extension method on the &lt;code&gt;IHasCommonFunctionality&amp;lt;&amp;gt;&lt;/code&gt; interface. Any class which implements this interface, will have the &lt;code&gt;ExecuteBaseFunctionality&lt;/code&gt; method available&lt;/li&gt;
&lt;li&gt;The method uses the generic parameter &lt;code&gt;TParent&lt;/code&gt; - this is the same parameter used when implementing the interface on a class, &lt;code&gt;IHasCommonFunctionality&amp;lt;TParent&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The method returns the generic parameter type (allowing for &lt;em&gt;method chaining&lt;/em&gt;). As the returned &lt;em&gt;parent&lt;/em&gt; variable is of type &lt;code&gt;IHasCommonFunctionality&amp;lt;TParent&amp;gt;&lt;/code&gt;, and we want to return &lt;code&gt;TParent&lt;/code&gt;, &lt;em&gt;parent&lt;/em&gt; is cast to &lt;code&gt;TParent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The above cast will &lt;em&gt;always be valid&lt;/em&gt; as the type represented by &lt;code&gt;TParent&lt;/code&gt;, will always implement &lt;code&gt;IHasCommonFunctionality&amp;lt;TParent&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A practical example might make it easier to see how the pieces fit together.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="interface-implementation"&gt;Interface implementation&lt;/h3&gt;
&lt;p&gt;The interface can now me implemented on one or many classes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Class1 : IHasCommonFunctionality&amp;lt;Class1&amp;gt;
{
    public Class1 ExecuteClass1Functionality()
    {
        Console.WriteLine(&amp;quot;Executing Class1 functionality&amp;quot;);
        return this;
    }
}

public class Class2 : IHasCommonFunctionality&amp;lt;Class2&amp;gt;
{
    public Class2 ExecuteClass2Functionality()
    {
        Console.WriteLine(&amp;quot;Executing Class2 functionality&amp;quot;);
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the generic parameter for &lt;code&gt;IHasCommonFunctionality&amp;lt;&amp;gt;&lt;/code&gt; is the &lt;em&gt;class the interface is being implemented on&lt;/em&gt;. This gives the extension method visibility of the type that is leveraging the interface.&lt;/p&gt;
&lt;p&gt;The extension method can now be leveraged from multiple classes::&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Class1 c1 = new Class1();

// ExecuteBaseFunctionality called on Class1, and the 
// Class1 instance is returned allowing 
// ExecuteClass1Functionality to be called
c1.ExecuteBaseFunctionality()
    .ExecuteClass1Functionality();

//-----------

Class2 c2 = new Class2();

// ExecuteBaseFunctionality called on Class2, and the 
// Class2 instance is returned allowing 
// ExecuteClass2Functionality to be called
c2.ExecuteBaseFunctionality()
    .ExecuteClass2Functionality();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the two example above, calling &lt;code&gt;ExecuteBaseFunctionality&lt;/code&gt; on an instance of &lt;code&gt;Class1&lt;/code&gt; returns the &lt;em&gt;Class1 instance&lt;/em&gt; will calling the method on &lt;code&gt;Class2&lt;/code&gt; returns the &lt;em&gt;Class2 instance&lt;/em&gt;, allowing method chaining to still be possible.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;When it's not possible to use inheritance to share a common method across multiple classes, the &lt;code&gt;interface + extension method&lt;/code&gt; technique can prove to be very valuable. Once the ground work has been done, introducing the method to a class is as simple as having the class implement the required interface. In addition, as multiple interface implementations are allowed its possible add different extension methods to different classes independently (not possible with the inheritance technique)&lt;/p&gt;
&lt;p&gt;I'm interested to know if this same problem has been solved in any other ways - please comment below with any additional techniques to leverage to solve the problem.&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Daily Drop wrap-up</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/02/01-daily-drop-wrap</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/02/01-daily-drop-wrap</guid>
			<pubDate>Wed, 01 Feb 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;At the start of 2022 I set myself the goal of &lt;code&gt;learning one new coding related piece of knowledge a day&lt;/code&gt;. It could be anything - some.NET / C# functionality I wasn't aware of, a design practice, a cool new coding technique, or just something I find interesting. It could be something I knew at one point but had forgotten, or something completely new, which I may or may never actually use.&lt;/p&gt;
&lt;p&gt;The Daily Drop was &lt;code&gt;started in February 2022&lt;/code&gt; as a record of these pieces of knowledge - writing about and summarizing them helped re-enforce the information for myself, as well as potentially helps others learn something new as well.&lt;/p&gt;
&lt;p&gt;One year, and 246 Daily Drops later (only week days, and 2 weeks off during December) the Daily Drop goal &lt;code&gt;is completed!&lt;/code&gt;. This post serves as a &lt;em&gt;wrap-up, as well as to highlight lessons learnt during the year&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="observations"&gt;Observations&lt;/h2&gt;
&lt;h3 id="forgotten-knowledge"&gt;Forgotten knowledge&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Use the knowledge learnt - or forget it&lt;/code&gt;. There are obviously exceptions to this, but for most developers unless we actively use a technique, method, syntax often, it needs to be looked-up each time. I am no exception to this. A number of the pieces of knowledge learnt throughout the year, was knowledge I had previous learn (sometime in the past 20 years), but was not actively using, and had thus &amp;quot;forgotten&amp;quot;. Reading about it again as part of the Daily Drop exercise just refreshed them memory and reminded me that I had actually previous learnt it.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="source-of-knowledge"&gt;Source of knowledge&lt;/h3&gt;
&lt;p&gt;Finding good sources of knowledge, which offer a mix between new C# features, and leveraging existing features is tough (but doable), but key. Two of my favorite sources (which are updated in the morning and afternoon CAT respectively) are &lt;a href="https://blog.cwa.me.uk/"&gt;The Morning Brew&lt;/a&gt; and the &lt;a href="https://www.alvinashcraft.com/"&gt;The Morning Dew&lt;/a&gt;. Both of these are aggregators for various Developer news.&lt;/p&gt;
&lt;p&gt;Other sources include, but not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Twitter .NET Community&lt;/li&gt;
&lt;li&gt;Youtube: &lt;a href="https://www.youtube.com/&amp;#64;nickchapsas"&gt;Nick Chapsas&lt;/a&gt;, &lt;a href="https://www.youtube.com/&amp;#64;RawCoding"&gt;Raw Coding&lt;/a&gt;, &lt;a href="https://www.youtube.com/&amp;#64;CodingTutorialsAreGo"&gt;Coding Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github repos&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="technical-writing-is-a-skill"&gt;Technical writing is a skill&lt;/h3&gt;
&lt;p&gt;Technical writing is a skill and takes times. Writing working coding samples is relatively quick - translating that into readable, understandable but concise and interesting posts is tough, and is time consuming. I feel most of the time I got this mostly right, but not always. However, as with most skills, practice over time improved my ability to write technical specifications, and this has carried over into my professional job.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="going-forward"&gt;Going forward&lt;/h2&gt;
&lt;p&gt;Do I feel like I gained skills and knowledge from Daily Drop? Yes!
Did I, overall, enjoy doing the Daily Drop? Yes!
Am I glad the year log goal has come to an end? Yes!&lt;/p&gt;
&lt;p&gt;Writing a blog post daily is time consuming and at times was very draining. So, while the daily posts will stop, they will be replaced by less frequent but more comprehensive posts. The additional time not blogging, will be dedicated to new side projects and implementation of new ideas.&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>EF queries on unmapped types</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/31-ef-unmapped-types</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/31-ef-unmapped-types</guid>
			<pubDate>Tue, 31 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework 8 is (&lt;em&gt;potentially&lt;/em&gt;) introducing new functionality allowing &lt;code&gt;raw queries to be executed on unmapped types&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At the time of this post, the functionality is only available on the &lt;a href="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8/nuget/v3/index.json"&gt;daily builds&lt;/a&gt;, and may change before the EF8 release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sqlquery-example"&gt;SqlQuery Example&lt;/h2&gt;
&lt;p&gt;Making use of the new functionality is fairly straight-forward. To use the new functionality, we need a &lt;code&gt;type&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class Blog
{
    public int Id { get; set; }

    [MaxLength(500)]
    public string Title { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;DbContext&lt;/code&gt; is also required:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DemoContext() : base()
    {
    }

    public DemoContext(DbContextOptions&amp;lt;DemoContext&amp;gt; options) : base(options)
    {        
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=Demo;Integrated Security=True;TrustServerCertificate=True&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important thing to note here, is that the &lt;code&gt;Blog type is NOT mapped to a DBSet in the DBContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;With the new functionality, &lt;em&gt;raw SQL queries&lt;/em&gt; can now be executed against the &lt;code&gt;unmapped type&lt;/code&gt; (&lt;em&gt;Blog&lt;/em&gt; in this example):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

// Blog type is not mapped
var blogs = await context.Database.SqlQuery&amp;lt;Blog&amp;gt;(
        &amp;#64;$&amp;quot;SELECT b.Id, b.Title, b.DateCreated
            FROM Blog b&amp;quot;)
    .ToListAsync();

Console.WriteLine($&amp;quot;Blogs returned: {blogs.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same functionality can be leveraged for &lt;em&gt;simple types&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var context = new DemoContext();

var titles = await context.Database.SqlQuery&amp;lt;string&amp;gt;(
        &amp;#64;$&amp;quot;SELECT b.Title
            FROM Blog b&amp;quot;)
    .ToListAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This functionality can also be abstracted to a generic method to make calling it multiple times, for multiple entities easier:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; ExecuteSqlQuery&amp;lt;T&amp;gt;(DbContext context, string query)
{
    return await context.Database.SqlQuery&amp;lt;T&amp;gt;(
            FormattableStringFactory.Create(query)
        ).ToListAsync();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can now be called as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var results = await ExecuteSqlQuery&amp;lt;Blog&amp;gt;(context, 
    &amp;quot;SELECT b.Id, b.Title, b.DateCreated FROM Blog b&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="dynamiccontext"&gt;DynamicContext&lt;/h2&gt;
&lt;p&gt;I have previous written a &lt;a href="https://www.nuget.org/packages/AlwaysDeveloping.EntityFrameworkCore.DynamicContext"&gt;NuGet package called DynamicContext&lt;/a&gt; which effectively provides the same functionality. A detailed &lt;a href="https://www.alwaysdeveloping.net/p/11-2020-dynamic-context/"&gt;blog post is also available&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So will this new EF functionality replace &lt;code&gt;DynamicContext&lt;/code&gt;? Yes, and no.&lt;/p&gt;
&lt;p&gt;For the most part, yes it does replace &lt;code&gt;DynamicContext&lt;/code&gt;. However there is one bit of functionality available in &lt;code&gt;DynamicContext&lt;/code&gt; that is not available with the new functionality - the &lt;code&gt;ability to run queries against anonymous types&lt;/code&gt;. This is possible with &lt;code&gt;DynamicContext&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Declare an example anonymous object with 
// the relevant properties, using default values 
var anon = new { BlogId = 0, Url = &amp;quot;&amp;quot; };

// Invoke the method just using the 
// example object, and not specifying T
var blog = CallWithAnon(anon);

static T CallWithAnon&amp;lt;T&amp;gt;(T example) where T: class
{
    // T is inferred from the example parameter (which is not used in the method, 
    // it is only used for the inference) and can successfully 
    // call into the dynamic runtime context
    using var dynContext = new RuntimeContext&amp;lt;T&amp;gt;();
    return dynContext.Set&amp;lt;T&amp;gt;().FromSqlRaw(&amp;quot;SELECT Id as BlogId, Url FROM Blog&amp;quot;)
        .AsNoTracking().First();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trying the same technique with the new EF functionality results in the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;No suitable constructor was found for entity type '&amp;lt;&amp;gt;f__AnonymousType0&amp;lt;int, string&amp;gt;'. 
he following constructors had parameters that could not be bound to properties of the entity type: 
    Cannot bind 'BlogId', 'Title' in '&amp;lt;&amp;gt;f__AnonymousType0&amp;lt;int, string&amp;gt;(int BlogId, string Title)'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a fairly niche use case though, so for the majority of the time, the &lt;code&gt;new functionally can replace DynamicContext&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the ability to query unmapped entities is required - this new functionality is the way to go (vs custom libraries). I'm happy to see additional &lt;em&gt;required&lt;/em&gt; functionality such as this being introduced into the base EF libraries, removing the reliance on additional libraries.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/d1f069fb-7f6d-4f80-a98f-734755474ae1"&gt;Entity Framework 8: Raw SQL queries on unmapped types&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://twitter.com/ajcvickers/status/1616203415637618688"&gt;Arthur Vickers Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;246: 31-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ArrayPool for frequent array creation</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/30-araypool</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/30-araypool</guid>
			<pubDate>Mon, 30 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;In situations where &lt;em&gt;arrays are created and destroyed frequently&lt;/em&gt;, using the &lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; class to &lt;em&gt;rent and return&lt;/em&gt; memory buffers, instead of initializing an array, can lead to improved performance and less pressure on the garbage collection process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="array-initialization"&gt;Array initialization&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;usual traditional&lt;/em&gt; way to instantiate an array, is to use the &lt;code&gt;new&lt;/code&gt; keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void UseInitArray(int arrayLength)
{
    ArrayItem[] array = new ArrayItem[arrayLength];

    for (int i = 0; i &amp;lt; arrayLength; i++)
    {
        array[i] = new ArrayItem
        {
            Id = i,
            Name = i.ToString()
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an array of &lt;em&gt;arrayLength&lt;/em&gt; is initialized with &lt;code&gt;ArrayItem[] array = new ArrayItem[arrayLength];&lt;/code&gt;. An &lt;em&gt;ArrayItem&lt;/em&gt; instance is then added to each element of the array.&lt;/p&gt;
&lt;p&gt;When a large number of arrays and created and destroyed frequently, the garbage collector is (comparatively) under pressure, as there are large amounts of memory allocated to the various large arrays which need to be cleaned up.&lt;/p&gt;
&lt;p&gt;This is where the &lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; class plays its part.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="arraypool"&gt;ArrayPool&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; shines because it allows already allocated space to be &lt;code&gt;rented&lt;/code&gt;, before it is returned back to the pool. This eliminates the need for new memory to be allocated, and then cleaned up by the garbage collector:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void UseArrayPool(int arrayLength)
{

    ArrayItem[] array = ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Rent(arrayLength);

    try
    {
        for (int i = 0; i &amp;lt; arrayLength; i++)
        {
            array[i] = new ArrayItem
            {
                Id = i,
                Name = i.ToString()
            };
        }
    }
    finally
    {
        ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Return(array);
    }

    // DO NOT DO THIS
    // array[0] = null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of the &lt;code&gt;new&lt;/code&gt; keyword being used to instantiate the array, a block of memory (of the appropriate size for the array we required) is &lt;code&gt;rented&lt;/code&gt; from the &lt;em&gt;ArrayPool&lt;/em&gt;, using &lt;code&gt;ArrayItem[] array = ArrayPool&amp;lt;ArrayItem&amp;gt;.Shared.Rent(arrayLength);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Once the array (and the memory allocated to it) is no longer required, the memory is &lt;code&gt;returned&lt;/code&gt; to the &lt;em&gt;ArrayPool&lt;/em&gt;, allowing it to be reused in future.&lt;/p&gt;
&lt;p&gt;It is important to &lt;code&gt;not access the array&lt;/code&gt; once the memory has been returned to the pool, as this could cause instability in the application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If an application creates and destroys a large number of array's, then using the &lt;code&gt;ArrayPool&lt;/code&gt; is the way to go. It is not significantly more complicated that manually instantiating the array, and the application could gain an improvement in performance by leveraging the &lt;code&gt;ArrayPool&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/StasYakhnenko/status/1618293902670454786"&gt;Stas Yakhnenko Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;245: 30-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Expression-body constructor</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/27-expression-body-constructor</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/27-expression-body-constructor</guid>
			<pubDate>Fri, 27 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;An &lt;code&gt;expression&lt;/code&gt; can be used as the body of a constructor, providing a more concise (but arguably, more complex) style.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="traditional-constructor"&gt;Traditional constructor&lt;/h2&gt;
&lt;p&gt;Traditionally, the constructor for an entity would have a parameter for each property of the entity and set the property value to the parameter value (or to a default):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; set; }

    public string Name { get; set; }

    public int LengthInSeconds { get; set; }

    // set all property values based on parameters
    public Song(string artist, string name, int lengthInSeconds)
    {
        Artist = artist;
        Name = name;
        LengthInSeconds = lengthInSeconds;
    }

    // set property values based on parameters and
    // default values
    public Song(string artist, string name)
    {
        Artist = artist;
        Name = name;
        LengthInSeconds = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While there is absolutely &lt;em&gt;nothing wrong with this approach&lt;/em&gt;, it is a fair number of lines of code just to set a few properties. A more concise approach, would be to use an &lt;code&gt;expression&lt;/code&gt; for the body of the constructor.&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;h2 id="expression-bodied-constructor"&gt;Expression-bodied constructor&lt;/h2&gt;
&lt;p&gt;The constructors can be rewritten as follows, using expressions for the body of the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; set; }

    public string Name { get; set; }

    public int LengthInSeconds { get; set; }

    // set all property values based on parameters
    public Song(string artist, string name, int lengthInSeconds) =&amp;gt;
        (Artist, Name, LengthInSeconds) = (artist, name, lengthInSeconds);

    // set property values based on parameters and
    // default values
    public Song(string artist, string name) =&amp;gt;
        (Artist, Name, LengthInSeconds) = (artist, name, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a powerful feature of &lt;code&gt;Tuples&lt;/code&gt; is leveraged. A &lt;em&gt;Tuple&lt;/em&gt; created from the values passed into the constructor (or default values), is assigned to a &lt;em&gt;Tuple&lt;/em&gt; created using the properties of the class. This will essentially &lt;code&gt;assign the parameter values to the property values&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Definitely a more concise approach, although if unfamiliar with the syntax and how &lt;em&gt;Tuples&lt;/em&gt; work, can definitely be a more confusing approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If concise, lean and clean code is the goal, then &lt;code&gt;expression-body constructors&lt;/code&gt; is the way to go. As mentioned, the syntax can be more confusing when compared with the traditional approach - especially to those unfamiliar with &lt;em&gt;Tuples&lt;/em&gt; and their properties.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/mjovanovictech/status/1617071212504440832"&gt;Milan Jovanović Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;244: 27-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Calling an async method in a constructor</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/26-async-constructor</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/26-async-constructor</guid>
			<pubDate>Thu, 26 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;As it is &lt;em&gt;not possible to await an async method in a constructor&lt;/em&gt;, if an async method &lt;em&gt;has&lt;/em&gt; to be called, a valid technique is to &lt;code&gt;call the async method in the constructor, but defer the await until later&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-async"&gt;Non async&lt;/h2&gt;
&lt;p&gt;Calling a &lt;code&gt;non async&lt;/code&gt; method in a constructor is straight forward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
	private readonly string _specialData;

    public MyClass()
    {
    	// takes long, not ideal
    	_specialData = ExternalService.GetData();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, an external service is called to get data required for &lt;code&gt;MyClass&lt;/code&gt; to function correctly.&lt;/p&gt;
&lt;p&gt;However, is the scenario when &lt;code&gt;ExternalService.GetData()&lt;/code&gt; is an async method &lt;code&gt;ExternalService.GetDataAsync()&lt;/code&gt; handled?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="async"&gt;Async&lt;/h2&gt;
&lt;h3 id="getresult"&gt;GetResult&lt;/h3&gt;
&lt;p&gt;If the only option to get the require data is via a &lt;em&gt;async method&lt;/em&gt;, simply just calling it in the constructor will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
	private readonly string _specialData;


    public MyClass()
    {
        // Won't work!
        // Return type is Task&amp;lt;string&amp;gt; not string
        // _specialData = ExternalService.GetDataAsync();

        // Won't work!
        // To use await, the method needs to be async
        // but constructors cannot be async
        //_specialData = await ExternalService.GetDataAsync();
    }
    	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One &lt;code&gt;not recommended&lt;/code&gt; option is to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
    private readonly string _specialDataTask;

    public MyClass()
    {
    	_specialData = ExternalService.GetDataAsync().GetAwaiter().GetResult();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.GetAwaiter().GetResult()&lt;/code&gt; is used on the &lt;em&gt;Task&lt;/em&gt; returned from &lt;em&gt;GetDataAsync&lt;/em&gt; - generally not a good idea to use this approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="lazy"&gt;Lazy&lt;/h3&gt;
&lt;p&gt;A better option is to use the &lt;code&gt;lazy initialization approach&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyClass
{
    private readonly Task&amp;lt;string&amp;gt; _specialDataTask;

    public MyClass()
    {
       _specialDataTask = ExternalService.GetDataAsync();
    }

    public async Task DoWorkUsingSpecialDataAsync()
    {
       var _specialData = await _specialDataTask.ConfigureAwait(false);

       // Do the work using _specialData
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The type of the &amp;quot;_specialData&amp;quot; variable was changed from &lt;code&gt;string to Task&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the constructor, the &lt;code&gt;async method is called, but not awaited&lt;/code&gt; - this returns a &lt;em&gt;Task&amp;lt;string&amp;gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;When/if the &amp;quot;_specialData&amp;quot; value is required, then the &lt;em&gt;Task&amp;lt;string&amp;gt;&lt;/em&gt; is awaited to get the actual value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this method, when the constructor is called, the process of getting the special data is initiated, but is not blocking. When it comes time to use the value returned from the process, &lt;code&gt;await&lt;/code&gt; is used to get the value from the &lt;em&gt;Task&lt;/em&gt;. Either the processing is finished and the value will be available immediately, or the process is still ongoing and the value will be returned once the process is completed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Ideally, this scenario should probably be avoided all together - but if it is a requirement, the lazy-initialization technique is great way to solve the problem.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://endjin.com/blog/2023/01/dotnet-csharp-lazy-async-initialization"&gt;Lazy and once-only C# async initialization&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;243: 26-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Case-less Dictionary keys</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/25-dictionary-comparer</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/25-dictionary-comparer</guid>
			<pubDate>Wed, 25 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Dictionary&lt;/code&gt; constructor can take a &lt;code&gt;StringComparer&lt;/code&gt; parameter allowing for retrieving of keys from the dictionary while ignoring the case of the key. This removes the need to perform &lt;em&gt;ToUpper&lt;/em&gt; and &lt;em&gt;ToLower&lt;/em&gt; on the calls involving the key.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="without-stringcomparer"&gt;Without StringComparer&lt;/h2&gt;
&lt;p&gt;Without a &lt;code&gt;StringComparer&lt;/code&gt;, the case of the &lt;em&gt;key added to the dictionary, and the case of the key when performing a lookup, need to match&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Dictionary&amp;lt;string, int&amp;gt;? artistAlbum = new Dictionary&amp;lt;string, int&amp;gt;();

// Call made to .ToLower() to ensure all artist 
// names are in the same standard format
artistAlbum.Add(&amp;quot;Foo Fighters&amp;quot;.ToLower(), 10);
artistAlbum.Add(&amp;quot;John Mayer&amp;quot;.ToLower(), 8);

// check will only return true if using lower case values,
// or specifically calling ToLower
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;)); // false
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;.ToLower())); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;foo fighters&amp;quot;)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;ToLower&lt;/code&gt; is called each time an item is added to the Dictionary. When performing a check to see if the Dictionary contains a key, a match will only be found if the supplied value is all lower case, or if &lt;code&gt;ToLower&lt;/code&gt; is specifically called again. This ensure that the keys are always stored, and then looked-up in a consistent format - lower case in this example.&lt;/p&gt;
&lt;p&gt;However, all the &lt;code&gt;ToLower&lt;/code&gt; (or &lt;code&gt;ToUpper&lt;/code&gt;) calls do have a performance impact, and additionally they have to manually be added everywhere the Dictionary is used. A simpler and better approach is to use a &lt;code&gt;StringComparer&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="with-stringcomparer"&gt;With StringComparer&lt;/h2&gt;
&lt;p&gt;Using the &lt;code&gt;StringComparer&lt;/code&gt; technique is as simple as passing a value into the &lt;code&gt;Dictionary&lt;/code&gt; constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Dictionary&amp;lt;string, int&amp;gt;? artistAlbum = 
        new Dictionary&amp;lt;string, int&amp;gt;(StringComparer.OrdinalIgnoreCase);

artistAlbum.Add(&amp;quot;Foo Fighters&amp;quot;, 10);
artistAlbum.Add(&amp;quot;John Mayer&amp;quot;, 8);

Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo Fighters&amp;quot;)); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;Foo fighters&amp;quot;)); // true
Console.WriteLine(artistAlbum.ContainsKey(&amp;quot;foo fighters&amp;quot;)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;StringComparer.OrdinalIgnoreCase&lt;/code&gt; is supplied to constructor, &lt;code&gt;ToLower&lt;/code&gt; is no longer required when adding or checking the existence of a key. The case is now ignored when doing the comparison - this results in cleaner code, and better overall performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If the &lt;code&gt;Dictionary&lt;/code&gt; could contain keys of various cases (maybe based on user input) then &lt;code&gt;StringComparer&lt;/code&gt; should be used over &lt;em&gt;ToLower&lt;/em&gt; or &lt;em&gt;ToUpper&lt;/em&gt;. There is no overhead to using this approach, and is actually cleaner and more performant.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/dictionary/#pass-in-stringcomparer-to-dictionary"&gt;Pass in StringComparer to Dictionary&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;242: 25-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>LINQ lambda vs method group</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/24-lambda-vs-method</guid>
			<pubDate>Tue, 24 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using an &lt;em&gt;expression&lt;/em&gt; with LINQ, &lt;code&gt;a lambda should be preferred over a method group&lt;/code&gt; as the performance is slightly better. Lambda expressions can be cached by the runtime resulting in the increased performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the below example we'll be filtering a collection of integers, to return only the values which are &lt;em&gt;greater than 100&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Where&lt;/em&gt; method on &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; accepts a &lt;code&gt;Func&amp;lt;int, bool&amp;gt;&lt;/code&gt; - this can be defined as an actual method, or as a lambda method. We'll have a look at each technique, and then compare performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="method-group"&gt;Method group&lt;/h3&gt;
&lt;p&gt;With a collection of integers, to filter using the &lt;em&gt;Where&lt;/em&gt; method with a &lt;code&gt;method group&lt;/code&gt;, a method need to be defined which &lt;em&gt;accepts an int and returns a bool&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// simple method which accepts an int
// and returns true if the value is 
// greater than 100
static bool GreaterThan100(int value)
{
    return value &amp;gt; 100;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can then be used in a &lt;em&gt;Where&lt;/em&gt; method call:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// collection of 100 integers
IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// filter using a method group
IEnumerable&amp;lt;int&amp;gt;? filteredItems = items.Where(GreaterThan100);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="lambda"&gt;Lambda&lt;/h3&gt;
&lt;p&gt;With the &lt;code&gt;lambda technique&lt;/code&gt; the separate defined method is invoked manually with the parameter specified:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt;? items = Enumerable.Range(50, 150);

// &amp;quot;manually&amp;quot; call the method, sending the int value
// &amp;quot;manually&amp;quot; to the method
var filteredItems1 = items.Where(i =&amp;gt; GreaterThan100(i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both techniques will yield the same results, and on the surface look (and are) very similar. However, next let's look at the performance of each technique to see the main difference.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;For the performance benchmarking, the following &lt;em&gt;lambda&lt;/em&gt; and &lt;em&gt;method group&lt;/em&gt; were tested:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class Benchmarks
{
    private IEnumerable&amp;lt;int&amp;gt; items = Enumerable.Range(1, 10000);

    [Benchmark(Baseline = true)]
    public List&amp;lt;int&amp;gt; MethodGroup() =&amp;gt; items.Where(IsDivisibleBy5).ToList();

    [Benchmark]
    public List&amp;lt;int&amp;gt; Lambda() =&amp;gt; items.Where(i =&amp;gt; IsDivisibleBy5(i)).ToList();

    private static bool IsDivisibleBy5(int i) =&amp;gt; i % 5 == 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;a collection of &lt;em&gt;10000 integers&lt;/em&gt; was used&lt;/li&gt;
&lt;li&gt;each item was checked to determine if it was &lt;em&gt;division by 5 or not&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MethodGroup&lt;/td&gt;
&lt;td style="text-align: right;"&gt;75.04 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.483 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.079 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lambda&lt;/td&gt;
&lt;td style="text-align: right;"&gt;66.44 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.306 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.146 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.89&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, we can see that the &lt;code&gt;lambda technique is approx. 10% faster than the method group technique&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The difference between the two methods is this example (10%) may seem fairly significant, but the timescale is in &lt;em&gt;nanoseconds&lt;/em&gt; - a 10% difference at this scale will not be noticeable. However, depending on the collection size and the complexity of the calculation, the difference could be more noticeable.&lt;br /&gt;
In short - for most scenarios using either technique will be fine, however if performance is an issue, or there is a specific bottleneck, then consider explicitly using the lambda technique.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/advanced/lambda_methodgroup/"&gt;Lambda vs method group&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;241: 24-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Task.Delay accuracy</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/23-task-delay</guid>
			<pubDate>Mon, 23 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Task.Delay&lt;/code&gt; relies on the underlying operating system's internal timer, which for most Windows environments, takes about 15ms to resolve. This means that the &lt;em&gt;minimum amount of time that can be accurately used with Task.Delay is approximately 15ms (on Windows)&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="sample"&gt;Sample&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Diagnostics.StopWatch&lt;/code&gt; can be used to benchmark how long a &lt;code&gt;Task.Delay&lt;/code&gt; call actually takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(100);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above, the result (which may vary each execution and per machine):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 110 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the code is specifying a 100ms delay, and actual delay is close to 110ms.&lt;/p&gt;
&lt;p&gt;The same &lt;em&gt;inaccurate&lt;/em&gt; delay is seen when trying to delay for a small precise time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Stopwatch? watch = Stopwatch.StartNew();

await Task.Delay(5);

watch.Stop(); 

Console.WriteLine($&amp;quot;Actual time delayed: {watch.ElapsedMilliseconds} milliseconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Actual time delayed: 19 milliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results may vary, but (in my case) the true delay was never less than 17ms. As mentioned, this is due to the underlying operating system's internal timer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If requiring small precise waiting times, &lt;code&gt;Task.Delay&lt;/code&gt; is not the way to go. In fact there are no &amp;quot;easy&amp;quot; ways to wait for such small precise times - there are ways to do it (which will not be shown here), but they are involved and are often not very performant when it comes to resource usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://linkdotnet.github.io/tips-and-tricks/async_await/#dont-use-taskdelay-for-small-precise-waiting-times"&gt;Don’t use Task.Delay for small precise waiting times&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;240: 23-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>