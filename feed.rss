<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Mon, 29 Aug 2022 05:07:03 GMT</pubDate>
		<lastBuildDate>Mon, 29 Aug 2022 05:07:03 GMT</lastBuildDate>
		<item>
			<title>Namespace-less types</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/29-global-namespace</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/29-global-namespace</guid>
			<pubDate>Mon, 29 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Types in C# &lt;code&gt;do not have to belong to a specific namespace&lt;/code&gt; - it is just standard convention that they do, however this is not a requirement. The &lt;code&gt;global&lt;/code&gt; alias, along with the namespace alias qualifier &lt;code&gt;::&lt;/code&gt; can be used to reference types without a namespace in the event of a &lt;em&gt;naming conflict&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;Consider the following basic example - a simple wrapper class, &lt;em&gt;belonging to a namespace&lt;/em&gt;, which will output a string to the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public class ConsoleWrapper
{
    public static void OutputToConsole(string output)
    {
        Console.WriteLine(output);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usage is straight forward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public class Program
{
    public static void Main()
    {
        ConsoleWrapper.OutputToConsole(
            $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we reference a Nuget package in our project - it just so happens the require functionality is contained in the package, in a class also called &lt;code&gt;ConsoleWrapper&lt;/code&gt;, however, it &lt;code&gt;doesn't contain a namespace&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public  class ConsoleWrapper
{
    public static void Output(string output)
    {
        Console.WriteLine(output);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try reference the new class in our &lt;em&gt;Main&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public static void Main()
{
    // old class in same namespace as Main
    ConsoleWrapper.OutputToConsole(
        $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);

    // new class without a namespace
    ConsoleWrapper.Output(
        $&amp;quot;Written to console by instance of '{nameof(GlobalKeyword.ConsoleWrapper)}'&amp;quot;);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the following compile-time error occurs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'ConsoleWrapper' does not contain a definition for 'Output'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the newly introduced  &lt;em&gt;ConsoleWrapper&lt;/em&gt; has no namespace, we cannot fully qualify it to resolve the conflict. However, as it has no namespace, it gets put into the &lt;code&gt;global namespace&lt;/code&gt; which can be referenced using &lt;code&gt;global::&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace GlobalKeyword;

public static void Main()
{
    // old class in same namespace as Main
    ConsoleWrapper.OutputToConsole(
        $&amp;quot;Written to console by instance of '{nameof(ConsoleWrapper)}'&amp;quot;);

    // new class in no/global namespace
    global::ConsoleWrapper.Output(
        $&amp;quot;Written to console by instance of '{nameof(GlobalKeyword.ConsoleWrapper)}'&amp;quot;);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Problem solved!&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a very rare issue to encounter, as it requires two unlikely scenarios to occur:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A type to not have a namespace&lt;/li&gt;
&lt;li&gt;The type without a namespace to have the same name as another type (either user defined, or reference)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The vast majority of types do have namespaces, so the chances of encountering this issue are small - however, if it is encountered, the &lt;code&gt;global&lt;/code&gt; alias can be used to resolve the conflict.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/namespace-alias-qualifier"&gt;:: operator (C# reference)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;148: 29-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Constructor out parameters</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/26-constructor-out</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/26-constructor-out</guid>
			<pubDate>Fri, 26 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Class constructors can contain &lt;code&gt;out or ref parameters&lt;/code&gt;, and operate just as they would on a normal method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usages"&gt;Usages&lt;/h2&gt;
&lt;p&gt;While not a very common feature to make use of in most code, below we'll look at a few use cases when an &lt;code&gt;out&lt;/code&gt; parameter on a constructor &lt;em&gt;might&lt;/em&gt; be useful. There may definitely be better ways of handling these specific use cases, but using an &lt;code&gt;out&lt;/code&gt; parameter is &lt;em&gt;a way to handle them&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dependent-entity"&gt;Dependent entity&lt;/h3&gt;
&lt;p&gt;Consider the situation when &lt;code&gt;instantiating a class, another class is created at the same time using the same information&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the below example, we have a &lt;code&gt;Product&lt;/code&gt; class to store product information (including the current price) and a &lt;code&gt;ProductPrice&lt;/code&gt; class to store the history of prices for the product.&lt;/p&gt;
&lt;p&gt;When creating a &lt;code&gt;Product&lt;/code&gt; record, &lt;code&gt;ProductPrice&lt;/code&gt; record should be created at the same time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(Guid.NewGuid(), &amp;quot;Green pants&amp;quot;, 99.99m);
var price = new ProductPrice
{
    Id = product1.Id,
    Price = product1.Price
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This could however also be done using an &lt;code&gt;out&lt;/code&gt; parameter. Consider the following &lt;em&gt;constructor&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product(Guid id, string name, decimal price, out ProductPrice productPrice)
{
    Id = id;
    Name = name;
    Price = price;

    productPrice = new ProductPrice 
    { 
        Id = id, 
        Price = price 
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which can then be called as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(Guid.NewGuid(), &amp;quot;Green pants&amp;quot;, 99.99m, out ProductPrice price);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More concise? Yes. A better solution? Debatably.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="generated-information"&gt;Generated information&lt;/h3&gt;
&lt;p&gt;Expanding on the above example, maybe the &lt;code&gt;Id of the Product is generated internally to the class&lt;/code&gt;, in the constructor. An &lt;code&gt;out&lt;/code&gt; parameter could be used to return the instance &lt;em&gt;Id&lt;/em&gt; from the constructor.&lt;/p&gt;
&lt;p&gt;Here the &lt;em&gt;Id&lt;/em&gt; is generated in the constructor, and assigned to the &lt;code&gt;out&lt;/code&gt; parameter as well as the &lt;em&gt;Id&lt;/em&gt; property of thd class itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product(string name, decimal price, out Guid id)
{
    id = Id = Guid.NewGuid();
    Name = name;
    Price = price;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usage of the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var product = new Product(&amp;quot;Green pants&amp;quot;, 99.99m, out Guid productId);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again - more concise than some alternatives? Yes. A better solution? Debatably.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not something I'd ever really considered, or ever required in 20 years of development - however it is an interesting feature. Maybe one day I might have a  a practical use to use it in production code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/MarusykRoman/status/1550995942576476162"&gt;Roman Marusyk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;147: 26-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Delimit an array with ArraySegment</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/25-arraysegment</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/25-arraysegment</guid>
			<pubDate>Thu, 25 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; structure can be used to represent only a portion of a larger array. A few use cases when &lt;code&gt;ArraySegment&lt;/code&gt; is useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when only a portion of a larger array needs to be passed as an argument to a method, &lt;code&gt;ArraySegment&lt;/code&gt; can be used to pass only the require portion of elements&lt;/li&gt;
&lt;li&gt;when wanting to perform operations on the array from multiple threads, &lt;code&gt;ArraySegment&lt;/code&gt; can be used to have each thread operation on a portion of the array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An important aspect of the &lt;code&gt;ArraySegment&lt;/code&gt; is that a &lt;code&gt;new array is not created&lt;/code&gt; - the &lt;code&gt;ArraySegment&lt;/code&gt; structure still points back to the original array.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the following examples, a line from a &lt;code&gt;csv file&lt;/code&gt; is being read into a &lt;code&gt;string array&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var artistCSVLine = &amp;quot;1,John,Mayer,1976,United States,www.johnmayer.com&amp;quot;;
var fullArtistArray = artistCSVLine.Split(&amp;quot;,&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also have a method to output each item in the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void OutputArray(string[] items)
{
    for (var i = 0; i &amp;lt; items.Length; i++)
    {
        Console.WriteLine(items[i]);
    }

    Console.WriteLine(&amp;quot;------&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the method, with the &lt;em&gt;fullArtistArray&lt;/em&gt; array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1
John
Mayer
1976
United States
www.johnmayer.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But suppose in our application we are only interested in the &lt;em&gt;artist Names and year of birth&lt;/em&gt;, how do we output only those values?&lt;/p&gt;
&lt;p&gt;(this example is very simplified for the sample, and not necessarily a production ready way of dealing with CSV records in this manner)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="without-arraysegment"&gt;Without ArraySegment&lt;/h3&gt;
&lt;p&gt;Without leveraging &lt;code&gt;ArraySegment&lt;/code&gt;, there are two common ways (in my experience) to get only a portion of an array:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Creating a separate array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define a new array
var portionArray = new string[3];
// set the values of the new array from the
// values of the original array
portionArray[0] = fullArtistArray[1];
portionArray[1] = fullArtistArray[2];
portionArray[2] = fullArtistArray[3];

// print out only the new array
OutputArray(portionArray);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, an additional array is created in memory and the information duplicated, so will use more memory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Manual checks for specific elements in the array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void OutputArrayPortion(string[] items)
{
    for (var i = 0; i &amp;lt; items.Length; i++)
    {
        // only output items in specific
        // positions in the array
        if (i == 1 || i == 2 || i == 3)
        {
            Console.WriteLine(items[i]);
        }
    }
    Console.WriteLine(&amp;quot;------&amp;quot;);
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the original full array can passed to the method and a manual check is performed to only output items in specific positions in the array. While this does use no additional memory, its not sustainable. If the checks needs to be performed in multiple places in code (when outputting the data, when saving to a database etc) this approach makes the code not very maintainable.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While either of these approaches could still work, a better approach is to leverage the &lt;code&gt;ArraySegment&lt;/code&gt; class.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="with-arraysegment"&gt;With ArraySegment&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; class can be used to represent only a portion (or segment) of the original array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create a segment, from fullArtistArray, starting at position 1
// and include 3 items from the original array
var artistSegment = new ArraySegment&amp;lt;string&amp;gt;(fullArtistArray, 1, 3);
OutputArraySegment(artistSegment);

// ------

public void OutputArraySegment(ArraySegment&amp;lt;string&amp;gt; items)
{
    for (var i = 0; i &amp;lt; items.Count; i++)
    {
        Console.WriteLine(items[i]);
    }
    Console.WriteLine(&amp;quot;------&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;John
Mayer
1976
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned, an important feature of the &lt;code&gt;ArraySegment&lt;/code&gt; is that a &lt;code&gt;new array is not created&lt;/code&gt;, but the class is a &lt;code&gt;structure which points to a segment of the original array&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This can be demonstrated as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var artistCSVLine = &amp;quot;1,John,Mayer,1976,United States,www.johnmayer.com&amp;quot;;
var fullArtistArray = artistCSVLine.Split(&amp;quot;,&amp;quot;);

// create a new array segment
var artistSegment = new ArraySegment&amp;lt;string&amp;gt;(fullArtistArray, 1, 3);

// change the item at index 3 in the ORIGINAL array
fullArtistArray[3] = &amp;quot;1977&amp;quot;;

// print out the array segment
OutputArraySegment(artistSegment);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;John
Mayer
1977
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The year value output is the &lt;code&gt;updated value&lt;/code&gt;, even though it &lt;code&gt;was updated on the original array&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ArraySegment&lt;/code&gt; provides an easy, memory efficient way of working with portions of a larger original array, and should be leveraged whenever possible of the other &lt;em&gt;non-array-segment&lt;/em&gt; techniques mentioned above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.arraysegment-1?view=net-6.0"&gt;ArraySegment Struct&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;146: 25-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Route handler filters in .NET 7</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/24-route-filter</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/24-route-filter</guid>
			<pubDate>Wed, 24 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with .NET 7 (most likely, .NET 7 is still in preview so its not 100% guaranteed to be included), is the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; interface, which allows for &lt;em&gt;intercepting&lt;/em&gt;  requests/response to and from a specific minimal endpoint.&lt;/p&gt;
&lt;p&gt;This enabled &lt;code&gt;cross-cutting concerns to be coded once&lt;/code&gt;, and then applied to the relevent endpoints. They operate &lt;em&gt;similar&lt;/em&gt; to the .NET &lt;code&gt;middleware&lt;/code&gt; but are applied at a specific endpoint level, and not a level higher targeting all routes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iroutehandlerfilter"&gt;IRouteHandlerFilter&lt;/h2&gt;
&lt;h3 id="definition"&gt;Definition&lt;/h3&gt;
&lt;p&gt;First, lets define the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; implementation to later be applied to a minimal api endpoint. In the below example, a router handler filter is defined to measure how long a call to the endpoint takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class RouteLogger : IRouteHandlerFilter
{
    public async ValueTask&amp;lt;object?&amp;gt; InvokeAsync(RouteHandlerInvocationContext context, 
        RouteHandlerFilterDelegate next)
    {
        // record the time before the endpoint (or next filter is called)
        Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
            $&amp;quot;RouteLogger - before endpoint called&amp;quot;);

        var result = await next.Invoke(context);

        // record the time after the endpoint (or next filter is called)
        Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
            $&amp;quot;RouteLogger - after endpoint called&amp;quot;);

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; interface only has one method to implement - &lt;em&gt;InvokeAsync&lt;/em&gt;, which takes two parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteHandlerInvocationContext&lt;/code&gt;:  this contains a reference to the &lt;em&gt;HttpContext&lt;/em&gt;, as well as a list of &lt;em&gt;Arguments&lt;/em&gt; which can be modified to be passed between filters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteHandlerFilterDelegate&lt;/code&gt;: this contains a delegate to the next &lt;em&gt;IRouteHandlerFilter&lt;/em&gt; implementation if multiple have been applied, otherwise it will route to the &lt;em&gt;actual endpoint handler&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the above sample, a message is logged when the method is entered, the &lt;em&gt;next&lt;/em&gt; delegate is invoked, and then a message logged just before the return. If &lt;em&gt;next&lt;/em&gt; is not invoked, the pipeline to the endpoint is &lt;code&gt;short-circuited&lt;/code&gt; and the &lt;code&gt;endpoint handler will never be invoked&lt;/code&gt;. This allows checks or validation to be performed (authentication checks for example), and &lt;em&gt;short-circuit&lt;/em&gt; if the checks fail.&lt;/p&gt;
&lt;h3 id="application"&gt;Application&lt;/h3&gt;
&lt;p&gt;Applying the filter to the endpoint is very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();

app.MapGet(&amp;quot;/endpoint&amp;quot;, () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Endpoint handler&amp;quot;);

    return &amp;quot;Endpoint has been called&amp;quot;;
}).AddFilter&amp;lt;RouteLogger&amp;gt;(); // add the filter

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the endpoint definition, the &lt;em&gt;AddFilter&lt;/em&gt; method is called, with the &lt;code&gt;IRouteHandlerFilter&lt;/code&gt; implementation specified. Multiple implementations can be linked together to form a pipeline to the endpoint handler.&lt;/p&gt;
&lt;?# InfoBlock ?&gt;
&lt;p&gt;The above was written using &lt;strong&gt;.NET 7 Preview 5&lt;/strong&gt;. AddFilter() has been renamed to &lt;em&gt;AddRouteHandlerFilter()&lt;/em&gt; in Preview 6 and will be renamed again to &lt;em&gt;AddEndpointFilter()&lt;/em&gt; starting in Preview 7.&lt;/p&gt;
&lt;?#/ InfoBlock ?&gt;
&lt;hr /&gt;
&lt;h2 id="middleware"&gt;Middleware&lt;/h2&gt;
&lt;p&gt;As mentioned in the introduction, &lt;em&gt;route handler filters&lt;/em&gt; act similar to the middleware. Where &lt;code&gt;route handler filters are applied to specific endpoints&lt;/code&gt;, &lt;code&gt;middleware is applied to requests coming in on any route&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below a middleware function is defined, which also performs logging:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// define the middleware
// The Func defined is called on every 
// request to any endpoints
app.Use(async (context, next) =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Middleware - before endpoint called&amp;quot;);

    await next(context);

    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Middleware - after endpoint called&amp;quot;);
});

app.MapGet(&amp;quot;/endpoint&amp;quot;, () =&amp;gt;
{
    Console.WriteLine($&amp;quot;{DateTime.Now:MM/dd/yyyy hh:mm:ss.fff}: &amp;quot; +
        $&amp;quot;Endpoint handler&amp;quot;);

    return &amp;quot;Endpoint has been called&amp;quot;;
}).AddFilter&amp;lt;RouteLogger&amp;gt;();

app.Run();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The middleware has a similar structure to a &lt;em&gt;route handler filter&lt;/em&gt;, with an &lt;em&gt;HttpContext&lt;/em&gt; and a &lt;em&gt;RequestDelegate&lt;/em&gt; as arguments. The &lt;em&gt;RequestDelegate&lt;/em&gt; argument &lt;code&gt;next&lt;/code&gt; is also invoked, to call the next middleware component, or the endpoint handler. If not called, &lt;em&gt;short-circuiting&lt;/em&gt; will occur, just as with the &lt;em&gt;route handler filter&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the above example, the &lt;code&gt;middleware was defined as a lambda function&lt;/code&gt; while the &lt;code&gt;filter was defined as a concrete IRouteHandlerFilter implementation&lt;/code&gt; - either of these can also be defined the either way. Middleware could be defined as a concrete implementation, and a route handler filter could be defined as a lambda function.&lt;br /&gt;
If there are a number of middleware or route handler filter components being used, it's usually better to use the concrete implementation method to keep the startup code cleaner, and keep all pipeline logic in one place (their own folder, for example).&lt;/p&gt;
&lt;p&gt;Executing the above code and browsing to the &lt;code&gt;/endpoint&lt;/code&gt;, results in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;07/27/2022 08:42:27.851: Middleware - before endpoint called
07/27/2022 08:42:27.859: RouteLogger - before endpoint called
07/27/2022 08:42:27.860: Endpoint handler
07/27/2022 08:42:27.860: RouteLogger - after endpoint called
07/27/2022 08:42:27.865: Middleware - after endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the &lt;code&gt;middleware is called first&lt;/code&gt;, before the http request is passed onto the endpoint specific &lt;code&gt;route handler filter(s)&lt;/code&gt; (if any are defined), before the &lt;code&gt;actual endpoint handler&lt;/code&gt; is called.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, &lt;code&gt;middleware&lt;/code&gt; is applied to all endpoints, so if some middleware logic is only applicable to a certain endpoint(s), then currently filter logic needs to be specific in the middleware to determine if the middleware functionality should be applied to the request or not.
Having the ability to granularly apply &lt;code&gt;route handler filter&lt;/code&gt; &amp;quot;middleware&amp;quot; on specific endpoint(s) allows for greater flexibility and is a welcome addition which brings functionality closer to being on par with that of MVC (which has ActionFilter)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/minimal-api-route-handler-filters"&gt;Minimal API Route Handler Filters&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;145: 24-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Override vs New behavior</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/23-override-new</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/23-override-new</guid>
			<pubDate>Tue, 23 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;polymorphism&lt;/code&gt;, even though on the surface they appear to be doing the same thing, &lt;em&gt;hiding&lt;/em&gt; the functionality of a parent, the &lt;code&gt;override&lt;/code&gt; and &lt;code&gt;new&lt;/code&gt; keywords behave very differently.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Override&lt;/code&gt; will &lt;em&gt;hide&lt;/em&gt; the parent method invoked, and the &lt;em&gt;overridden&lt;/em&gt; method on the child will be called. However when &lt;code&gt;new&lt;/code&gt; is used on a method, when invoked, the &lt;em&gt;parent&lt;/em&gt; method will be called.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="definition-recap"&gt;Definition recap&lt;/h2&gt;
&lt;p&gt;A lot of keywords used in the introduction above, so a quick recap on some of the definitions of the keywords.&lt;/p&gt;
&lt;h3 id="polymorphism"&gt;Polymorphism&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Polymorphism&lt;/code&gt; allows for objects of a &lt;em&gt;derived class&lt;/em&gt; can be treated as objects of the &lt;em&gt;parent class&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, when a &lt;em&gt;Child&lt;/em&gt; class inherits from a &lt;em&gt;Parent&lt;/em&gt; class, then the following is valid:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// defined as type Parent
// but assigned a Child
Parent childEntity = new Child();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="virtual"&gt;Virtual&lt;/h3&gt;
&lt;p&gt;Often the &lt;em&gt;Parent&lt;/em&gt; class will defined methods as &lt;code&gt;virtual&lt;/code&gt; (which can also be applied to properties, indexers), which allows for it to be explicitly overridden in the &lt;em&gt;Child&lt;/em&gt; class.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Parent
{
    public virtual void Hello()
    {
        Console.WriteLine(&amp;quot;Hello, I am Parent&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="override"&gt;Override&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;override&lt;/code&gt; keyword is used on a &lt;em&gt;Child&lt;/em&gt; class, to &lt;code&gt;override&lt;/code&gt; the behavior defined by the &lt;em&gt;Parent&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Child : Parent
{
    // Override the Parent Hello method
    public override void Hello()
    {
        Console.WriteLine(&amp;quot;Hello, I am Child&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="new"&gt;New&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; keyword can be used as a declaration modifier to explicitly &lt;em&gt;hide&lt;/em&gt; the base class functionality:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Child : Parent
{
    // Hide the Parent Hello method
    public new void Hello()
    {
        Console.WriteLine(&amp;quot;Hello, I am Child&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="new-vs-override"&gt;New vs override&lt;/h2&gt;
&lt;p&gt;There is a subtle difference between the definitions of the &lt;code&gt;override&lt;/code&gt; and &lt;code&gt;new&lt;/code&gt; keywords:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt; will &lt;strong&gt;override&lt;/strong&gt; the parent method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; will &lt;strong&gt;hide&lt;/strong&gt; the parent method&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What all this comes down to, is the following - consider a &lt;em&gt;Parent&lt;/em&gt; and two different &lt;em&gt;Child&lt;/em&gt; classes, one using &lt;code&gt;new&lt;/code&gt; and one using &lt;code&gt;override&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Parent
{
    public virtual string Ping()
    {
        return $&amp;quot;Response from {nameof(Parent)}&amp;quot;;
    }
}

public class OverrideChild : Parent
{
    public override string Ping()
    {
        return $&amp;quot;Response from {nameof(OverrideChild)}&amp;quot;;
    }
}

public class NewChild : Parent
{
    public new string Ping()
    {
        return $&amp;quot;Response from {nameof(NewChild)}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we declare an instance of each of the three types and call the &lt;em&gt;Ping&lt;/em&gt; method, we get a response from the method on the respective type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Parent parent = new Parent();
NewChild newChild = new NewChild();
OverrideChild overChild = new OverrideChild();

Console.WriteLine(parent.Ping());
Console.WriteLine(newChild.Ping());
Console.WriteLine(overChild.Ping());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Response from Parent
Response from NewChild
Response from OverrideChild
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, so good - all is as expected.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="polymorphism-1"&gt;Polymorphism&lt;/h3&gt;
&lt;p&gt;However, when using &lt;code&gt;polymorphism&lt;/code&gt; then behavior starts to change.&lt;/p&gt;
&lt;p&gt;In the below, each type is &lt;code&gt;declare of type Parent by assigned one of the three different types&lt;/code&gt; (this is allowed, because of &lt;em&gt;polymorphism&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// all type Parent
// but assigned different types
Parent parent = new Parent();
Parent overChild = new OverrideChild();
Parent newChild = new NewChild();

Console.WriteLine(parent.Ping()); 
Console.WriteLine(overChild.Ping()); 
Console.WriteLine(newChild.Ping()); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Response from Parent
Response from OverrideChild
Response from Parent
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see that with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt;: there is a &lt;em&gt;link&lt;/em&gt; between the child and parent entities, so when the method is called the runtime knows to call the child entity method (even though the type is &lt;em&gt;Parent&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;: the parent method is hidden by the child method, but there is no &lt;em&gt;link&lt;/em&gt; between them, so calling the method on a &lt;em&gt;Parent&lt;/em&gt; entity (even though it was assigned a &lt;em&gt;Child&lt;/em&gt;) will call the parent entity method&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Interesting behavior from the runtime which one should be aware of, otherwise unexpended results might occur. There is no &lt;em&gt;right&lt;/em&gt; or &lt;em&gt;wrong&lt;/em&gt; modifier to use, it will depend on the use case, how the classes are defined and used, and how they should behave.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2022/05/13/override-vs-new-polymorphism-in-c-net/"&gt;Override vs New Polymorphism In C# .NET&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;144: 23-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Unsafe cast for performance</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/22-unsafe-cast</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/22-unsafe-cast</guid>
			<pubDate>Mon, 22 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UnSafe static class&lt;/code&gt; can be used to perform an &lt;code&gt;Unsafe&lt;/code&gt; cast, which can lead to performance improvements - however it is only recommended in instances when a &lt;code&gt;safe cast ((T)o) would have guaranteed to be successful&lt;/code&gt;.  Performing an unsafe cast when a safe cast would have been unsuccessful could result in application instability.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="safe-casting"&gt;Safe casting&lt;/h2&gt;
&lt;p&gt;When performing a &lt;code&gt;safe cast&lt;/code&gt;, runtime safety checks are performed, and if the cast is invalid then an &lt;code&gt;InvalidCastException&lt;/code&gt; will be thrown.&lt;/p&gt;
&lt;p&gt;The below method is a &lt;code&gt;safe cast&lt;/code&gt;, as the runtime will prevent the cast from taking place (and throw the &lt;em&gt;InvalidCastException&lt;/em&gt;) if &lt;em&gt;object o&lt;/em&gt; is not compatible with type Product:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product GetProduct(object o)
{
    return (Product)o;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another approach is to use the &lt;code&gt;is&lt;/code&gt; keyword, which will not thrown the exception, but return &lt;code&gt;false&lt;/code&gt; if the cast is not compatible (and actually perform the cast if it is compatible):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product GetProductIs(object o)
{
    if (o is Product p)
        return p;

    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For almost all use cases, one of the above techniques will be suitable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unsafe-casting"&gt;UnSafe casting&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;static Unsafe class&lt;/code&gt; can be used to perform a cast, but without any of the safety checks being performed. Performing an invalid cast will not lead to the &lt;code&gt;InvalidCastException&lt;/code&gt; being thrown, just to potential system instability.&lt;/p&gt;
&lt;p&gt;Performing an &lt;code&gt;unsafe cast&lt;/code&gt; is almost as simple as performing a &lt;em&gt;safe cast&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Product GetProductUnsafe(object o)
{
    // case object o to Product
    return Unsafe.As&amp;lt;Product&amp;gt;(o);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As no safety checks are performed by the runtime, some performance gains can be achieved by using this approach - but let's test just how big of a gain.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Benchmarking the three different techniques, each with a &lt;code&gt;null value&lt;/code&gt; and with a &lt;code&gt;Product instance&lt;/code&gt; (a valid cast):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;o&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NormalCast&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2752 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0331 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0294 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2763 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CastUsingIs&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.4600 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0369 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0327 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.4688 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.37&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.67&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnsafeCast&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0447 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0428 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0761 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0000 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.16&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NormalCast&lt;/td&gt;
&lt;td&gt;Product&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1189 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0353 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0275 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1164 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CastUsingIs&lt;/td&gt;
&lt;td&gt;Product&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7099 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0511 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0453 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7091 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.290&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnsafeCast&lt;/td&gt;
&lt;td&gt;Product&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0000 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0000 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0000 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0000 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Results may vary depending on the use case, but here, &lt;code&gt;using Unsafe is effectively is free&lt;/code&gt; and takes no time at all.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;Unsafe&lt;/code&gt; is only recommended in the narrow use case where one knows using a &lt;code&gt;safe cast will succeed&lt;/code&gt; - leveraging &lt;code&gt;Unsafe&lt;/code&gt; in this case will result in performance gains.
However, the gain is on the &lt;em&gt;nanoseconds&lt;/em&gt; scale, so is not likely to be noticeable - results may vary depending on the use ase though, and if performing a large number of slow &lt;em&gt;casts&lt;/em&gt;, then potentially a safe &lt;code&gt;Unsafe&lt;/code&gt; cast result in a noticeable difference.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.tabsoverspaces.com/233888-what-is-the-cost-of-casting-in-net-csharp?utm_source=feed/"&gt;What is the cost of casting in .NET (C#)?&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;143: 22-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Filter IEnumerable with OfType</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/19-linq-oftype</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/19-linq-oftype</guid>
			<pubDate>Fri, 19 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;LINQ provides a built in method to filter collection contents &lt;em&gt;by type&lt;/em&gt;, &lt;code&gt;OfType&amp;lt;&amp;gt;&lt;/code&gt;. This is considerably easier and more streamline than the alternative of using a &lt;code&gt;Where&lt;/code&gt; in combination with a &lt;code&gt;Select&lt;/code&gt; (which I had previously been using)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In the below example, the setup is as follows:&lt;/p&gt;
&lt;p&gt;We have three interfaces:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IBaseType {}

public interface ITypeA
{
    void ExecuteTypeAProcessing();
}

public interface ITypeB
{
    void ExecuteTypeBProcessing();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And two classes which implement these interfaces:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// implement the base interface and TypeA interface
public class TypeA : IBaseType, ITypeA
{
    public void ExecuteTypeAProcessing()
    {
        Console.WriteLine($&amp;quot;{nameof(ExecuteTypeAProcessing)} has been called&amp;quot;);
    }
}

// implement the base interface and TypeB interface
public class TypeB : IBaseType, ITypeB
{
    public void ExecuteTypeBProcessing()
    {
        Console.WriteLine($&amp;quot;{nameof(ExecuteTypeBProcessing)} has been called&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A list of &lt;code&gt;IBaseType&lt;/code&gt; has also been initialized, and contains a combination of &lt;em&gt;TypeA&lt;/em&gt; and &lt;em&gt;TypeB&lt;/em&gt; instances (this is possible, as both types implement &lt;em&gt;IBaseType&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;IBaseType&amp;gt; types = new()
{
  new TypeA(),
  new TypeA(),
  new TypeB(),
  new TypeA(),
  new TypeB(),
  new TypeB(),
  new TypeA(),
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="where-with-select"&gt;Where with Select&lt;/h2&gt;
&lt;p&gt;This is the method I've been using prior to knowing there was an alternative. It does work, but is very verbose.&lt;/p&gt;
&lt;p&gt;Suppose we want to execute the &lt;em&gt;ExecuteTypeAProcessing&lt;/em&gt; method on instances of &lt;em&gt;ITypeA&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach(var type in types
    .Where(t =&amp;gt; t is ITypeA)
    .Select(t =&amp;gt; t as ITypeA))
{
    type.ExecuteTypeAProcessing();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another method, this time executing &lt;em&gt;ExecuteTypeBProcessing&lt;/em&gt; on instances of &lt;em&gt;ITypeB&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;types.Where(t =&amp;gt; t is ITypeB)
    .Select(t =&amp;gt; t as ITypeB)
    .ToList()
    .ForEach(t =&amp;gt; t.ExecuteTypeBProcessing());
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="oftype"&gt;OfType&lt;/h2&gt;
&lt;p&gt;Only recently did I come across the &lt;code&gt;OfType&lt;/code&gt; method on &lt;em&gt;IEnumerable&lt;/em&gt; - not that it was hidden in any way, I just never looked for it, as the above &lt;code&gt;Where + Select&lt;/code&gt; method worked for my needs. However &lt;code&gt;OfType&lt;/code&gt; greatly simplifies the above code.&lt;/p&gt;
&lt;p&gt;Executing &lt;em&gt;ExecuteTypeAProcessing&lt;/em&gt; on instances of &lt;em&gt;ITypeA&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach(var type in types.OfType&amp;lt;ITypeA&amp;gt;())
{
    type.ExecuteTypeAProcessing();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing &lt;em&gt;ExecuteTypeBProcessing&lt;/em&gt; on instances of &lt;em&gt;ITypeB&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;types.OfType&amp;lt;ITypeB&amp;gt;()
    .ToList()
    .ForEach(t =&amp;gt; t.ExecuteTypeBProcessing());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Either option is simpler, more concise and more readable than the &lt;em&gt;Where + Select&lt;/em&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Nothing groundbreaking learnt today - but never-the-less something very interesting and useful, which will definitely see frequent usage.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;142: 19-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Combining enum values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/18-enum-bit-flags</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/18-enum-bit-flags</guid>
			<pubDate>Thu, 18 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;bitwise logical operator (|)&lt;/code&gt; can be used to &lt;em&gt;combine enum values&lt;/em&gt; when assigning to a variable, but they can also be used when &lt;code&gt;defining the enum&lt;/code&gt; to create enum values which are a &lt;code&gt;combination of other enum values&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="combine-variable"&gt;Combine variable&lt;/h2&gt;
&lt;p&gt;This is the more common (in my experience) usage of combining enums - assigning enum value(s) to a variable.&lt;/p&gt;
&lt;p&gt;Consider the following enum:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Flags]
enum OrderStatus
{
    New = 1,
    Processing = 2,
    Reserved = 4,
    Paid = 8,
    Delivered = 16,
    Cancelled = 32
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could indicate that an order is &lt;em&gt;Paid&lt;/em&gt; but also been &lt;em&gt;Cancelled&lt;/em&gt; by doing the follow:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;OrderStatus status = OrderStatus.Paid | OrderStatus.Cancelled;

Console.WriteLine($&amp;quot;Is order Paid? {status.HasFlag(OrderStatus.Paid)}&amp;quot;);
Console.WriteLine($&amp;quot;Is order Cancelled? {status.HasFlag(OrderStatus.Cancelled)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Is order Paid? True
Is order Cancelled? True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;bitwise logical operator (|)&lt;/code&gt; can also be used when &lt;code&gt;declaring the enum&lt;/code&gt; to combine statues.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="combine-declaration"&gt;Combine declaration&lt;/h2&gt;
&lt;p&gt;Consider the same enum from above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Flags]
enum OrderStatus
{
    New = 1,
    Processing = 2,
    Reserved = 4,
    Paid = 8,
    Delivered = 16,
    Cancelled = 32
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we wanted two methods to determine if a order is currently &lt;code&gt;Open&lt;/code&gt; (still processing to do) or if it is &lt;code&gt;Closed&lt;/code&gt; (no more processing to do).&lt;/p&gt;
&lt;p&gt;With the enums as they are, something similar to this would need to be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// check all the statuses considered 'open'
bool IsOrderOpen(OrderStatus status) =&amp;gt; status.HasFlag(OrderStatus.New) ||
        status.HasFlag(OrderStatus.Processing) ||
        status.HasFlag(OrderStatus.Reserved) ||
        status.HasFlag(OrderStatus.Paid);

// check all the statuses considered 'closed'
bool IsOrderClosed(OrderStatus status) =&amp;gt; status.HasFlag(OrderStatus.Delivered) ||
        status.HasFlag(OrderStatus.Cancelled);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time a new status is added and the enum changes, the developer would need to remember to come in and update each method as well.&lt;/p&gt;
&lt;p&gt;A cleaner approach, is to &lt;code&gt;define a new status, and use it to combine with other statuses&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider this &lt;code&gt;updated enum&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Flags]
enum OrderStatus
{
    New = 1 | 64,
    Processing = 2 | 64,
    Reserved = 4 | 64,
    Paid = 8 | 64,
    Delivered = 16 | 128,
    Cancelled = 32 | 128,
    Open = 64,
    Closed = 128
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two new statuses, &lt;code&gt;Open&lt;/code&gt; and &lt;code&gt;Closed&lt;/code&gt;, have been defined, with each other status being updated to indicate it as being either &lt;em&gt;Open&lt;/em&gt; or &lt;em&gt;Closed&lt;/em&gt;.
For example &lt;code&gt;Processing = 2 | 64,&lt;/code&gt; effectively means: &lt;code&gt;an order with a status of Processing is Processing but also Open&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To check if an order is &lt;code&gt;Open&lt;/code&gt; or &lt;code&gt;Closed&lt;/code&gt; now, all that is required is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;bool IsOrderOpen(OrderStatus status) =&amp;gt; status.HasFlag(OrderStatus.Open);
bool IsOrderClosed(OrderStatus status) =&amp;gt; status.HasFlag(OrderStatus.Closed);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the status is not set explicitly to 'Open' or 'Closed'
var status = OrderStatus.Reserved;

Console.WriteLine($&amp;quot;Is order open? {IsOrderOpen(status)}&amp;quot;);
Console.WriteLine($&amp;quot;Is order closed? {IsOrderClosed(status)}&amp;quot;);

// just to confirm a check on the original status 
// still works
Console.WriteLine($&amp;quot;Is order reserved? {status.HasFlag(OrderStatus.Reserved)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Is order open? True
Is order closed? False
Is order reserved? True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This version of the code is definitely &lt;code&gt;much cleaner&lt;/code&gt;, and much &lt;code&gt;easier to maintain&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Using the &lt;em&gt;bitwise logical operator (|)&lt;/em&gt; on enum definition is a useful technique I was not aware of. It facilities cleaner code, and makes it easier for the developer to contain enum logic all in one place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/vzph36/enum_bitshifting_syntax_for_multiple_flags_during/"&gt;Enum bit-shifting syntax for multiple flags during enum declaration&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;141: 18-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Parallel processing with ParallelEnumerable </title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/17-parallelenumerable</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/17-parallelenumerable</guid>
			<pubDate>Wed, 17 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Linq has built in parallel functionality, available in the &lt;code&gt;ParallelEnumerable&lt;/code&gt; class.  This functionality is available as &lt;em&gt;extension methods&lt;/em&gt; on &lt;code&gt;ParallelQuery&lt;/code&gt;, which is generated by calling &lt;code&gt;AsParallel&lt;/code&gt; on an &lt;em&gt;IEnumerable&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage of the functionality offered by &lt;code&gt;ParallelEnumerable&lt;/code&gt; is very similar (and for the most part, the same) to normal Linq method usage.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;access&lt;/em&gt; the root of the parallel functionality,&lt;code&gt;ParallelQuery&lt;/code&gt;, all that is required is the &lt;code&gt;AsParallel()&lt;/code&gt; method to be called on an &lt;em&gt;IEnumerable&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;int&amp;gt; array = Enumerable.Range(1, 1000);
ParallelQuery&amp;lt;int&amp;gt; parallelQuery = array.AsParallel();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the ParallelQuery instance, traditional Linq methods can still available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// output: 750,5
int average = parallelQuery
    .Where(i =&amp;gt; i &amp;gt; 500)
    .Average(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there is now also &lt;em&gt;additional methods&lt;/em&gt; available, for example &lt;code&gt;ForAll&lt;/code&gt; which will perform an &lt;em&gt;Action&lt;/em&gt; on each element, but in &lt;strong&gt;parallel&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var outputArray = new int[1000];
parallelQuery.ForAll(i =&amp;gt;
{
    outputArray[i - 1] = i * i;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's benchmark this to see how it performs against other parallel and not parallel operations which achieve the same outcome.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmark"&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;In this set of benchmarks, we are operating on a &lt;em&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/em&gt; with 100 items, and for each item in the source, the &lt;em&gt;PerformCalculation&lt;/em&gt; method will be called:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the source items
IEnumerable&amp;lt;int&amp;gt; array = Enumerable.Range(1, 100);

// the method invoked
void PerformCalculation(int i)
{
    _ = i * i * i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following techniques were benchmarked:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List.ForEach:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForEachList()
{
    array.ToList()
       .ForEach(i =&amp;gt; PerformCalculation(i));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Foreach over an Array:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ForeachOverArray()
{
    foreach (var i in array.ToArray())
    {
        PerformCalculation(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ParallelForEach:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ParallelForEach()
{
    Parallel.ForEach(array, PerformCalculation);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ParallelQuery.ForAll:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void ParallelQueryForAll()
{
    array
    .AsParallel()
    .ForAll(i =&amp;gt; PerformCalculation(i));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ListForEach&lt;/td&gt;
&lt;td style="text-align: right;"&gt;322.85 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.651 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.286 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0825&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;520 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ForeachOverArray&lt;/td&gt;
&lt;td style="text-align: right;"&gt;91.40 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.770 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.656 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.28&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.01&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0675&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;424 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ParallelQueryForAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13,481.85 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;172.827 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;161.663 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;41.77&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.86&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.0599&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0610&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12,585 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ParallelForEach&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7,978.07 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;41.364 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.540 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;24.70&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.43&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.6844&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1068&lt;/td&gt;
&lt;td style="text-align: right;"&gt;24,175 B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;parallel versions are slow&lt;/code&gt; - &lt;strong&gt;VERY&lt;/strong&gt; slow compared to just iterating over the collection of items in sequence.&lt;/p&gt;
&lt;p&gt;Surely doing processing in parallel should make things process quicker overall? Generally yes - in this case however, the actual work being performed (the &lt;em&gt;PerformCalculation&lt;/em&gt; method) is done so quickly, that the &lt;code&gt;overhead of creating and managing the parallel tasks is a detriment to performance&lt;/code&gt; vs just operating on the items in sequence.&lt;/p&gt;
&lt;p&gt;However, what if the work being performed took slightly longer....&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmark-v2"&gt;Benchmark v2&lt;/h2&gt;
&lt;p&gt;We'll run the exact same benchmarks, with the same array size, but now the &lt;em&gt;PerformCalculation&lt;/em&gt; method will &lt;code&gt;take 2ms longer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void PerformCalculation(int i)
{
    _ = i * i * i;
    // simulate a longer 
    // running process
    Thread.Sleep(2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results of round 2:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ListForEach&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,536.90 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.679 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.506 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ForeachOverArray&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,534.54 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.702 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.528 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ParallelQueryForAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;152.84 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.730 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.683 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ParallelForEach&lt;/td&gt;
&lt;td style="text-align: right;"&gt;71.86 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.165 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20.788 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.07&lt;/td&gt;
&lt;td style="text-align: right;"&gt;99 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;parallel versions are now 10-20 times faster!&lt;/code&gt;. The &lt;em&gt;Parallel.ForEach&lt;/em&gt; is &lt;code&gt;twice as fast&lt;/code&gt; as the &lt;em&gt;ParallelEnumerable.ForAll&lt;/em&gt;, but uses &lt;code&gt;7 times the amount of memory&lt;/code&gt; (and both parallel techniques use vastly more memory in comparison to the basic loops)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;There are a number of different techniques to solve a use case such as this - each with its own pros and cons, which would need to be evaluated for each use case. It's important to know about each technique, so a thorough evaluation can be done. Results may vary based on collection size, and process time, but based on the above use case:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Low memory usage&lt;/code&gt; is most important? - use a &lt;em&gt;foreach&lt;/em&gt; loop&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fast throughput&lt;/code&gt; is most important? - use &lt;em&gt;Parallel.ForEach&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Good throughput with good memory&lt;/code&gt; usage? - use &lt;em&gt;ParallelEnumerable.ForAll&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable?view=net-6.0"&gt;ParallelEnumerable Class&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;140: 17-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Pub/Sub with Redis</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/16-redis-pub-sub</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/16-redis-pub-sub</guid>
			<pubDate>Tue, 16 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A common use case for &lt;code&gt;Redis&lt;/code&gt; is as a &lt;em&gt;key-value&lt;/em&gt; stored, generally for caching - however, in addition to this &lt;em&gt;key-value&lt;/em&gt; store &lt;code&gt;Redis&lt;/code&gt; also has built in &lt;code&gt;messaging functionality via pub/sub&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="redis-installation"&gt;Redis installation&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; is not officially supported on Windows - so to use it on Windows, either &lt;code&gt;WSL2&lt;/code&gt; (Windows Subsystem for Linux) has to be used, or the Redis container image (available from &lt;a href="https://hub.docker.com/_/redis"&gt;Docker Hub&lt;/a&gt;) running in &lt;em&gt;Docker Desktop&lt;/em&gt;, for example.&lt;/p&gt;
&lt;p&gt;For the examples below, the &lt;code&gt;Redis&lt;/code&gt; image from &lt;em&gt;Docker Hub&lt;/em&gt; was used, running on &lt;em&gt;Docker Desktop&lt;/em&gt; for Windows.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="subscriber"&gt;Subscriber&lt;/h2&gt;
&lt;p&gt;First let's look at the &lt;code&gt;subscriber&lt;/code&gt; side. A reference is required to the &lt;code&gt;StackExchange.Redis&lt;/code&gt; NuGet package for the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using StackExchange.Redis;

// configure the connection to the Redis endpoint
using ConnectionMultiplexer redis = 
    ConnectionMultiplexer.Connect(&amp;quot;localhost:6379&amp;quot;);
ISubscriber subScriber = redis.GetSubscriber();

// subscribe to the &amp;quot;alwaysdeveloping&amp;quot; channel. This needs to match the channel name
// the publisher is using as well
subScriber.Subscribe(new RedisChannel(&amp;quot;alwaysdeveloping&amp;quot;, 
    RedisChannel.PatternMode.Auto), 
    (channel, message) =&amp;gt;
{
    // this handler method will be called for each message received on the channel
    Console.WriteLine($&amp;quot;[{DateTime.Now}] Message received: {message}&amp;quot;);
});

Console.ReadKey();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuring the &lt;code&gt;subscriber&lt;/code&gt; is relatively straight forward:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a connection to the specific &lt;code&gt;Redis&lt;/code&gt; endpoint&lt;/li&gt;
&lt;li&gt;Get a &lt;em&gt;subscriber&lt;/em&gt; from the connection&lt;/li&gt;
&lt;li&gt;Subscribe to a specific channel (by name , &lt;em&gt;alwaysdeveloping&lt;/em&gt; in the above)&lt;/li&gt;
&lt;li&gt;Specify the handler method to be called when a message is received&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code will execute until a key is read from the console, waiting for any message to be sent to the channel. When a message is sent to the channel, it will in turn be published to &lt;code&gt;all&lt;/code&gt; subscribers - it is possible to have &lt;code&gt;multiple subscribers&lt;/code&gt;, each subscriber &lt;code&gt;will receive their own copy of the message&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="publisher"&gt;Publisher&lt;/h2&gt;
&lt;p&gt;Next let's look at the &lt;code&gt;publisher&lt;/code&gt; - configuring this is also as straightforward as the subscriber:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using StackExchange.Redis;

// configure the connection to the Redis endpoint
using ConnectionMultiplexer redis = 
    ConnectionMultiplexer.Connect(&amp;quot;localhost:6379&amp;quot;);
ISubscriber sub = redis.GetSubscriber();

// loop 100 times
for (int i = 0; i &amp;lt;= 100; i++)
{
    // generate a unique id for each message
    var id = Guid.NewGuid().ToString();

    // publish to the &amp;quot;alwaysdeveloping&amp;quot; channel
    await sub.PublishAsync(new RedisChannel(&amp;quot;alwaysdeveloping&amp;quot;, 
        RedisChannel.PatternMode.Auto),
        $&amp;quot;Sample message with Id {id}&amp;quot;);

    Console.WriteLine($&amp;quot;Message with Id '{id}' published!&amp;quot;);
    Thread.Sleep(100);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a connection to the &lt;code&gt;Redis&lt;/code&gt; endpoint&lt;/li&gt;
&lt;li&gt;Get a &lt;em&gt;subscriber&lt;/em&gt; from the connection&lt;/li&gt;
&lt;li&gt;Loops 100 times,&lt;/li&gt;
&lt;li&gt;Publishes a string to a specific channel (by name, &lt;em&gt;alwaysdeveloping&lt;/em&gt; in the above)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="pubsub-execution"&gt;Pub/Sub Execution&lt;/h2&gt;
&lt;p&gt;Executing the &lt;code&gt;subscriber&lt;/code&gt; first, so it is running waiting for messages, then executing the &lt;code&gt;publisher&lt;/code&gt; yields the following output:&lt;/p&gt;
&lt;p&gt;Sample from the the &lt;strong&gt;Publisher&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Message with Id '1895b2c1-61c1-4be9-8ed2-7c6359018534' published!
Message with Id '01a27c11-984c-481a-b4d0-bc879b13674d' published!
Message with Id '49e799eb-cf4c-4847-a234-d79b8e40cd79' published!
Message with Id '25700248-edbc-4c70-aaef-5aca4cb0f24f' published!
Message with Id '6a4caee2-e9ad-446f-8e2c-156cebdf6a42' published!
Message with Id '061ef1ff-e830-408c-84db-bdf649c8c446' published!
Message with Id '358c78ba-e85a-481a-970a-1c67b2ca8b1d' published!
Message with Id '5101fe4a-86fb-4356-b0db-dea0f4f1a402' published!
Message with Id 'fe944b2c-c945-417c-bb61-8b7eb7bfe8f1' published!
Message with Id '1f6d26a0-35ab-4994-8293-1e2a9e672cee' published!
Message with Id '5e276d80-9ccd-403b-9435-80b8fda0e2d3' published!
Message with Id 'a3ea7ddd-6ac6-4b3e-b35d-1276ce20e1bd' published!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sample from the &lt;code&gt;Subscriber(s)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[2022/07/19 21:09:24] Message received: Sample message with Id 1895b2c1-61c1-4be9-8ed2-7c6359018534
[2022/07/19 21:09:24] Message received: Sample message with Id 01a27c11-984c-481a-b4d0-bc879b13674d
[2022/07/19 21:09:24] Message received: Sample message with Id 49e799eb-cf4c-4847-a234-d79b8e40cd79
[2022/07/19 21:09:24] Message received: Sample message with Id 25700248-edbc-4c70-aaef-5aca4cb0f24f
[2022/07/19 21:09:24] Message received: Sample message with Id 6a4caee2-e9ad-446f-8e2c-156cebdf6a42
[2022/07/19 21:09:24] Message received: Sample message with Id 061ef1ff-e830-408c-84db-bdf649c8c446
[2022/07/19 21:09:25] Message received: Sample message with Id 358c78ba-e85a-481a-970a-1c67b2ca8b1d
[2022/07/19 21:09:25] Message received: Sample message with Id 5101fe4a-86fb-4356-b0db-dea0f4f1a402
[2022/07/19 21:09:25] Message received: Sample message with Id fe944b2c-c945-417c-bb61-8b7eb7bfe8f1
[2022/07/19 21:09:25] Message received: Sample message with Id 1f6d26a0-35ab-4994-8293-1e2a9e672cee
[2022/07/19 21:09:25] Message received: Sample message with Id 5e276d80-9ccd-403b-9435-80b8fda0e2d3
[2022/07/19 21:09:25] Message received: Sample message with Id a3ea7ddd-6ac6-4b3e-b35d-1276ce20e1bd
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Configuring &lt;code&gt;Redis pub/sub&lt;/code&gt; is incredibly simple and easy to implement, especially if there is a Redis instance setup (for caching for example). While not entirely comparable, having worked with other similar services such as &lt;em&gt;RabbitMq&lt;/em&gt; and &lt;em&gt;Kafka&lt;/em&gt;, this was by far the simplest to implement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=80Ke9hsG_RU"&gt;DevMentors - FeedR episode #5&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/"&gt;Install Redis on Windows&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;139: 16-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>