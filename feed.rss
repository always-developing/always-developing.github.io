<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Mon, 08 Aug 2022 04:11:21 GMT</pubDate>
		<lastBuildDate>Mon, 08 Aug 2022 04:11:21 GMT</lastBuildDate>
		<item>
			<title>String null or empty using pattern matching</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/08-length-pattern-matching</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/08-length-pattern-matching</guid>
			<pubDate>Mon, 08 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pattern matching&lt;/code&gt; syntax can be used to check the nullability and length of a string, instead of the traditional &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; method - with interesting (and promising) performance benchmarks!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="isnullorempty"&gt;IsNullOrEmpty&lt;/h2&gt;
&lt;p&gt;Usually the &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; method is used to check if a specific string has a value (other than null or empty) - a string is passed in and a bool value is returned.&lt;/p&gt;
&lt;p&gt;Consider the following method which uses &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void IsStringNullOrEmpty(string value)
{ 
    if (!string.IsNullOrEmpty(value))
    {
        Console.WriteLine($&amp;quot;Using 'IsNullOrEmpty' the '{value}' is NOT empty or null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the method is called with three different values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string checkValue = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = &amp;quot;&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = null;
IsStringNullOrEmpty(checkValue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, only one value triggers an output to the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;    Using 'IsNullOrEmpty' the value 'www.alwaysdeveloping.net' is NOT empty or null
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="pattern-matching"&gt;Pattern Matching&lt;/h2&gt;
&lt;p&gt;However, instead of this, &lt;code&gt;string.IsNullOrEmpty&lt;/code&gt; the following &lt;code&gt;pattern matching&lt;/code&gt; syntax could be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    value is { Length: &amp;gt; 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This checks if the &lt;em&gt;value&lt;/em&gt; variable has a value (not null) and has a length greater than zero.&lt;/p&gt;
&lt;p&gt;Again, consider the following method which uses &lt;code&gt;pattern matching&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void IsStringNullOrEmpty(string value)
{
    if (value is { Length: &amp;gt; 0 })
    {
        Console.WriteLine($&amp;quot;Using 'pattern matching' the value '{value}' is NOT empty or null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the method is called with three different values (the same values as above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;string checkValue = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = &amp;quot;&amp;quot;;
IsStringNullOrEmpty(checkValue);

checkValue = null;
IsStringNullOrEmpty(checkValue);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, as expected, the same values as when using &lt;code&gt;IsNullOrEmpty&lt;/code&gt; are picked up as valid or not:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;    Using 'pattern matching' the value 'www.alwaysdeveloping.net' is NOT empty or null
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;So there doesn't appear to be any difference in the output of the two methods. Next let's see how each performs using BenchmarkDotNet.&lt;/p&gt;
&lt;p&gt;The two different methods were compared, using the same three values as above: a string with a &lt;code&gt;value&lt;/code&gt;, and &lt;code&gt;empty&lt;/code&gt; string and a &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[MemoryDiagnoser]
public class Benchmarks
{
    [Params(&amp;quot;alwaysdeveloping.net&amp;quot;, &amp;quot;&amp;quot;, null)]
    public string? strValue { get; set; }

    [Benchmark]
    public void IsNullOrEmpty()
    {
        _ = !string.IsNullOrEmpty(strValue);
    }

    [Benchmark]
    public void PatternMatching()
    {
        _ = strValue is { Length: &amp;gt; 0 };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;strValue&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2562 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0367 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0307 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2615 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2592 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0203 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0190 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2627 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0158 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0148 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0123 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0133 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0150 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0144 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0163 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsNullOrEmpty&lt;/td&gt;
&lt;td&gt;alwaysdeveloping.net&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0355 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0298 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0279 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0296 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PatternMatching&lt;/td&gt;
&lt;td&gt;alwaysdeveloping.net&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0093 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0113 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0105 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0056 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the result, when the string is &lt;code&gt;null or empty performance is pretty much equivalent&lt;/code&gt;, however when the string &lt;code&gt;has a value, pattern matching is about 4x faster&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;pattern matching&lt;/code&gt; syntax is definitely interesting and intriguing, however is definitely not as intuitive or informative to the developer as to what it does. If micro-optimization is required, this is definitely something to look into, however for most applications the performance improvement would be unnoticeable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1545094497138360323"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;133: 08-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Windows services with .NET Core</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/05-windows-service</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/05-windows-service</guid>
			<pubDate>Fri, 05 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Configuring code to run as a &lt;code&gt;Windows Service&lt;/code&gt; in .NET is simple and fairly straight-forward (at least simpler and more straight forward than I was expecting). The &lt;code&gt;Windows Service&lt;/code&gt; specific configuration only required a NuGet package and a few lines of code.&lt;/p&gt;
&lt;p&gt;This post will describe the &lt;code&gt;code changes&lt;/code&gt; required to make the code ready to be hosted as a Windows Service, but will not go into specifics on how the Windows Service is configured.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="background-service"&gt;Background Service&lt;/h2&gt;
&lt;p&gt;Whether hosted as a &lt;code&gt;Windows Service&lt;/code&gt; or not, the logic needs to be executed in the background, usually on a schedule or at specific intervals. This is done with the .NET &lt;em&gt;BackgroundService&lt;/em&gt; class.&lt;/p&gt;
&lt;p&gt;To start creating this background process, a class is created which inherits from &lt;em&gt;BackgroundService&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class RandomWorker : BackgroundService
{
    private readonly ILogger&amp;lt;RandomWorker&amp;gt; _logger;

    public RandomWorker(ILogger&amp;lt;RandomWorker&amp;gt; logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // continually run until cancelled
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation(&amp;quot;RandomWorker Service running &amp;quot; +
                &amp;quot;as Windows Service at: {currentTime}&amp;quot;, DateTime.Now);

            var random = new Random();
            var randomValue = random.Next(10);

            if(randomValue &amp;gt; 5)
            {
                _logger.LogError(&amp;quot;RandomWorker running as Windows &amp;quot; +
                    &amp;quot;Service threw an exception at: {currentTime}&amp;quot;, DateTime.Now);
            }

            // wait for 10 seconds
            await Task.Delay(10000, stoppingToken);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The class operates with &lt;code&gt;dependency injection&lt;/code&gt;, so any registered services can be injected (&lt;em&gt;ILogger&lt;/em&gt; in this example)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ExecuteAsync&lt;/code&gt; method is called once the background service is started - the &lt;code&gt;while&lt;/code&gt; loop in conjunction with the &lt;code&gt;Task.Delay&lt;/code&gt; call, ensures that the method is forever looping effectively executing every 10 seconds (roughly), until cancelled via the &lt;em&gt;CancellationToken&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now that we have a &lt;em&gt;BackgroundService&lt;/em&gt; which runs our logic, we need to host it so that it can be executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="hosting"&gt;Hosting&lt;/h2&gt;
&lt;h3 id="console-hosting"&gt;Console hosting&lt;/h3&gt;
&lt;p&gt;The simplest option is to host it in a &lt;em&gt;Console Application&lt;/em&gt; - this is an exe which needs to be executed, and will run until the console windows is closed.&lt;/p&gt;
&lt;p&gt;A top-level statement &lt;em&gt;Console Application&lt;/em&gt; is shown below, with the &lt;code&gt;RandomWorker&lt;/code&gt; class added as a &lt;em&gt;Hosted Service&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =&amp;gt;
    {
        // Add the RandomWorker as a hosted service
        services.AddHostedService&amp;lt;RandomWorker&amp;gt;();
    })
    .Build();

await host.RunAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sample output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 16:40:20
info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 16:40:30
info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 16:40:40
info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 16:40:50
info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 16:41:00
fail: WindowsServiceDemo.RandomWorker[0]
      RandomWorker running as Windows Service threw an exception at: 07/10/2022 16:41:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have the building blocks for a background service, running on an interval in a console we can look at how to turn this into a &lt;code&gt;Windows Service&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="windows-services-hosting"&gt;Windows Services hosting&lt;/h3&gt;
&lt;p&gt;Enhancing a traditional &lt;em&gt;Console Application&lt;/em&gt; to be able to be used as a &lt;code&gt;Windows Service&lt;/code&gt; is fairly straight forward:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Reference the &lt;code&gt;Microsoft.Extensions.Hosting.WindowsService&lt;/code&gt; NuGet package&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update the startup to include additional &lt;code&gt;Windows Service&lt;/code&gt; specific configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using WindowsServiceDemo;

IHost host = Host.CreateDefaultBuilder(args)
    // configure to be able to be used in Windows Service
    .UseWindowsService(options =&amp;gt;
    {
        // with the name
        options.ServiceName = &amp;quot;RandomWorker Service&amp;quot;;
    })
    .ConfigureServices(services =&amp;gt;
    {
        services.AddHostedService&amp;lt;RandomWorker&amp;gt;();
    })
    .Build();

await host.RunAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optionally configure &lt;code&gt;Event Viewer&lt;/code&gt; logging - this step can be skipped if logging to the Event Viewer is not required.
The default logging level for &lt;code&gt;Event Viewer&lt;/code&gt; is &lt;em&gt;Warning&lt;/em&gt;, so for development purposes the default log level can be set to &lt;em&gt;Information&lt;/em&gt;.
In &lt;code&gt;appsettings.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;Logging&amp;quot;: {
        &amp;quot;EventLog&amp;quot;: {
        &amp;quot;LogLevel&amp;quot;: {
            &amp;quot;Default&amp;quot;: &amp;quot;Information&amp;quot;
        }
        },
        &amp;quot;LogLevel&amp;quot;: {
        &amp;quot;Default&amp;quot;: &amp;quot;Information&amp;quot;,
        &amp;quot;Microsoft.Hosting.Lifetime&amp;quot;: &amp;quot;Information&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That's it! (from a code configuration point of view). The application can now be run as a normal console application, but is also &lt;em&gt;ready&lt;/em&gt; to be hosted as a &lt;code&gt;Windows Service&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This post will not go into detail around &lt;em&gt;how&lt;/em&gt; to configure the &lt;code&gt;Windows Service&lt;/code&gt; - but a brief summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The application needs to be &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/windows-service#publish-the-app"&gt;published&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Windows Service&lt;/code&gt; needs to be created using the &lt;code&gt;sc.exe&lt;/code&gt; tool. The tool creates the Windows Service and &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/windows-service#create-the-windows-service"&gt;links it to the exe created in the above step&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Optionally &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/windows-service#configure-the-windows-service"&gt;configure the Windows Service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally all of the above steps are done in a CI/CD pipeline, with all the steps automated.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="api-hosting"&gt;Api hosting&lt;/h3&gt;
&lt;p&gt;A note on the &lt;code&gt;BackgroundService&lt;/code&gt; inherited class, &lt;code&gt;RandomWorker&lt;/code&gt; - in the above example it was hosted in a &lt;em&gt;Console Application&lt;/em&gt; using:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    services.AddHostedService&amp;lt;RandomWorker&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The great thing about the &lt;code&gt;BackgroundService&lt;/code&gt;, is that it can be hosted in an API if required - allowing the service logic to become &lt;code&gt;cross platform&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below is top level statement API, using a minimal api - but also &lt;code&gt;hosting the background service&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHostedService&amp;lt;RandomWorker&amp;gt;();

var app = builder.Build();

app.MapGet(&amp;quot;/randomservice&amp;quot;, (ILogger&amp;lt;RandomWorker&amp;gt; logger) =&amp;gt;
{
     logger.LogInformation(&amp;quot;Endpoint called and executed &amp;quot; +
        &amp;quot;while background service is running&amp;quot;);
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running this API now executes the service in the background, while still allowing endpoints to be called:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 17:15:13
fail: WindowsServiceDemo.RandomWorker[0]
      RandomWorker running as Windows Service threw an exception at: 07/10/2022 17:15:13
info: WindowsServiceDemo.RandomWorker[0]
      Endpoint called and executed while background service is running
info: WindowsServiceDemo.RandomWorker[0]
      RandomWorker Service running as Windows Service at: 07/10/2022 17:15:23
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;In my personal experience, in the last few years &lt;code&gt;Windows Services&lt;/code&gt; have seen a decline in usage in favour of more cross-platform solutions, such as hosting the background service in an API, or using other scheduling solutions such as &lt;a href="https://www.hangfire.io/"&gt;HangFire&lt;/a&gt;.
However, in the case when hosting the code as a &lt;code&gt;Windows Service&lt;/code&gt; is unavoidable - it's good to know that its fairly simple and straightforward to configure .NET Core (and beyond) code to function as a Windows Service.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/windows-service"&gt;Create a Windows Service using BackgroundService&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://code-maze.com/aspnetcore-running-applications-as-windows-service/"&gt;Running .NET Core Applications as a Windows Service&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;132: 05-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Dynamically changing minimal api return type</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/04-minimal-api-return-type</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/04-minimal-api-return-type</guid>
			<pubDate>Thu, 04 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Minimal apis, by default, have a JSON return type - however a custom &lt;code&gt;IResult&lt;/code&gt; implementation can be used to change this return type. This same interface can be used to dynamically decide at runtime the return type, but requires some additional effort.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="default-return-type"&gt;Default return type&lt;/h2&gt;
&lt;p&gt;With minimal api's, the default return type is JSON. Executing the following command, the &lt;em&gt;Song&lt;/em&gt; instance is automatically serialized to JSON and the response &lt;em&gt;content-type&lt;/em&gt; header automatically set to &lt;strong&gt;application/json&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/json&amp;quot;, () =&amp;gt;
{
    return new Song
    {
        ArtistName = &amp;quot;John Mayer&amp;quot;,
        SongName = &amp;quot;Bigger than my body&amp;quot;,
        LengthInSeconds = 245
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Returned JSON:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{&amp;quot;songName&amp;quot;:&amp;quot;Bigger than my body&amp;quot;,&amp;quot;artistName&amp;quot;:&amp;quot;John Mayer&amp;quot;,&amp;quot;lengthInSeconds&amp;quot;:245}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WHat if a &lt;code&gt;different return type&lt;/code&gt; is required?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="xml-return-type"&gt;XML return type&lt;/h2&gt;
&lt;p&gt;As mentioned, to change the response type, instead of just returning the &lt;em&gt;Song&lt;/em&gt; instance (which will then serialize to JSON), an implementation of &lt;code&gt;IResult&lt;/code&gt; needs to be returned.&lt;/p&gt;
&lt;p&gt;In this endpoint an instance of the custom class &lt;code&gt;XmlResult&lt;/code&gt; (full code below) is being returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/xml&amp;quot;, () =&amp;gt;
{
    // XML implementation of IResult 
    return new XmlResult&amp;lt;Song&amp;gt;(
        new Song
        {
            ArtistName = &amp;quot;John Mayer&amp;quot;,
            SongName = &amp;quot;Bigger than my body&amp;quot;,
            LengthInSeconds = 245
        });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;XmlResult&lt;/code&gt; is an implementation of the &lt;code&gt;IResult&lt;/code&gt; interface, which is very simple, containing only one method to implement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    Task ExecuteAsync(HttpContext httpContext);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method will accept the &lt;em&gt;HttpContext&lt;/em&gt; of the request as a parameter, and modify the response body and headers as required before being returned to the called.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;XmlResult&lt;/code&gt; implementation (this is by no means the most efficient method for doing XML serialization, but it's a simple demonstration for this post):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// implement IResult
public class XmlResult&amp;lt;T&amp;gt; : IResult
{
    // store the entity to be serialized
    private readonly T _entity;

    public XmlResult(T entity)
    {
        _entity = entity;
    }

    // method which needs implementing
    public Task ExecuteAsync(HttpContext httpContext)
    {
        // prepare for XML serialization
        XmlSerializer xmlSerializer = new(typeof(T));
        using StringWriter textWriter = new();

        // perform the serialization
        xmlSerializer.Serialize(textWriter, _entity);

        // modify the response content type, content length and 
        // write the XML to the body of the response
        httpContext.Response.ContentType = MediaTypeNames.Application.Xml;
        httpContext.Response.ContentLength = 
            Encoding.UTF8.GetByteCount(textWriter.ToString());
        return httpContext.Response.WriteAsync(textWriter.ToString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/xml&lt;/code&gt; endpoint show above, returns the following response, with the response &lt;em&gt;content-type&lt;/em&gt; set to &lt;strong&gt;application/xml&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Song&amp;gt;
    &amp;lt;SongName&amp;gt;Bigger than my body&amp;lt;/SongName&amp;gt;
    &amp;lt;ArtistName&amp;gt;John Mayer&amp;lt;/ArtistName&amp;gt;
    &amp;lt;LengthInSeconds&amp;gt;245&amp;lt;/LengthInSeconds&amp;gt;
&amp;lt;/Song&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far so good, however, the standard recommended way of returning an &lt;code&gt;IResult&lt;/code&gt; implementation is via an extension method on &lt;code&gt;IResultExtensions&lt;/code&gt;, and not a manual instantiation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class XmlResultsExtensions
{
    public static IResult Xml&amp;lt;T&amp;gt;(this IResultExtensions resultExtensions, T entity)
    {
        ArgumentNullException.ThrowIfNull(resultExtensions);

        return new XmlResult&amp;lt;T&amp;gt;(entity);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this extension method, the &lt;strong&gt;final XML endpoint&lt;/strong&gt; now looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/xml&amp;quot;, () =&amp;gt;
{
    // Use the extension method instead of 
    // explicitly using XmlResult 
    return Results.Extensions.Xml(
        new Song
        {
            ArtistName = &amp;quot;John Mayer&amp;quot;,
            SongName = &amp;quot;Bigger than my body&amp;quot;,
            LengthInSeconds = 245
        });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next up we explore how to allow the &lt;code&gt;caller to decide how they would like the data returned, using a single endpoint&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="dynamic-return-type"&gt;Dynamic return type&lt;/h2&gt;
&lt;p&gt;Let's explore how the return type can be changed dynamically based on an indicator from the caller. For this example we'll use the &lt;code&gt;content-type&lt;/code&gt; of the &lt;em&gt;request&lt;/em&gt; as the indicator (not necessarily the good option for all cases - but good enough for this demo).&lt;/p&gt;
&lt;p&gt;We'll add a parameter to the endpoint, and instruct ASPNET Core to get the value from the &lt;code&gt;content-type&lt;/code&gt; header, using the &lt;em&gt;FromHeader&lt;/em&gt; attribute:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/dynamic&amp;quot;, ([FromHeader(Name = &amp;quot;Content-Type&amp;quot;)] string? contentType) =&amp;gt;
{
    var song = new Song
    {
        ArtistName = &amp;quot;John Mayer&amp;quot;,
        SongName = &amp;quot;Bigger than my body&amp;quot;,
        LengthInSeconds = 245
    };

    return song;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Progress! However this endpoint still only returns JSON. Next let's add the check on the request content type....&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/dynamic&amp;quot;, ([FromHeader(Name = &amp;quot;Content-Type&amp;quot;)] string? contentType) =&amp;gt;
{
    var song = new Song
    {
        ArtistName = &amp;quot;John Mayer&amp;quot;,
        SongName = &amp;quot;Bigger than my body&amp;quot;,
        LengthInSeconds = 245
    };

    // if XML return XML implementation of Song
    if (contentType == MediaTypeNames.Application.Xml)
    {
        return Results.Extensions.Xml(song);
    }

    return song;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...which &lt;code&gt;results in an error!&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot convert lambda expression to type 'RequestDelegate' because 
    the parameter types do not match the delegate parameter types
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our endpoint is trying trying to return two different types - an &lt;code&gt;IResult&lt;/code&gt; implementation when XML, and a &lt;code&gt;Song&lt;/code&gt; instance when not.&lt;/p&gt;
&lt;p&gt;This is easy enough to resolve - change the endpoint to &lt;code&gt;always returns an IResult&lt;/code&gt; implementation. To do this however, we now need a &lt;code&gt;custom IResult implementation for JSON&lt;/code&gt;. It operates exactly the same as the XML implementation, but serializes to JSON instead of XML:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class JsonResult&amp;lt;T&amp;gt; : IResult
{
    private readonly T _entity;

    public JsonResult(T entity)
    {
        _entity = entity;
    }

    public Task ExecuteAsync(HttpContext httpContext)
    {
        using StringWriter textWriter = new StringWriter();
        var jsonResult = System.Text.Json.JsonSerializer.Serialize&amp;lt;T&amp;gt;(_entity);

        httpContext.Response.ContentType = MediaTypeNames.Application.Json;
        httpContext.Response.ContentLength = Encoding.UTF8.GetByteCount(jsonResult);
        return httpContext.Response.WriteAsync(jsonResult);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the corresponding extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class JsonResultsExtensions
{
    public static IResult Json&amp;lt;T&amp;gt;(this IResultExtensions resultExtensions, T entity)
    {
        ArgumentNullException.ThrowIfNull(resultExtensions);

        return new JsonResult&amp;lt;T&amp;gt;(entity);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, we update the &lt;em&gt;dynamic&lt;/em&gt; endpoint so the &lt;strong&gt;final endpoint&lt;/strong&gt; now looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/dynamic&amp;quot;, ([FromHeader(Name = &amp;quot;Content-Type&amp;quot;)] string? contentType) =&amp;gt;
{
    var song = new Song
    {
        ArtistName = &amp;quot;John Mayer&amp;quot;,
        SongName = &amp;quot;Bigger than my body&amp;quot;,
        LengthInSeconds = 245
    };

    // if XML return XML implementation of Song
    if (contentType == MediaTypeNames.Application.Xml)
    {
        return Results.Extensions.Xml(song);
    }

    // In all other cases return JSON
    return Results.Extensions.Json(song);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The endpoint can now be invoked with a &lt;code&gt;content-type&lt;/code&gt; header value &lt;code&gt;application/xml&lt;/code&gt; to get the results in XML and in all other cases, get the result as JSON.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a fair amount of code just to change the response type - but it is a piece of code which only needs to be written once and can then be reused across all endpoints. All endpoints can then benefit from bug fixes or performance improvements in the &lt;code&gt;IResult&lt;/code&gt; implementation.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-6.0#responses"&gt;Minimal APIs overview - responses&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;131: 04-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>String interpolation with alignment</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/03-string-interpolation-alignment</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/03-string-interpolation-alignment</guid>
			<pubDate>Wed, 03 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;string interpolation ($)&lt;/code&gt;, the &lt;em&gt;interpolation expressions results&lt;/em&gt; (the final string resolved into the main string) can be left or right aligned, including padding to be used when aligning.&lt;/p&gt;
&lt;p&gt;This can be very useful when having &lt;em&gt;interpolation expressions&lt;/em&gt; which result in string of varying lengths - having these values alignment can result in a more uniform output.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In all the below examples, a collection of &lt;em&gt;sale values&lt;/em&gt; of varying lengths is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var saleValues = new[]
{
    100,
    54500,
    1,
    8514,
    -500
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="default"&gt;Default&lt;/h4&gt;
&lt;p&gt;If we want to output each of them without any alignment:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The sale amount is: 100 (for the month of August)
The sale amount is: 54500 (for the month of August)
The sale amount is: 1 (for the month of August)
The sale amount is: 8514 (for the month of August)
The sale amount is: -500 (for the month of August)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="right-align"&gt;Right align&lt;/h4&gt;
&lt;p&gt;If we require a more uniform output, a &lt;code&gt;positive number&lt;/code&gt; can be used to &lt;code&gt;right align and pad&lt;/code&gt; the value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach (var sale in saleValues)
{
    Console.WriteLine($&amp;quot;The sale amount is: {sale, 9} (for the month of August)&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above will &lt;code&gt;right align&lt;/code&gt; the &lt;em&gt;sale&lt;/em&gt; value and make it a uniform &lt;em&gt;9 characters in length&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The sale amount is:       100 (for the month of August)
The sale amount is:     54500 (for the month of August)
The sale amount is:         1 (for the month of August)
The sale amount is:      8514 (for the month of August)
The sale amount is:      -500 (for the month of August)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="left-align"&gt;Left align&lt;/h4&gt;
&lt;p&gt;To left align, a &lt;code&gt;negative number&lt;/code&gt; is specified:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach (var sale in saleValues)
{
    Console.WriteLine($&amp;quot;The sale amount is: {sale, -9} (for the month of August)&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above will &lt;code&gt;left align&lt;/code&gt; the &lt;em&gt;sale&lt;/em&gt; value and make it a uniform &lt;em&gt;9 characters in length&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The sale amount is: 100       (for the month of August)
The sale amount is: 54500     (for the month of August)
The sale amount is: 1         (for the month of August)
The sale amount is: 8514      (for the month of August)
The sale amount is: -500      (for the month of August)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id="const-value"&gt;Const value&lt;/h4&gt;
&lt;p&gt;The value specified is required to be a constant value.&lt;/p&gt;
&lt;p&gt;So this is valid:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// must be a constant
const int length = 10;

foreach (var sale in saleValues)
{
    Console.WriteLine($&amp;quot;The sale amount is: {sale, length} (for the month of August)&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, this is &lt;code&gt;NOT VALID&lt;/code&gt;, as &lt;em&gt;length&lt;/em&gt; is not a &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int length = saleValues.Length;

foreach (var sale in saleValues)
{
    Console.WriteLine($&amp;quot;The sale amount is: {sale, length} (for the month of August)&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small lesser-known feature of string interpolation, however it can be very useful in producing uniform output when required, with very little additional effort.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1541467908169035776"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;130: 03-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ActivatorUtilities to create instances</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/02-activatorutilities</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/02-activatorutilities</guid>
			<pubDate>Tue, 02 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ActivatorUtilities&lt;/code&gt; static class can be used to create instances of classes &lt;code&gt;outside of the dependency injection (DI) container&lt;/code&gt;, while still &lt;code&gt;leveraging the DI container&lt;/code&gt; to create instances of the dependencies.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;Consider a business logic class, which has one dependency on &lt;code&gt;IConfiguration&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyBusinessLogic
{
    private readonly IConfiguration _configuration;

    public MyBusinessLogic(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    public int PerformBusinessLogic()
    {
        Console.WriteLine(&amp;quot;Performing business logic&amp;quot;);

        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It consists of a &lt;em&gt;Constructor&lt;/em&gt; and a single method, &lt;em&gt;PerformBusinessLogic&lt;/em&gt;, which performs some business logic, and returns the value &lt;code&gt;1&lt;/code&gt; once completed.&lt;/p&gt;
&lt;p&gt;In all of the below examples, the &lt;em&gt;MyBusinessLogic&lt;/em&gt; class &lt;code&gt;has NOT been registered with the dependency injection container&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The code for all the endpoints shown below is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// endpoint definition show below goes here!

app.Run();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thats it - nothing else being registered or configured on startup.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-di"&gt;Default DI&lt;/h3&gt;
&lt;p&gt;First, we'll try getting an instance of class directly from the DI container, two different ways:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject directly
app.MapGet(&amp;quot;/direct&amp;quot;, ([FromServices]MyBusinessLogic logic) =&amp;gt;
{
    return logic.PerformBusinessLogic();
});

// inject the service provider (the DI container)
// and try get the service from there
app.MapGet(&amp;quot;/provider&amp;quot;, (IServiceProvider provider) =&amp;gt;
{
    var logic = provider.GetRequiredService&amp;lt;MyBusinessLogic&amp;gt;();

    return logic.PerformBusinessLogic();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you've worked with DI before, you would be unsurprised to know that the above does not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;InvalidOperationException: No service for type 'MyBusinessLogic' has been registered.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The runtime doesn't know how to instantiate the &lt;em&gt;MyBusinessLogic&lt;/em&gt; class. To resolve we could register &lt;em&gt;MyBusinessLogic&lt;/em&gt; with the DI container, but for this post the assumption is this is not an option.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="manual"&gt;Manual&lt;/h3&gt;
&lt;p&gt;Next we'll look at the ways to manually get an instance of the &lt;em&gt;MyBusinessLogic&lt;/em&gt; class:&lt;/p&gt;
&lt;p&gt;The first way is to just manually instantiate the class directly. The constructor of &lt;em&gt;MyBusinessLogic&lt;/em&gt; requires an instance of &lt;code&gt;IConfiguration&lt;/code&gt;. In the below, &lt;code&gt;IConfiguration&lt;/code&gt; is injected via DI, and then passed to the constructor of &lt;em&gt;MyBusinessLogic&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/manual&amp;quot;, (IConfiguration config) =&amp;gt;
{
    var logic = new MyBusinessLogic(config);

    return logic.PerformBusinessLogic();
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;This will work&lt;/code&gt;, but if &lt;em&gt;MyBusinessLogic&lt;/em&gt; had a long list of dependencies and it's constructor required many parameters, this can become messy. The endpoint would need to be modified to accept items from the DI container when it doesn't actual require them directly - they are only used to pass to &lt;em&gt;MyBusinessLogic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As slight improvement is to only inject the &lt;em&gt;IServiceProvider&lt;/em&gt; implementation into the endpoint and then use that to get the required items for the &lt;em&gt;MyBusinessLogic&lt;/em&gt; constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/manualprovider&amp;quot;, (IServiceProvider provider) =&amp;gt;
{
    var logic = new MyBusinessLogic(provider.GetService&amp;lt;IConfiguration&amp;gt;());

    return logic.PerformBusinessLogic();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this &lt;code&gt;will work&lt;/code&gt;, but is still not ideal, as each type required needs to manually retrieved from the DI container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="activatorutilities"&gt;ActivatorUtilities&lt;/h3&gt;
&lt;p&gt;Thankfully, there is a class to assist with this exact requirement - the &lt;code&gt;ActivatorUtilities&lt;/code&gt; static class. Its usage is very simple - the &lt;em&gt;CreateInstance&lt;/em&gt; method is called with the required class passed in as a generic parameter, along with the &lt;em&gt;IServiceProvider&lt;/em&gt; implementation as a parameter (any other parameters which might be required, but are not part of the DI container).&lt;br /&gt;
&lt;code&gt;ActivatorUtilities&lt;/code&gt; will then return an instance of the require class, using the &lt;em&gt;IServiceProvider&lt;/em&gt; implementation to resolve any dependencies automatically - as would happen when using the DI container implicitly.&lt;/p&gt;
&lt;p&gt;As the required &lt;em&gt;IConfiguration&lt;/em&gt; parameter is already in the DI container, no additional parameters need to be passed in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/activatorutils&amp;quot;, (IServiceProvider provider) =&amp;gt;
{
    var logic = ActivatorUtilities.CreateInstance&amp;lt;MyBusinessLogic&amp;gt;(provider);

    return logic.PerformBusinessLogic();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an &lt;code&gt;instance of MyBusinessLogic is created&lt;/code&gt;, and all its dependencies are &lt;code&gt;automatically resolved from the IServiceProvider instance&lt;/code&gt;, provider.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;An incredibly useful method when working with dependency injection, but not all classes have been added to the DI container (for example, if in the processes of porting a legacy app, one controller at a time).&lt;/p&gt;
&lt;p&gt;There are other ways of doing this using reflection (&lt;em&gt;Activator.CreateInstance&lt;/em&gt; for example) not mentioned here - this post focuses on instantiating a class when the type wanted is known at compile time.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://onthedrift.com/posts/activator-utilities/"&gt;Activator utilities: activate anything!&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;129: 02-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Readonly parameters with the in modifier</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/01-in-modifier</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/01-in-modifier</guid>
			<pubDate>Mon, 01 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; parameter modifying keyword is used to cause a parameter be passed by reference, and ensure that cannot be modified in the method.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; modifier's usage is similar to the &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; keywords, except &lt;code&gt;ref&lt;/code&gt; parameters can be modified and &lt;code&gt;out&lt;/code&gt; parameters must be modified/set, while the &lt;code&gt;in&lt;/code&gt; modifier effectively makes the parameter read-only.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="types"&gt;Types&lt;/h2&gt;
&lt;h3 id="simple-value-types"&gt;Simple value types&lt;/h3&gt;
&lt;p&gt;First lets have a look at how value types are handled in a few simple examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int originalValue = 1001;
InKeywordMethod(originalValue);

// parameter used in keyword
void InKeywordMethod(in int theValue)
{
    // this is not allowed and 
    // will not compile if uncommented
    // theValue = 999;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If uncommented, the application will not compile with the error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot assign to variable 'in int' because it is a readonly variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected based on the introduction, with the use of the &lt;code&gt;in&lt;/code&gt; keyword, the &lt;em&gt;theValue&lt;/em&gt; variable is read-only inside the scope of the method, and cannot be modified.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="structure-value-types"&gt;Structure value types&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; keyword applied to a &lt;code&gt;struct&lt;/code&gt; (a value type) parameter, yields in the same results as in the previous example with sample value types.&lt;/p&gt;
&lt;p&gt;Consider the following &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct StructOptions
{
    public int IntValue { get; set; }
    public string StringValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it's usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sOptions = new StructOptions
{
    IntValue = 759,
    StringValue = &amp;quot;StringValue&amp;quot;
};
InStructKeywordMethod(sOptions);

void InStructKeywordMethod(in StructOptions options)
{
    // this is not allowed and will not compile if uncommented
    // options.IntValue = 100;

    // this is also not allowed and will result in an error
    /*
    options = new StructOptions
    {
        IntValue = 123,
        StringValue = &amp;quot;NewStringValue!&amp;quot;
    }
    */
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The properties of the &lt;code&gt;struct&lt;/code&gt; as well as the &lt;code&gt;struct&lt;/code&gt; itself are both read-only.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="reference-types"&gt;Reference types&lt;/h3&gt;
&lt;p&gt;Reference types however operate slightly differently when used with the &lt;code&gt;in&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;We will use the same &lt;em&gt;Options&lt;/em&gt; data structure as in the previous example, however this time define it as a &lt;code&gt;class&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Options
{
    public int IntValue { get; set; }

    public string StringValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it's usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var options = new Options
{
    IntValue = 759,
    StringValue = &amp;quot;StringValue&amp;quot;
};

Console.WriteLine(options.IntValue);
InClassKeywordMethod(options);
Console.WriteLine(options.IntValue);

void InClassKeywordMethod(in Options options)
{
    // This is allowed!
    options.IntValue = 123;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the reference type, modifications of its properties are allowed. Running the above code does not result in any compiler errors, with the output as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;759
123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, modification of the &lt;code&gt;class&lt;/code&gt; instance (not it's properties) is &lt;strong&gt;NOT&lt;/strong&gt; allowed, and will result in a &lt;strong&gt;compiler error&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void InClassKeywordMethod(in Options options)
{
    // Cannot assign to variable 'in Options' because it is a readonly variable
    /*
    options = new Options
    {
        IntValue = 123,
        StringValue = &amp;quot;NewStringValue&amp;quot;
    };
    */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Not a modifier which will see everyday use, but interesting all the same. If using the &lt;code&gt;in&lt;/code&gt; keyword, keep in mind that reference types properties can still be modified, and consider other options to make them readonly (removing the &lt;em&gt;set&lt;/em&gt; accessor, for example)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier"&gt;in parameter modifier&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;128: 01-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Deconstructing a class instance into multiple variables</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/29-deconstruct-method</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/29-deconstruct-method</guid>
			<pubDate>Fri, 29 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;One or many &lt;code&gt;Deconstruct&lt;/code&gt; methods can be added to a class allowing the class properties to be deconstructed into one or more variables (depending on the &lt;code&gt;Deconstruct&lt;/code&gt; methods available). This helps created cleaner, more concise code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-deconstruct"&gt;Non-Deconstruct&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Song&lt;/em&gt; class, with three properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string SongName { get; init; }

    public string ArtistName { get; init; }

    public int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If there is a requirement to print out all the properties of a &lt;em&gt;Song&lt;/em&gt; instance, it could be done like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

Console.WriteLine($&amp;quot;The song '{song1.SongName}' by '{song1.ArtistName}' &amp;quot; +
    $&amp;quot;is {song1.LengthInSeconds} seconds long&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing especially wrong with this, but if the &lt;em&gt;Song&lt;/em&gt; class had more properties, with long names, the interpolated string could get long and unwieldy.&lt;/p&gt;
&lt;p&gt;This could be simplified by doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

var name = song1.SongName;
var artist = song1.ArtistName;
var length = song1.LengthInSeconds;

Console.WriteLine($&amp;quot;The song '{name}' by '{artist}' is {length} seconds long&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interpolated string is definitely more concise now, but thee extra variables have been defined and assigned. This would make sense if the values are being reused numerous times in the code - but if this is only used once-off, a lot of vertical space has been taken up for no real &amp;quot;value&amp;quot;.&lt;/p&gt;
&lt;p&gt;However, the &lt;code&gt;Deconstruct&lt;/code&gt; method makes this process even more concise and simpler.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="deconstruct"&gt;Deconstruct&lt;/h2&gt;
&lt;p&gt;One or many &lt;code&gt;Deconstruct&lt;/code&gt; method can be added to the &lt;em&gt;Song&lt;/em&gt; class to allow for the deconstruction of the instance into variables.&lt;/p&gt;
&lt;p&gt;A method called &lt;code&gt;Deconstruct&lt;/code&gt; is defined on the class, with one or more &lt;code&gt;out&lt;/code&gt; parameters in the method signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string SongName { get; init; }

    public string ArtistName { get; init; }

    public int LengthInSeconds { get; init; }

    // deconstruct all three properties
    public void Deconstruct(out string artist, out string name, out int length)
    {
        name = SongName;
        artist = ArtistName;
        length = LengthInSeconds;
    }

    // deconstruct into a string combination of song and artist
    // as well as the length
    public void Deconstruct(out string output, out int length)
    {
        output = $&amp;quot;'{SongName}' by {ArtistName}&amp;quot;;
        length = LengthInSeconds;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Deconstruct&lt;/code&gt; methods can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

// deconstruct song1, into three variables
var (artist, name, length) = song1;
Console.WriteLine($&amp;quot;The song '{name}' by '{artist}' is {length} long&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the three variables &lt;em&gt;artist&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; are automatically defined and assigned to the &lt;code&gt;out&lt;/code&gt; parameter values of the matching corresponding &lt;code&gt;Deconstruct&lt;/code&gt; method. Definitely cleaner and more concise that previous techniques.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Deconstruct&lt;/code&gt; methods also work with the &lt;code&gt;discard&lt;/code&gt; character. In the above example there is a second &lt;code&gt;Deconstruct&lt;/code&gt; method which returns the string &lt;em&gt;output&lt;/em&gt; and the song &lt;em&gt;length&lt;/em&gt;. If only interested in the &lt;em&gt;output&lt;/em&gt; value, but not the &lt;em&gt;length&lt;/em&gt;, then the following can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

// deconstruct song1, into only one variable
// discarding the length
var (output, _) = song1;
Console.WriteLine(output);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here no memory is allocated for the &lt;em&gt;length&lt;/em&gt; out parameter where the &lt;code&gt;discard&lt;/code&gt; is used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;There are not too many practical use cases for the &lt;code&gt;Deconstruct&lt;/code&gt; method - but where it can be applied (in cases such as the ones described above), it will definitely assist with creating cleaner, more concise code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct#user-defined-types"&gt;Deconstructing tuples and other types&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;127: 29-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Multiple applications - one host</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/28-multi-applications</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/28-multi-applications</guid>
			<pubDate>Thu, 28 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Multiple applications can be executed inside a single ASPNET Core host - this effectively &lt;code&gt;allows different endpoints and functionality to be available on the same base URL, but with different ports&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I first learnt about this in  Khalid Abuhakmeh's &lt;a href="https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host"&gt;post on the subject&lt;/a&gt;, however his post dives into using the &lt;em&gt;IHostBuilder&lt;/em&gt; (the technique prior to .NET6's top level statement and minimal api model). This post explores how to achieve the same output, but with the .NET6 &lt;em&gt;WebApplicationBuilder&lt;/em&gt;, top level statements and minimal api.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-application"&gt;Single application&lt;/h2&gt;
&lt;p&gt;First let's look at the default host setup with a single application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Create the builder
var builder = WebApplication.CreateBuilder(args);

// create the app from the builder
var app = builder.Build();

// optionally set the port
app.Urls.Add(&amp;quot;http://*:5001&amp;quot;);

// define endpoints to expose on the port
app.MapGet(&amp;quot;/main&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the main application&amp;quot;;
});

// run the application
await app.RunAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a number of steps to configuring an application for startup:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the &lt;em&gt;WebApplicationBuilder&lt;/em&gt; instance, and optionally configure the dependency injection container (not done in this example)&lt;/li&gt;
&lt;li&gt;Build the application, which returns a &lt;em&gt;WebApplication&lt;/em&gt; instance&lt;/li&gt;
&lt;li&gt;Optionally configure the port(s) the application exposes&lt;/li&gt;
&lt;li&gt;Optionally configure any endpoints to expose on the above ports&lt;/li&gt;
&lt;li&gt;Run the application&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To create multiple applications, basically these &lt;code&gt;steps need to be duplicated&lt;/code&gt;, with some slight changes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-applications"&gt;Multiple applications&lt;/h2&gt;
&lt;h3 id="startup"&gt;Startup&lt;/h3&gt;
&lt;p&gt;In our sample, we are going to create two applications to be hosted - a &lt;em&gt;main&lt;/em&gt; application, which would expose business related endpoints, and an &lt;em&gt;admin&lt;/em&gt; application which exposes admin related endpoints. This setup is just for demo purposes - I wouldn't necessarily recommend this setup for a production application as a default.&lt;/p&gt;
&lt;p&gt;Let's start at the top and duplicate the configuration.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create the &lt;code&gt;WebApplicationBuilder instance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create the main application builder
var builder = WebApplication.CreateBuilder(args);
// create the admin application builder
var adminBuilder = WebApplication.CreateBuilder(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Build&lt;/code&gt; the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// main application
var app = builder.Build();
// admin application
var adminApp = adminBuilder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Configure the port(s)&lt;/code&gt; the applications each expose:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the main application's endpoints will be exposed 
// on port 5001
app.Urls.Add(&amp;quot;http://*:5001&amp;quot;);
// the admin endpoints will be exposed 
// on port 5009
adminApp.Urls.Add(&amp;quot;http://*:5009&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure any &lt;code&gt;endpoints to be exposed&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// exposed the main application endpoints
app.MapGet(&amp;quot;/main&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the main application&amp;quot;;
});

// expose the admin endpoints
adminApp.MapGet(&amp;quot;/admin&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the admin application&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Run&lt;/code&gt; the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// as we have multiple applications running
// we execute both of them and wait for either
// to finish before shutting down the host
await Task.WhenAny(
    app.RunAsync(),
    adminApp.RunAsync()
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id="execution"&gt;Execution&lt;/h3&gt;
&lt;p&gt;Running the project/host now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Expose &lt;em&gt;main application&lt;/em&gt; functionality on port &lt;code&gt;5001&lt;/code&gt;. Browsing to &lt;code&gt;http://localhost:5001/main&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Welcome to the main application
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While trying to access the &lt;em&gt;admin&lt;/em&gt; endpoint on the &lt;code&gt;main application port 5001&lt;/code&gt; will not return any results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expose &lt;em&gt;admin&lt;/em&gt; functionality on port &lt;code&gt;5009&lt;/code&gt;. Browsing to &lt;code&gt;http://localhost:5009/admin&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Welcome to the admin application
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While trying to access the &lt;em&gt;main&lt;/em&gt; endpoint on the &lt;code&gt;admin application port 5009&lt;/code&gt; will not return any results.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not something I would recommend as the default go-to method, the ability to segregate endpoints into completely separate applications can prove useful in certain use cases - such as separating business and admin functionality as demonstrated in the example or if running a multi-tenant application, another use case could to separate each tenant into their own application (and own ports).
However there are probably better ways than creating multiple applications in one host for both the above mentioned use cases - but the knowledge the this is possible, is another tool to potentially use when required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host"&gt;Hosting Two ASP.NET Core Apps In One Host&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;126: 28-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Null forgiving operator</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving</guid>
			<pubDate>Wed, 27 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# contains a &lt;code&gt;unary, postfix, null-forgiving&lt;/code&gt; (or null-suppression) operator &lt;code&gt;!&lt;/code&gt;, which can be used to declare that an expression of a reference type is &lt;code&gt;not null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The null-forgiving operator is used in a nullable enabled context, has no effect at run time, and only affects the compiler's static flow analysis by changing the null state of the expression in question.&lt;/p&gt;
&lt;p&gt;Effectively, the operator informs the compiler that an expression which it has determined to be &lt;code&gt;null&lt;/code&gt;, is in fact not null and no diagnostic alert (a warning by default) needs to be raised.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="unit-testing"&gt;Unit testing&lt;/h3&gt;
&lt;p&gt;A practical use of the &lt;code&gt;!&lt;/code&gt; null-forgiving operator, is when performing unit tests.&lt;/p&gt;
&lt;p&gt;Consider the following class, which has an &lt;em&gt;Artist&lt;/em&gt; property, forced to be &lt;code&gt;non-null&lt;/code&gt; by the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; }

    public Song(string artist)
    {
        Artist = artist ?? throw new ArgumentNullException(nameof(artist));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When unit testing the class, one would want to test all possible combinations of &lt;em&gt;Song&lt;/em&gt; instantiation - with and without a valid &lt;em&gt;artist&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
var exceptionSong = new Song(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, is at compile time, the compiler sees the &lt;code&gt;null&lt;/code&gt; being passed to the constructor and raises the following warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot convert null literal to non-nullable reference type.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we &lt;strong&gt;want&lt;/strong&gt; to pass &lt;code&gt;null&lt;/code&gt; as part of a unit test to determine the correct behavior is seen. The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used to effectively tell the compiler, that the &lt;em&gt;&lt;code&gt;null&lt;/code&gt; expression is not null, and the compiler does not need to treat is as such&lt;/em&gt; (and thus no warning is generated)&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
// Null-forgiving operator added
var exceptionSong = new Song(null!);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-check"&gt;Manual check&lt;/h3&gt;
&lt;p&gt;Another practical use of the &lt;code&gt;null-forgiving operator&lt;/code&gt;, is in situations when the compiler has &lt;code&gt;incorrectly&lt;/code&gt; determined that an expression could possibly be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the below method to validate an instance of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static bool IsValid(Song? song)
    =&amp;gt; song is not null &amp;amp;&amp;amp; song.Artist is not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance 
// from a source
Song? s = GetSong();

// validate the song and output if valid
if (IsValid(s))
{
    Console.WriteLine($&amp;quot;Song by Artist `{s.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code generates the following warning on the &lt;code&gt;s.Artist&lt;/code&gt; usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Dereference of a possibly null reference.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This warning is due to the fact, that based on the data types, &lt;code&gt;s&lt;/code&gt; (of type &lt;code&gt;Song?&lt;/code&gt;) could contain a &lt;code&gt;null&lt;/code&gt; value, in which case &lt;code&gt;s.Artist&lt;/code&gt; would cause an exception. However, the &lt;code&gt;IsValid&lt;/code&gt; method is performing checks to ensure that &lt;code&gt;s.Artist can never be invoked when s is null&lt;/code&gt; - in this use case the warning is incorrect.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used again to tell the compiler, that the &lt;em&gt;s&lt;/em&gt; expression in &lt;code&gt;s.Artist&lt;/code&gt; can be treated as never being null.&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance
Song? s = GetSong();

if (IsValid(s))
{
    // null-forgiving operator added
    Console.WriteLine($&amp;quot;Song by Artist `{s!.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not an operator for every day use for most applications, the &lt;code&gt;null-forgiving&lt;/code&gt; operator can be very useful in resolving certain inaccurate warnings. However take care when using the operator, and only implement when sure that the compiler is incorrect. While the code itself will not throw any exceptions &lt;strong&gt;because&lt;/strong&gt; of the operator usage (it's ignored at runtime), the code could throw exceptions due to the the expression in question being &lt;code&gt;null&lt;/code&gt; - which the compiler was trying to warn about (before being manually overwritten with the operator)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving"&gt;! (null-forgiving) operator&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;125: 27-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>IEnumerable's lazy evaluation</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution</guid>
			<pubDate>Tue, 26 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When executing a method which returns &lt;em&gt;IEnumerable&lt;/em&gt;, the method body is &lt;code&gt;not execute until the result is enumerated over&lt;/code&gt;. Invoking the method will not cause any of the method code to execute, including any code before the first &lt;code&gt;yield&lt;/code&gt; in the body - not until enumeration.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ienumerable"&gt;IEnumerable&lt;/h2&gt;
&lt;p&gt;A quick summary of &lt;code&gt;IEnumerable&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; usage - when a method is defined to have a return type of IEnumberable&amp;lt;T&amp;gt;, it can be invoked and the results iterated over:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method in the foreach loop
foreach(var number in GetNumbers())
{
    Console.WriteLine(number);
}

public IEnumberable&amp;lt;int&amp;gt; GetNumbers()
{
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The great benefit of IEnumerable though, comes with its usage in conjunction with the &lt;code&gt;yield&lt;/code&gt; keyword - this is used inside the method to return a value and (temporarily) yield control to the calling iterator. Once the iteration body (&lt;em&gt;Console.WriteLine&lt;/em&gt; in our example) is complete, control is then returned back to the method, which is executed until the next &lt;code&gt;yield&lt;/code&gt; is encountered.&lt;/p&gt;
&lt;p&gt;The output for the above would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-evaluation"&gt;Lazy evaluation&lt;/h2&gt;
&lt;p&gt;In the above example we saw how the &lt;em&gt;GetNumbers&lt;/em&gt; method was called as part of the iterator (as part of the &lt;code&gt;foreach&lt;/code&gt;) - but it is also possible to invoke the method, and store the returned &lt;em&gt;IEnumerable&lt;/em&gt; for later execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method 
IEnumerable&amp;lt;int&amp;gt; numbers = GetNumbers();

// do more processing

// iterate over the IEnumerable&amp;lt;int&amp;gt; variable
foreach (var number in numbers)
{
    Console.WriteLine(number);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the same output as the previous example above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-execution"&gt;Lazy execution&lt;/h2&gt;
&lt;p&gt;The interesting part about the lazy evaluation (and the reason for this post), is that when using &lt;code&gt;lazy evaluation&lt;/code&gt;, the method body is &lt;code&gt;not executed when the method is called&lt;/code&gt;, only when it's &lt;code&gt;iterated over&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Consider the following method which returns &lt;em&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/em&gt;, but before it returns a value it will log which value is being returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; GetStringsWithLogging()
{
    Console.WriteLine(&amp;quot;Executing iteration 1&amp;quot;);
    yield return &amp;quot;Iteration 1&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 2&amp;quot;);
    yield return &amp;quot;Iteration 2&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 3&amp;quot;);
    yield return &amp;quot;Iteration 3&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 4&amp;quot;);
    yield return &amp;quot;Iteration 4&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 5&amp;quot;);
    yield return &amp;quot;Iteration 5&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is executed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine($&amp;quot;Before '{nameof(GetStringsWithLogging)}' called&amp;quot;);
var deferLogging = GetStringsWithLogging();
Console.WriteLine($&amp;quot;After '{nameof(GetStringsWithLogging)}' called&amp;quot;);

foreach (var item in deferLogging)
{
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before 'GetStringsWithLogging' called
After 'GetStringsWithLogging' called
Executing iteration 1
Iteration 1
Executing iteration 2
Iteration 2
Executing iteration 3
Iteration 3
Executing iteration 4
Iteration 4
Executing iteration 5
Iteration 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output one can see that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is &lt;code&gt;not invoked&lt;/code&gt; when it is initially called - it is only when the &lt;em&gt;deferLogging&lt;/em&gt; variable is iterated over with the &lt;em&gt;foreach&lt;/em&gt; loop, that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;My initial gut assumption with an IEnumerable method was that the body of the method in question (&lt;em&gt;GetStringsWithLogging&lt;/em&gt; here) would execute up until the first &lt;code&gt;yield&lt;/code&gt; when called, no matter if lazy or not. However working through sample examples, and understanding how the code is lowered, the deferred execution makes more sense - and I am glad my initial assumptions were incorrect.&lt;/p&gt;
&lt;p&gt;Having the ability to defer execution of the method allows for potentially long running processes which retrieve the results data (for example), to be deferred until/if actually needed (obviously all by design, I am sure) it very valuable. The &lt;em&gt;IEnumerable&lt;/em&gt; instance can be passed around between methods, and only materialized when required - instead of passing around the (potentially larger in size) materialized data, when it might not even be needed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.blog/2022/06/15/c-ienumerable-yield-return-and-lazy-evaluation/"&gt;C#: IEnumerable, yield return, and lazy evaluation&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;124: 26-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>