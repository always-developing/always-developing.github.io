<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Mon, 27 Jun 2022 04:33:09 GMT</pubDate>
		<lastBuildDate>Mon, 27 Jun 2022 04:33:09 GMT</lastBuildDate>
		<item>
			<title>Lambda vs local function performance</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/27-lambda-vs-local</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/27-lambda-vs-local</guid>
			<pubDate>Mon, 27 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;local function&lt;/code&gt; will out perform a &lt;code&gt;lambda function&lt;/code&gt; by a significant margin, which can make a different especially if the function is called from within a loop.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;The use case is straight forward: &lt;code&gt;iterate through a list of 500 integers, and if the number is larger than a supplied value (y), add it to a running total&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below we look at a number of different ways to perform the &lt;code&gt;if the number is larger than a supplied value (y)&lt;/code&gt; check, and then benchmark the performance of each technique.&lt;/p&gt;
&lt;h3 id="lambda"&gt;Lambda&lt;/h3&gt;
&lt;p&gt;The first method is to use a &lt;code&gt;lambda function&lt;/code&gt; to perform the &lt;em&gt;where&lt;/em&gt; check:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Lambda(int y)
{
    int runningTotal = 0;

    // define the lambda to compare two values
    // and return true or false based on the results
    Func&amp;lt;int, bool&amp;gt; whereFilter = x =&amp;gt; x &amp;gt; y;

    for(int i = 0; i &amp;lt; 500; i++)
    {
        // call the lambda
        if(whereFilter(i))
        {
            runningTotal += i;
        }
    }

    return runningTotal;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A lambda function is defined which compares two values, and is then invoked to compare the iteration value with the supplied value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="local-function"&gt;Local function&lt;/h3&gt;
&lt;p&gt;Next, instead of using a lambda, we will define a &lt;code&gt;local function&lt;/code&gt; to perform the &lt;em&gt;where&lt;/em&gt; check:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int LocalFunction(int y)
{
    int runningTotal = 0;

    // define the local function expression
    // with the same functionality as the above lambda
    bool whereFilter(int x) =&amp;gt; x &amp;gt; y;

    for (int i = 0; i &amp;lt; 500; i++)
    {
        // invoke the local function
        if (whereFilter(i))
        {
            runningTotal += i;
        }
    }

    return runningTotal;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A local function, as with the lambda, is defined which compares two values, and is then invoked to compare the iteration value with the supplied value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="function"&gt;Function&lt;/h3&gt;
&lt;p&gt;Next, the local function will be replaced with a normal &lt;code&gt;function&lt;/code&gt; to perform the &lt;em&gt;where&lt;/em&gt; check:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Method(int y)
{
    int runningTotal = 0;

    for (int i = 0; i &amp;lt; 500; i++)
    {
        // call the separate expression-bodied method
        if (whereFilterMethod(i, y))
        {
            runningTotal += i;
        }
    }

    return runningTotal;
}

// expression bodied method to compare two values
private bool whereFilterMethod(int x, int y) =&amp;gt; x &amp;gt; y;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method body is the same as the local function, but defined outside the method in question (&lt;em&gt;Method&lt;/em&gt; in this example).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="operation"&gt;Operation&lt;/h3&gt;
&lt;p&gt;Lastly, instead of using any variation of method, the operation will be put directly inline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Operation(int y)
{
    int runningTotal = 0;

    for (int i = 0; i &amp;lt; 500; i++)
    {
        // straight compare of the two value
        if (i &amp;gt; y)
        {
            runningTotal += i;
        }
    }

    return runningTotal;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No method defined here, just the straight comparison.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Finally let's benchmark all of the above techniques. &lt;strong&gt;BenchmarkDotNet&lt;/strong&gt; was used to benchmark each technique using two parameters, &lt;code&gt;17&lt;/code&gt; and &lt;code&gt;472&lt;/code&gt;, to give representation for the lower and upper bounds of the loop.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;y&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Lambda&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td style="text-align: right;"&gt;974.7 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.68 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12.79 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LocalFunction&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td style="text-align: right;"&gt;135.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.51 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.34 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td style="text-align: right;"&gt;136.2 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.30 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.15 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operation&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td style="text-align: right;"&gt;135.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.86 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.67 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;td style="text-align: right;"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lambda&lt;/td&gt;
&lt;td&gt;472&lt;/td&gt;
&lt;td style="text-align: right;"&gt;854.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.61 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.99 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LocalFunction&lt;/td&gt;
&lt;td&gt;472&lt;/td&gt;
&lt;td style="text-align: right;"&gt;255.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.85 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.42 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;472&lt;/td&gt;
&lt;td style="text-align: right;"&gt;263.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.95 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.76 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operation&lt;/td&gt;
&lt;td&gt;472&lt;/td&gt;
&lt;td style="text-align: right;"&gt;252.2 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.00 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.74 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As one can see from the results, a lambda is &lt;code&gt;3-6x times&lt;/code&gt; slower than any of the other methods.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When calling the &lt;code&gt;lambda/local function/function/operation&lt;/code&gt; once off in the hot path, there probably won't be any noticeable difference depending on which method is used.&lt;br /&gt;
However if used in a loop (such as in the example), consider moving away from a &lt;code&gt;lambda&lt;/code&gt; to any of the other techniques to see an improvement in performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leveluppp.ghost.io/content/images/size/w1000/2021/07/lambda_tips1-1.png"&gt;Lambda Optimizations Tips 1&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;104: 27-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Method currying basics in C#</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/24-curry-basics</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/24-curry-basics</guid>
			<pubDate>Fri, 24 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Method Currying&lt;/code&gt; is entails breaking a single method (which takes multiple parameters), into a sequence of single-parameter methods.&lt;br /&gt;
For example, instead of a method which takes 3 parameters &lt;code&gt;method(a, b, c)&lt;/code&gt;, currying the method would instead turn it into &lt;code&gt;method(a)(b)(c)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This offers a different syntax, which allows for complex composite methods to be built up from simpler methods. Currying is more commonly used in functional programming, but can be utilized in C#.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="currying"&gt;Currying&lt;/h2&gt;
&lt;p&gt;The below examples contain a &lt;em&gt;very simple&lt;/em&gt; example of currying, but it will demonstrate the basics of how currying a method will break it down into a sequence of single argument methods.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="multiply-method"&gt;Multiply method&lt;/h3&gt;
&lt;p&gt;Let's consider a method which &lt;code&gt;multiples three integers together&lt;/code&gt;, and returns the result. This can be written as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int Multiply(int a, int b, int c)
{
    return a * b * c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far so good.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="multiply-lambda"&gt;Multiply Lambda&lt;/h3&gt;
&lt;p&gt;This &lt;em&gt;Multiply&lt;/em&gt; method, can also be written as a &lt;code&gt;lambda Func&lt;/code&gt; instead of a full method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, int, int, int&amp;gt; multiply = (a, b, c) =&amp;gt; a * b * c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we start with the currying process.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="multiply-curry-part-1"&gt;Multiply Curry part 1&lt;/h3&gt;
&lt;p&gt;As mentioned, &lt;code&gt;currying&lt;/code&gt; entails breaking down a single method, with three parameters in this example, into a sequence of single-parameters methods. Let's start small and build on it until we have the desired result.&lt;/p&gt;
&lt;p&gt;First, we'll change the above &lt;em&gt;multiply&lt;/em&gt; lambda to only take one argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, Func&amp;lt;int, int, int&amp;gt;&amp;gt; curryMultipleBase = a =&amp;gt; ((b, c) =&amp;gt; a * b * c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks a bit complicated, but basically the initial lambda has been updated to instead of having three arguments, it now &lt;code&gt;takes one argument, and returns a Func&amp;lt;&amp;gt;, which takes 2 arguments, and returns an int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Overall, the entire composition of methods still takes 3 parameters. This can now be invoked as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, Func&amp;lt;int, int, int&amp;gt;&amp;gt; curryMultipleBase = a =&amp;gt; ((b, c) =&amp;gt; a * b * c);

// invoke the lambda, passing in one value
// getting back a lambda which takes two arguments
Func&amp;lt;int, int, int&amp;gt; result1 = curryMultipleBase(2);

// invoke the lambda which takes two arguments
// and returns an int
int result2 = result1(3, 4);

Console.WriteLine(result2);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or more succinctly expressed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, Func&amp;lt;int, int, int&amp;gt;&amp;gt; curryMultipleBase = a =&amp;gt; ((b, c) =&amp;gt; a * b * c);

// instead of having the intermediate Func&amp;lt;int, int, int&amp;gt;
// just invoke the result directly
int result = curryMultipleBase(2)(3, 4);
Console.WriteLine(result);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the above yield a result of &lt;code&gt;24&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We've converted a portion to be single parameter, but a portion still has 2 parameters.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="multiply-curry-part-2"&gt;Multiply Curry part 2&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;curryMultipleBase&lt;/em&gt; returns a lambda, which has two parameters - the objective to too only have single parameter methods. Let's convert the two parameter Func into two single parameter Func's:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Old
Func&amp;lt;int, Func&amp;lt;int, int, int&amp;gt;&amp;gt; curryMultipleBase = a =&amp;gt; ((b, c) =&amp;gt; a * b * c);

// New
Func&amp;lt;int, Func&amp;lt;int, Func&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; curryMultiple = a =&amp;gt; (b =&amp;gt; c =&amp;gt; a * b * c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of returning a Func which takes 2 arguments and returns an int, the lambda now returns a &lt;code&gt;Func, which takes 1 parameter, and returns a Func which takes one parameter and returns an int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The new version of the lambda can be invoked as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, Func&amp;lt;int, Func&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; curryMultiple = a =&amp;gt; (b =&amp;gt; (c =&amp;gt; a * b * c));

Func&amp;lt;int, Func&amp;lt;int, int&amp;gt;&amp;gt; result1 = curryMultiple(2);
Func&amp;lt;int, int&amp;gt; result2 = result1(3);
int result3 = result2(3);

Console.WriteLine(result3);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or more succinctly expressed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Func&amp;lt;int, Func&amp;lt;int, int, int&amp;gt;&amp;gt; curryMultipleBase = a =&amp;gt; ((b, c) =&amp;gt; a * b * c);

// instead of having the intermediate Func(s)
// just invoke the result directly
int result = curryMultiple(2)(3)(4);
Console.WriteLine(result);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it! We've successfully converted the initial three parameter method, into a sequence of one parameter methods - &lt;code&gt;int result = curryMultiple(2)(3)(4);&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="logging-example"&gt;Logging example&lt;/h3&gt;
&lt;p&gt;Suppose we have to call a &lt;em&gt;Log&lt;/em&gt; method, with a message and the type of message to log (Error, Warning or Information). There are a number of techniques to achieve this, especially if the method is called often.&lt;/p&gt;
&lt;p&gt;The method could be called directly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    Log(&amp;quot;error&amp;quot;, &amp;quot;An Exception occurred&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;quot;issue&amp;quot; with this approach is that the constant type parameter &amp;quot;error&amp;quot; (or &amp;quot;warning&amp;quot; or &amp;quot;info&amp;quot;) is repeated with every call.&lt;/p&gt;
&lt;p&gt;We could create an &lt;code&gt;Action&lt;/code&gt; for each log type, which can then be reused:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Action&amp;lt;string&amp;gt; logError = message =&amp;gt; Log(&amp;quot;error&amp;quot;, message);
Action&amp;lt;string&amp;gt; logWarning = message =&amp;gt; Log(&amp;quot;warning&amp;quot;, message);
Action&amp;lt;string&amp;gt; logInfo = message =&amp;gt; Log(&amp;quot;info&amp;quot;, message);

logWarning(&amp;quot;Validation failed, skipping record&amp;quot;);

// logWarning can be reused
logWarning(&amp;quot;An exception occurred, but the record was saved successfully&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The constant type parameter is now only specified once, instead of once per call.&lt;/p&gt;
&lt;p&gt;Yet another option, is too make use of &lt;code&gt;method currying&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Action&amp;lt;string&amp;gt; CurryLog(string type) =&amp;gt; message =&amp;gt; Log(type, message);

var curryLogInfo = CurryLog(&amp;quot;info&amp;quot;);
curryLogInfo(&amp;quot;Record processed successfully&amp;quot;);

// curryLogInfo can be reused
curryLogInfo(&amp;quot;Saving record to database&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;currying&lt;/code&gt; approach is very similar to the &lt;code&gt;Action&lt;/code&gt; technique mentioned above, but it comes down to syntax preference.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;I found the idea of &lt;code&gt;method currying&lt;/code&gt; very interesting and intriguing, but I'm not sure of its benefits in C# over other techniques. Perhaps a preference for the syntax style is enough of a benefit to use it instead of the &amp;quot;traditional&amp;quot; way.&lt;/p&gt;
&lt;p&gt;Either way though, its useful to have knowledge of this technique, just incase it offers a unique solution to a problem in the future.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://weblogs.asp.net/dixin/lambda-calculus-via-c-sharp-1-fundamentals-closure-currying-and-partial-application"&gt;Currying and partial application&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://towardsdatascience.com/what-is-currying-in-programming-56fd57103431"&gt;What Is Currying in Programming?&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;103: 24-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Visual Studio layouts</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/23-visual-studio-layouts</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/23-visual-studio-layouts</guid>
			<pubDate>Thu, 23 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Visual Studio provides the functionality to configure different &lt;code&gt;layouts&lt;/code&gt; and switch between, based on the type of project or work being done.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;h3 id="default"&gt;Default&lt;/h3&gt;
&lt;p&gt;Creating and then switching between different layouts is as easy as clicking a button.&lt;/p&gt;
&lt;p&gt;For me, the first step is to create a &lt;code&gt;Default&lt;/code&gt; layout - a general purpose layout, suitable for most type of development work I do.&lt;/p&gt;
&lt;p&gt;This entails configuring the panes and windows in Visual Studio to have the desired layout, then selecting the &lt;code&gt;Window -&amp;gt; Save Window Layout&lt;/code&gt; menu option. A prompt will appear to give the layout a name - &lt;code&gt;Default&lt;/code&gt; for me.&lt;/p&gt;
&lt;p&gt;The actual panes and layout is unimportant, but what is important is what you have something which works for you. My default:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/default.png" alt="Default layout"&gt;&lt;/p&gt;
&lt;p&gt;Now that there is a default saved, you can easily move things around and at the click of a button go back to the default. By clicking &lt;code&gt;Window -&amp;gt; Apply Window Layout -&amp;gt; Default&lt;/code&gt; (or Ctrl-Alt-1), the panes and windows are restored to the &lt;code&gt;Default&lt;/code&gt; layout.&lt;/p&gt;
&lt;p&gt;Let's create another layout and switch between them.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="analyzer"&gt;Analyzer&lt;/h3&gt;
&lt;p&gt;When working with &lt;a href="https://alwaysdeveloping.net/p/analyzer-explained"&gt;Roslyn Analyzers&lt;/a&gt;, the &lt;em&gt;Syntax Visualizer&lt;/em&gt; is an critical window, so one would want this to be prominent.&lt;/p&gt;
&lt;p&gt;I have update the layout to be as follows below, and saved it as my &lt;code&gt;RoslynAnalyzer&lt;/code&gt; layout. As you can see, the &lt;em&gt;Syntax Visualizer&lt;/em&gt; is now displayed on the right, using a good portion of screen real estate:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/Analyzer.png" alt="Analyzer layout"&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Window -&amp;gt; Apply Window Layout -&amp;gt; X&lt;/code&gt; menu option (or Ctrl-Alt-1 and Ctrl-Alt-2) can now be used to easily switch between the layouts at the click of a button.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="design"&gt;Design&lt;/h3&gt;
&lt;p&gt;Another example is when doing design work which involves the &lt;em&gt;Toolbox&lt;/em&gt;, one might want as much space to use the designer:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/Design.png" alt="Design layout"&gt;&lt;/p&gt;
&lt;p&gt;Here the right panel has been made to "auto hide" to give as much space as possible to the middle pane for design (this could also apply to code as well, if thats what works for you)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The ability to customize and personalize the layout in Visual Studio can definitely lead to more productivity and a sense of comfort with one's tools. The ability to customize it even more based on the &lt;em&gt;type of work&lt;/em&gt; just increases that productivity even more!&lt;/p&gt;
&lt;p&gt;Some additional scenarios for when one might want a different, custom layout:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Projects which use the database related windows vs non-database projects&lt;/li&gt;
&lt;li&gt;Projects which contain unit tests (and the usage of the related windows) vs projects with no unit tests&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/ide/customizing-window-layouts-in-visual-studio?view=vs-2022#create-and-save-custom-layouts"&gt;Create and save custom layouts&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;102: 23-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Converting ExpandObject</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/22-expando-conversion</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/22-expando-conversion</guid>
			<pubDate>Wed, 22 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ExpandoObject&lt;/code&gt; class implements &lt;code&gt;IEnumberable&lt;/code&gt; and &lt;code&gt;IDictionary&lt;/code&gt; - this means its fields can be iterated over, and that it can be converted to, and operated on as a Dictionary.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="expandoobject"&gt;ExpandoObject&lt;/h2&gt;
&lt;p&gt;First some information on the &lt;code&gt;ExpandoObject&lt;/code&gt; class - it enables one to add and deleted members of its instance at runtime.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic infoObject = new ExpandoObject();
infoObject.Name = &amp;quot;Always Developing&amp;quot;;
infoObject.Url = &amp;quot;www.alwaysdeveloping.net&amp;quot;;

Console.WriteLine(infoObject.Name);
Console.WriteLine(infoObject.Url);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, the properties &lt;em&gt;Name&lt;/em&gt; and &lt;em&gt;Age&lt;/em&gt; are dynamically added at runtime. Any number of properties, of any type can dynamically be added.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ExpandoObject&lt;/code&gt; can also have methods (Action and Func) added dynamically, and then invoked:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic infoObject = new ExpandoObject();
infoObject.Name = &amp;quot;Always Developing&amp;quot;;
infoObject.Url = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
infoObject.Visitors = 0;
infoObject.IncreaseVisitorCount = (Action)(() =&amp;gt; { infoObject.Visitors++; });
infoObject.GetVisitorCount = (Func&amp;lt;int&amp;gt;)(() =&amp;gt; { return infoObject.Visitors; });

infoObject.IncreaseVisitorCount();
infoObject.IncreaseVisitorCount();

Console.WriteLine(infoObject.GetVisitorCount());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;IncreaseVisitorCount&lt;/em&gt; Action and &lt;em&gt;GetVisitorCount&lt;/em&gt; Func are dynamically added, and then invoked.&lt;/p&gt;
&lt;p&gt;The output of the above being &lt;code&gt;2&lt;/code&gt;, as expected, as the &lt;em&gt;IncreaseVisitorCount&lt;/em&gt; method is invoked twice.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ienumerable-conversion"&gt;IEnumerable conversion&lt;/h2&gt;
&lt;p&gt;As &lt;code&gt;ExpandoObject&lt;/code&gt; implement IEnumberable, specifically &lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, object?&amp;gt;&amp;gt;&lt;/code&gt; and can be iterated over, with a &lt;code&gt;KeyValuePair&amp;lt;string, object?&amp;gt;&lt;/code&gt; item returned for each iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic infoObject = new ExpandoObject();
infoObject.Name = &amp;quot;Always Developing&amp;quot;;
infoObject.Url = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
infoObject.Visitors = 0;
infoObject.IncreaseVisitorCount = (Action)(() =&amp;gt; { infoObject.Visitors++; });
infoObject.GetVisitorCount = (Func&amp;lt;int&amp;gt;)(() =&amp;gt; { return infoObject.Visitors; });

// prop is of type KeyValuePair&amp;lt;string, object?&amp;gt;
foreach (var prop in infoObject)
{
    Console.WriteLine($&amp;quot;Key: '{prop.Key}' with value '{prop.Value}'&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, iterating over &lt;em&gt;infoObject&lt;/em&gt; will return each property dynamically added to the &lt;code&gt;ExpandoObject&lt;/code&gt; instance, including methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Key: 'Name' with value 'Always Developing'
Key: 'Url' with value 'www.alwaysdeveloping.net'
Key: 'Visitors' with value '2'
Key: 'IncreaseVisitorCount' with value 'System.Action'
Key: 'GetVisitorCount' with value 'System.Func`1[System.Int32]'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="dictionary-conversion"&gt;Dictionary conversion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExpandoObject&lt;/code&gt; also implements &lt;code&gt;IDictionary&amp;lt;string, object?&amp;gt;&lt;/code&gt;, so can directly be assigned to this type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;dynamic infoObject = new ExpandoObject();
infoObject.Name = &amp;quot;Always Developing&amp;quot;;
infoObject.Url = &amp;quot;www.alwaysdeveloping.net&amp;quot;;
infoObject.Visitors = 0;
infoObject.IncreaseVisitorCount = (Action)(() =&amp;gt; { infoObject.Visitors++; });
infoObject.GetVisitorCount = (Func&amp;lt;int&amp;gt;)(() =&amp;gt; { return infoObject.Visitors; });

// cast ExpandoObject to IDictionary&amp;lt;string, object?&amp;gt;
IDictionary&amp;lt;string, object?&amp;gt; dictionary = infoObject;
foreach (var item in dictionary)
{
    Console.WriteLine($&amp;quot;Key: '{item.Key}' with value '{item.Value}'&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above the same as the first example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Key: 'Name' with value 'Always Developing'
Key: 'Url' with value 'www.alwaysdeveloping.net'
Key: 'Visitors' with value '2'
Key: 'IncreaseVisitorCount' with value 'System.Action'
Key: 'GetVisitorCount' with value 'System.Func`1[System.Int32]'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Casting to &lt;code&gt;Dictionary&lt;/code&gt; allows one to check if a property/key has been added to the &lt;code&gt;ExpandoObject&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IDictionary&amp;lt;string, object?&amp;gt; dictionary = infoObject;
foreach (var item in dictionary)
{
    Console.WriteLine($&amp;quot;Key: '{item.Key}' with value '{item.Value}'&amp;quot;);
}

// This would result in an exception
// var value = infoObject[&amp;quot;Name&amp;quot;];

// On a dictionary, this is allowed
if (dictionary.ContainsKey(&amp;quot;Name&amp;quot;))
{
    Console.WriteLine(dictionary[&amp;quot;Name&amp;quot;]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small, but useful piece of knowledge to be aware of if working with &lt;code&gt;ExpandoObject&lt;/code&gt; as the ability to easily convert to other types opens up new operations and possibilities on the instance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.code4it.dev/csharptips/expandoobject-to-dictionary"&gt;C# Tip: Convert ExpandoObjects to IDictionary&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;101: 22-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>TryAddEnumerable to configure dependency injection</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/21-tryaddenumerable</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/21-tryaddenumerable</guid>
			<pubDate>Tue, 21 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using the C# dependency injection container, the:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Add&lt;/code&gt; methods (&lt;em&gt;AddSingleton&lt;/em&gt;, &lt;em&gt;AddScoped&lt;/em&gt;, &lt;em&gt;AddTransient&lt;/em&gt;) will always add the interface and implementation to the container, even if it results in duplicate registrations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TryAdd&lt;/code&gt; methods (&lt;em&gt;TryAddSingleton&lt;/em&gt;, &lt;em&gt;TryAddScoped&lt;/em&gt;, &lt;em&gt;TryAddTransient&lt;/em&gt;) will only add the interface and implementation to the container if the &lt;em&gt;interface&lt;/em&gt; has not already been registered&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Today we are looking specifically at &lt;code&gt;TryAddEnumerable&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TryAddEnumerable&lt;/code&gt; will only add the interface and implementation to the container if the &lt;em&gt;combination of the interface and implementation&lt;/em&gt; has not already been registered&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="endpoint-example"&gt;Endpoint example&lt;/h2&gt;
&lt;p&gt;In the three examples below, we have a simple setup, with an interface and a couple of implementations of the interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IServiceInterface { }

public class ServiceImplementationOne: IServiceInterface { }

public class ServiceImplementationTwo : IServiceInterface { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then a minimal endpoint which has &lt;em&gt;IEnumerable&amp;lt;IServiceInterface&amp;gt;&lt;/em&gt; injected, and returns all implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint&amp;quot;, (IEnumerable&amp;lt;IServiceInterface&amp;gt; service) =&amp;gt;
{
    return service.Select(s =&amp;gt; s.GetType().Name);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="add-methods"&gt;Add methods&lt;/h3&gt;
&lt;p&gt;First, lets look at the behavior of the &lt;em&gt;Add&lt;/em&gt; methods. These methods will always add the interface and implementation, even if its already been added.&lt;/p&gt;
&lt;p&gt;In the dependency injection configuration, in this example, a duplicate implementation of &lt;em&gt;ServiceImplementationTwo&lt;/em&gt; is added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.AddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationOne));
builder.Services.AddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo));
builder.Services.AddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo));

var app = builder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The endpoint will return the following - &lt;em&gt;ServiceImplementationTwo&lt;/em&gt; has been added to the dependency injection container twice, and is therefor the duplicate was injected into and returned from the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
  &amp;quot;ServiceImplementationOne&amp;quot;,
  &amp;quot;ServiceImplementationTwo&amp;quot;,
  &amp;quot;ServiceImplementationTwo&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="tryadd-methods"&gt;TryAdd methods&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;TryAdd&lt;/em&gt; methods operate differently, and will ensure that only one implementation of the interface is added to the container.&lt;/p&gt;
&lt;p&gt;In the dependency injection configuration, in this example, we use the same configuration as in the first example, but with the &lt;em&gt;TryAddTransient&lt;/em&gt; method instead of the &lt;em&gt;AddTransient&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

builder.Services.TryAddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationOne));
builder.Services.TryAddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo));
builder.Services.TryAddTransient(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo));

var app = builder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The endpoint will return the following - only the first implementation of &lt;em&gt;IServiceInterface&lt;/em&gt; added to the dependency injection container is registered.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
  &amp;quot;ServiceImplementationOne&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neither of the two registrations of &lt;em&gt;ServiceImplementationTwo&lt;/em&gt; are actioned, because an implementation of &lt;em&gt;IServiceInterface&lt;/em&gt; (ServiceImplementationOne) was already added.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tryaddenumerable-method"&gt;TryAddEnumerable method&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;TryAddEnumerable&lt;/em&gt; method is used slightly differently - this method takes a &lt;em&gt;ServiceDescriptor&lt;/em&gt; instance, and not a interface and implementation directly.&lt;/p&gt;
&lt;p&gt;In the dependency injection configuration, in this example, we use the the same configuration as in the above example, with a slightly different setup. We define three instances of &lt;em&gt;ServiceDescriptor&lt;/em&gt;, two of them are describing implementations of &lt;em&gt;ServiceImplementationTwo&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

var descriptorOne = new ServiceDescriptor(typeof(IServiceInterface), 
    typeof(ServiceImplementationOne), ServiceLifetime.Transient);
var descriptorTwo = new ServiceDescriptor(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo), ServiceLifetime.Transient);
var descriptorThree = new ServiceDescriptor(typeof(IServiceInterface), 
    typeof(ServiceImplementationTwo), ServiceLifetime.Transient);

builder.Services.TryAddEnumerable(new[] { descriptorOne, descriptorTwo, descriptorThree });

var app = builder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The endpoint will return the following - only the first implementation of each unique &lt;em&gt;interface&lt;/em&gt; + &lt;em&gt;implementation&lt;/em&gt; combination:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
  &amp;quot;ServiceImplementationOne&amp;quot;,
  &amp;quot;ServiceImplementationTwo&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;TryAddEnumerable&lt;/em&gt; method is incredible useful, especially as a library author where your library might need to add items to the dependency injection container, but without knowing if another library has already added it. &lt;em&gt;TryAddEnumerable&lt;/em&gt; can be used to ensure that the dependency injection container is not &amp;quot;polluted&amp;quot; with duplicate identical implementations, which could potentially cause issues.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=iQ8cNI7a6mk"&gt;The .NET dependency injection methods you are not using&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;100: 21-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Binary and hexadecimal conversion</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/20-base-conversion</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/20-base-conversion</guid>
			<pubDate>Mon, 20 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Convert&lt;/code&gt; class can be used to convert any integer value to it's corresponding value of a &lt;code&gt;different base&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Binary&lt;/code&gt; (base 2), &lt;code&gt;Octal&lt;/code&gt; (base 8), &lt;code&gt;Decimal&lt;/code&gt; (base 10) and &lt;code&gt;Hexadecimal&lt;/code&gt; (base 16) are supported.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="convert-class"&gt;Convert class&lt;/h2&gt;
&lt;p&gt;Using the &lt;code&gt;Convert&lt;/code&gt; class to perform the conversion is incredibly simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var intValue = 642;

// use the ToString method, specifying the new base
var binary = Convert.ToString(intValue, 2);
var octal = Convert.ToString(intValue, 8);
var hex = Convert.ToString(intValue, 16);

Console.WriteLine(binary);
Console.WriteLine(octal);
Console.WriteLine(hex);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;1010000010
1202
282
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Negative values are also supported:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var intValue = 642;

// use the ToString method, specifying the new base
var binaryNeg = Convert.ToString(intValue * 1, 2);
var octalNeg = Convert.ToString(intValue * -1, 8);
var hexNeg = Convert.ToString(intValue * -1, 16);

Console.WriteLine(binaryNeg);
Console.WriteLine(octalNeg);
Console.WriteLine(hexNeg);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;11111111111111111111110101111110
37777776576
fffffd7e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's all there is to it - simple and occasionally useful!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;In my almost 20 years of programming, I don't think I've ever had to perform these kinds of conversions (outside of assignments at university), so this functionality is probably not useful for every day development for most applications - however when the need does arise, it's useful to know it can be easily implemented.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1523685323875635200"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;99: 20-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Sortable Guids using NewId</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/17-sortable-guids</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/17-sortable-guids</guid>
			<pubDate>Fri, 17 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Often &lt;code&gt;Guids&lt;/code&gt; are used as database primary keys, as they are "guaranteed" to be unique and random or un-guessable. However one drawback of them, is that due to their uniqueness there is no ordering, which leads to &lt;a href="https://www.mssqltips.com/sqlservertip/4331/sql-server-index-fragmentation-overview/"&gt;index fragmentation&lt;/a&gt;, an increase in database size, as well as a potential performance degradation.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.nuget.org/packages/NewId/"&gt;NewId&lt;/a&gt; library, can assist with this, by generating unique, but sortable &lt;code&gt;Guids&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="guid"&gt;Guid&lt;/h2&gt;
&lt;p&gt;In C#, &lt;code&gt;Guid's&lt;/code&gt; are mostly created using the &lt;code&gt;Guid.NewGuid&lt;/code&gt; method (there are other ways, such as using this &lt;a href="https://alwaysdeveloping.net/05/10-deterministic-guid"&gt;technique to create a deterministic Guid&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;Guid.NewGuid&lt;/code&gt; to created 10 &lt;code&gt;Guids&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;for (int i = 0; i &amp;lt; 10; i++)
{
    var id = Guid.NewGuid();
    Console.WriteLine(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see, as by design, the values of the 10 &lt;code&gt;Guids&lt;/code&gt; are random and are unrelated to one another:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;7620e975-26e6-46ca-876d-dff93495ad57
24751db7-6372-4b8c-94fd-2ae3ad92f926
c8791bf1-f85a-4b12-81e7-18cab1516cb9
5a78214c-adb6-4d59-8921-bca021b50b22
e46a7e0e-faf4-4af3-bd2e-39a1102af894
807ad5c4-7314-4ebb-8914-3b9a0f38386f
ca536113-ea85-41a6-844f-891d8aab40e4
44cf6ff1-89da-458f-8f69-57d4c68c73cf
b18e4911-e439-4506-9f23-b5017ce82d55
225557ab-a5eb-48e1-b04e-7a72696e85ca
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned, having unique values is the desired goal, but having them be completely random can cause issues if they are being used as database primary keys.&lt;br&gt;
The non-sequential nature of this approach leads to index fragmentation, but also means records cannot be sorted by this field, and requires another field (e.g. DateCreated) to be sortable.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="newid"&gt;NewId&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://www.nuget.org/packages/NewId/"&gt;Newid&lt;/a&gt; library addresses these issues, by creating unique, semi-random, sortable &lt;code&gt;Ids&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The library is very easy to use, with the &lt;code&gt;NewId.Next()&lt;/code&gt; method used to produce an &lt;code&gt;Id&lt;/code&gt;. It is also possible to set a start &lt;code&gt;Id&lt;/code&gt;, or a start byte-array, from quick subsequent &lt;code&gt;Ids&lt;/code&gt; are based.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;NewId&lt;/code&gt; to created 10 &lt;code&gt;Ids&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;for (int i = 0; i &amp;lt; 10; i++)
{
    var newId = NewId.Next().ToGuid();
    Console.WriteLine(newId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 10 unique, but sortable &lt;code&gt;Guids&lt;/code&gt; are as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;df1d0000-0a83-7cd3-fdf2-08da40cae578
df1d0000-0a83-7cd3-467a-08da40cae579
df1d0000-0a83-7cd3-48ba-08da40cae579
df1d0000-0a83-7cd3-49de-08da40cae579
df1d0000-0a83-7cd3-4aba-08da40cae579
df1d0000-0a83-7cd3-4b95-08da40cae579
df1d0000-0a83-7cd3-4c93-08da40cae579
df1d0000-0a83-7cd3-4d6e-08da40cae579
df1d0000-0a83-7cd3-4e8b-08da40cae579
df1d0000-0a83-7cd3-4f5c-08da40cae579
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the &lt;code&gt;Guids&lt;/code&gt; are unique and sorted, but don't look entirely random - this is because some parts are in fact not entirely random.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Id&lt;/code&gt; generated is made up of three portions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df1d0000-0a83-7cd3&lt;/code&gt;: this portion is the same for all &lt;code&gt;Ids&lt;/code&gt; generated by the same process/worker Id. This will be constant on a particular machine, but will differ PC to PC.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4f5c&lt;/code&gt;: this portion will change with each &lt;code&gt;Id&lt;/code&gt; generated.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;08da40cae579&lt;/code&gt;: this portion increments, but slowly and not for every &lt;code&gt;Id&lt;/code&gt; generated (as is evident in the the above example)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are three sources of information are used to construct the &lt;code&gt;Id&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;process/worker Id&lt;/code&gt;: unique and constant for each PC&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;timestamp&lt;/code&gt;: by definition, incrementing and thus orderable&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;sequence&lt;/code&gt;: this is an incrementing Id&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generating a &lt;code&gt;NewId&lt;/code&gt; is just as easy as generating a &lt;code&gt;Guid&lt;/code&gt; directly - and are directly convertible to a &lt;code&gt;Guid&lt;/code&gt; (as was done in the above code example)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;NewId&lt;/code&gt; is not suitable for every situation - in some cases you would want the generated &lt;code&gt;Id&lt;/code&gt; to be completely random and un-guessable. However, if you are using &lt;code&gt;Guids&lt;/code&gt; as database primary keys, consider using &lt;code&gt;NewId&lt;/code&gt; to generate the &lt;code&gt;Ids&lt;/code&gt; instead of &lt;em&gt;Guid.NewGuid&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I appreciate the fact that, while the library does generate its own type (also called &lt;em&gt;NewId&lt;/em&gt;), this type is effectively a &lt;code&gt;Guid&lt;/code&gt;, and can easy be converted to one. This means that any underlying entities which currently use a &lt;code&gt;Guid&lt;/code&gt; do not need to be updated with a new type, or reference a third party package - they can be kept "clean".&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.nuget.org/packages/NewId/"&gt;NewId&lt;/a&gt;&lt;br&gt;
&lt;a href="https://andrewlock.net/generating-sortable-guids-using-newid/"&gt;Generating sortable Guids using NewId&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;98: 17-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>The cost of Nullable variables</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/16-nullable-performance</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/16-nullable-performance</guid>
			<pubDate>Thu, 16 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The ability to mark a variable as &lt;code&gt;Nullable&lt;/code&gt; (using the ? syntax) is a useful feature in C#, but does come with a large (relative to non-nullable) performance cost.&lt;/p&gt;
&lt;p&gt;Today we'll have a look at some simple benchmarks and how making a variable nullable impacts performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmark"&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;The benchmarks were be run on .NET6, using BenchmarkDotNet.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Benchmark(Baseline =true)]
[Arguments(1, 2)]
[Arguments(2, 4)]
[Arguments(0, 0)]
public void NotNullableParameters(int a, int b)
{
    int result = 0;

    for (int i = 0; i &amp;lt; 1000; i++)
    {
        result += a * b;
    }
}

[Benchmark]
[Arguments(1, 2)]
[Arguments(2, 4)]
[Arguments(0, 0)]
[Arguments(null, null)]
public void NullableParameters(int? a, int? b)
{
    int? result = 0;

    for (int i = 0; i &amp;lt; 1000; i++)
    {
        result += a * b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logic of each method is the same, and is straight-forward - multiple two int values, 1000 times, and keep a running total of the result.&lt;/p&gt;
&lt;p&gt;The first benchmark will us non-nullable int values, while the second will use nullable int values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="results"&gt;Results&lt;/h2&gt;
&lt;p&gt;Running the benchmarks yields the following results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NullableParameters&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,196.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.79 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20.38 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;?&lt;/td&gt;
&lt;td style="text-align: right;"&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NotNullableParameters&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style="text-align: right;"&gt;240.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.53 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.13 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NullableParameters&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,051.0 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.70 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.45 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.37&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.06&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NotNullableParameters&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style="text-align: right;"&gt;241.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.74 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.50 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NullableParameters&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,054.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.60 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.18 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.37&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.07&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NotNullableParameters&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style="text-align: right;"&gt;240.8 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.92 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.73 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NullableParameters&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,053.6 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.73 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.81 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.38&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.06&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In all cases, the &lt;code&gt;non-nullable version is approximately 4.4x faster than the nullable version&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Bear in mind, this is measured in nano-seconds, so probably won't make a material different to performance, unless the logic is computational heavy.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lowered-code"&gt;Lowered code&lt;/h2&gt;
&lt;p&gt;Using &lt;a href="https://sharplab.io/"&gt;sharplab.io&lt;/a&gt; to have a look at the lowered code, there a number of additional checks performed with the nullable version, all of which adds to the performance difference.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;non-nullable&lt;/code&gt; version is lowered to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void NotNullableParameters(int a, int b)
{
    int num = 0;
    int num2 = 0;
    while (num2 &amp;lt; 1000)
    {
        num += a * b;
        num2++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While the &lt;code&gt;nullable&lt;/code&gt; version is lowered to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void NullableParameters(Nullable&amp;lt;int&amp;gt; a, Nullable&amp;lt;int&amp;gt; b)
{
    Nullable&amp;lt;int&amp;gt; num = 0;
    int num2 = 0;
    while (num2 &amp;lt; 1000)
    {
        Nullable&amp;lt;int&amp;gt; num3 = num;
        Nullable&amp;lt;int&amp;gt; num4 = a;
        Nullable&amp;lt;int&amp;gt; num5 = b;
        Nullable&amp;lt;int&amp;gt; num6 = ((num4.HasValue &amp;amp; num5.HasValue) ? 
            new Nullable&amp;lt;int&amp;gt;(num4.GetValueOrDefault() * num5.GetValueOrDefault()) : 
            null);
        num = ((num3.HasValue &amp;amp; num6.HasValue) ? 
            new Nullable&amp;lt;int&amp;gt;(num3.GetValueOrDefault() + num6.GetValueOrDefault()) : 
            null);
        num2++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As with most things, there is a trade-off, in this case - the convenience of nullable types vs the performance impact their usage brings.&lt;/p&gt;
&lt;p&gt;The performance penalty when using nullable types is measured in nano-seconds, and for the most part won't have any noticeable impact on performance of the application. However if a large number of operations are being performed on nullable types, and performance is to be improved, then one can look at converting the nullable types to non-nullable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leveluppp.ghost.io/content/images/size/w1000/2021/12/nullable_b.png"&gt;What is the cost of Nullable in .NET&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;97: 16-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Creating objects without calling the constructor</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/15-get-uninitialized-object</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/15-get-uninitialized-object</guid>
			<pubDate>Wed, 15 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;RuntimeHelpers.GetUninitializedObject&lt;/code&gt; method can be used to create an instance of an object, without calling its constructor or property initializers.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="example-class"&gt;Example class&lt;/h3&gt;
&lt;p&gt;Consider the following simple &lt;em&gt;Person&lt;/em&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Person
{
    public string Name { get; } = &amp;quot;(not set)&amp;quot;;

    public int Age { get;  }

    public Person(int age)
    {
        Age = age;
    }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important things to note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One constructor which explicitly sets both properties&lt;/li&gt;
&lt;li&gt;One constructor which only explicitly sets the age&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;Name&lt;/em&gt; property has an initializer, which sets the value if not explicitly set&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="normal-initialization"&gt;Normal initialization&lt;/h3&gt;
&lt;p&gt;First let's look at &amp;quot;normal&amp;quot; object initializations - two instances of the &lt;em&gt;Person&lt;/em&gt; class will be created, using the two different constructors:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var p1 = new Person(&amp;quot;Dave&amp;quot;, 46);
var p2 = new Person(47);

Console.WriteLine($&amp;quot;p1 has a name of '{p1.Name}' and an age of {p1.Age}&amp;quot;);
Console.WriteLine($&amp;quot;p2 has a name of '{p2.Name}' and an age of {p2.Age}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the first instance, both properties are set, in the second instance only the age is (explicitly) set.&lt;/p&gt;
&lt;p&gt;The output is then as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;p1 has a name of 'Dave' and an age of 46
p2 has a name of '(not set)' and an age of 47
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you might have expected, &lt;em&gt;p1&lt;/em&gt; outputs both values passed into the constructor, which &lt;em&gt;p2&lt;/em&gt; outputs the &lt;em&gt;Age&lt;/em&gt; specified, and the default initialization value for the &lt;em&gt;Name&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="getuninitializedobject"&gt;GetUninitializedObject&lt;/h3&gt;
&lt;p&gt;Next, we'll look at the &lt;code&gt;RuntimeHelpers.GetUninitializedObject&lt;/code&gt; method, which is part of the &lt;code&gt;System.Runtime.CompilerServices&lt;/code&gt; namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using System.Runtime.CompilerServices;

var p1 = new Person(&amp;quot;Dave&amp;quot;, 46);
var p2 = new Person(47);
var p3 = (Person)RuntimeHelpers.GetUninitializedObject(typeof(Person));

Console.WriteLine($&amp;quot;p1 has a name of '{p1.Name}' and an age of {p1.Age}&amp;quot;);
Console.WriteLine($&amp;quot;p2 has a name of '{p2.Name}' and an age of {p2.Age}&amp;quot;);
Console.WriteLine($&amp;quot;p3 has a name of '{p3.Name}' and an age of {p3.Age}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the third instance, we use the &lt;em&gt;GetUninitializedObject&lt;/em&gt; to get an &lt;code&gt;uninitialized instance of Person&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The output is then as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;p1 has a name of 'Dave' and an age of 46
p2 has a name of '(not set)' and an age of 47
p3 has a name of '' and an age of 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the name of the method suggests, no initialization methods are called - neither the constructors nor the &lt;em&gt;Name&lt;/em&gt; initializer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful library to know about and leverage when the need arises. I wouldn't suggest using it to initialize objects, unless you know how the object will behave without having any constructor or initializers invoked. Doing so may cause instability in the usage of the instance.&lt;/p&gt;
&lt;p&gt;One useful use case could be for auto generating documentation - if the documentation is to give examples of clean uninitialized entities, then this method could be used to get an object, which can then be serialized and output.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/create-dotnet-objects-without-calling-the-constructor"&gt;Create .NET Objects without Calling The Constructor&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;96: 15-06-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Indexers with multiple arguments</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/06/14-indexer-arguments</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/06/14-indexer-arguments</guid>
			<pubDate>Tue, 14 Jun 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Previously we have look at a method to &lt;a href="https://alwaysdeveloping.net/02/23-indexers"&gt;add an indexer and access class as an array&lt;/a&gt;. Today we explore indexers again, and how custom indexers can be written which accept not only integers, but other types as well as &lt;code&gt;multiple parameters&lt;/code&gt;, to access data in a variety of ways.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="list-example"&gt;List example&lt;/h2&gt;
&lt;p&gt;First as a benchmark, we'll have a look at the &lt;code&gt;List&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var strList = new List&amp;lt;string&amp;gt;();

strList.Add("one");
strList.Add("two");
strList.Add("three");
strList.Add("four");
strList.Add("five");

Console.WriteLine(strList[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The items added to the List can be accessed using an int indexer. In the above example &lt;em&gt;strList[3]&lt;/em&gt; will return the 4th item in the list. This is standard built-in functionality.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="enhancedlist-example"&gt;EnhancedList example&lt;/h2&gt;
&lt;p&gt;Next we'll create our own &lt;code&gt;EnhancedList&lt;/code&gt;, which inherits from the &lt;code&gt;List&lt;/code&gt; class, but provides additional functionality through custom indexers.&lt;/p&gt;
&lt;p&gt;The base &lt;code&gt;EnhancedList&lt;/code&gt; looks as follows and operates exactly the same as a normal &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="access-index"&gt;Access index&lt;/h3&gt;
&lt;p&gt;First, let's create an indexer to &lt;code&gt;get the index, based on the value&lt;/code&gt;. This is basically exactly what the &lt;code&gt;IndexOf&lt;/code&gt; method does, but as an indexer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method checks if the list contains the value passed in, and if it does will return the value's index, otherwise -1 will be returned.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// access the value based on the index
Console.WriteLine(enhancedList[3]);

// access the index based on the value
Console.WriteLine(enhancedList["two"]);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    four
    1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The built in indexer for &lt;code&gt;List&lt;/code&gt; accepts an int as a parameter, and we've created an indexer which accepts type T (the type contained in the &lt;em&gt;EnhancedList&lt;/em&gt;), in this example, a string.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="multiple-index-lookup"&gt;Multiple index lookup&lt;/h3&gt;
&lt;p&gt;As we've seen, &lt;code&gt;EnhancedList[index]&lt;/code&gt; can be used to get the value at the specified index. Let's update the &lt;code&gt;EnhancedList&lt;/code&gt; to accept &lt;code&gt;multiple indexes and return multiple values&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;

    public IEnumerable&amp;lt;T&amp;gt; this[bool rangeLookup, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; (T)this[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new indexer has been added, this time taking a bool and an array of integers as arguments. The bool parameter is required to differentiate between &lt;em&gt;EnhancedList[index]&lt;/em&gt; and &lt;em&gt;EnhancedList[params]&lt;/em&gt; - without the bool forcing a difference, there is no way of specifying which indexer is being called.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// get the value for index 2 and 4
foreach (var lookupItem in enhancedList[true, 2, 4])
{
    Console.WriteLine(lookupItem);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, we get the values at index 2 and 4. The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    three
    five
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="t-modification"&gt;T modification&lt;/h3&gt;
&lt;p&gt;The generic type T contained in the &lt;code&gt;EnhancedList&lt;/code&gt; can also be modified before being returned by the indexer. In the last example, we are going to create an indexer which returned the items in the list as a string, ready for output to the Console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class EnhancedList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;
{
    public int this[T value] =&amp;gt; this.Contains(value) ? this.IndexOf(value) : -1;

    public IEnumerable&amp;lt;T&amp;gt; this[bool rangeLookup, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; (T)this[i]);

    public IEnumerable&amp;lt;string&amp;gt; this[string prefixMessage, params int[] indexes] =&amp;gt; 
        indexes.Select(i =&amp;gt; $"{prefixMessage} {(T)this[i]}");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new indexer takes a string prefix message, and an array of indexes. Instead of returning just the values at the position of the indexes (as in the previous example), now the &lt;em&gt;prefixMessage&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt; are combined before being returned.&lt;/p&gt;
&lt;p&gt;The usage is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var enhancedList = new EnhancedList&amp;lt;string&amp;gt;();
enhancedList.Add("one");
enhancedList.Add("two");
enhancedList.Add("three");
enhancedList.Add("four");
enhancedList.Add("five");

// return value at index 0, 2 and 4
// with the supplied message
foreach (var lookupItem in enhancedList["Printing item ...", 0, 2, 4])
{
    Console.WriteLine(lookupItem);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, we get the values at index 2 and 4. The output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;    Printing item ... one
    Printing item ... three
    Printing item ... five
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While the examples shown above are not necessarily production ready or practical, they do show how indexers can be created which accept multiple arguments, allowing for some innovative possibilities depending on your specific use case.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/maartenballiauw/status/1527280915092742144"&gt;Maarten Balliauw Tweet&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;95: 14-06-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>