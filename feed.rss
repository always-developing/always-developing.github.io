<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Fri, 25 Nov 2022 03:51:15 GMT</pubDate>
		<lastBuildDate>Fri, 25 Nov 2022 03:51:15 GMT</lastBuildDate>
		<item>
			<title>Opting into experimental functionality</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/25-preview-attribute</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/25-preview-attribute</guid>
			<pubDate>Fri, 25 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;RequiresPreviewFeatures&lt;/code&gt; attribute can be used to flag a specific piece of code as &lt;em&gt;experimental&lt;/em&gt; or &lt;em&gt;in preview&lt;/em&gt; - this code cannot be used unless the consumer specifically opts into &lt;em&gt;enabling preview features&lt;/em&gt;, preventing the preview, potentially unstable code, from being used unwittingly.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="preview-feature"&gt;Preview feature&lt;/h2&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;p&gt;To mark a &lt;em&gt;method&lt;/em&gt; (or class, property etc) as &lt;em&gt;in preview&lt;/em&gt;, it is decorated with the &lt;code&gt;RequiresPreviewFeatures&lt;/code&gt; attribute. Here the &lt;em&gt;DoWorkNew&lt;/em&gt; method is flagged as &lt;em&gt;in preview&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Worker
{
    public void DoWork()
    {
        // do some work the old way
    }

    [RequiresPreviewFeatures()]
    public void DoWorkNew() 
    { 
        // do some work the new one
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it stands, trying to use this method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var worker = new Worker();

worker.DoWorkNew();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will result in the following compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using 'DoWorkNew' requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To to able to use code marked with the attribute, one specifically needs to opt into &lt;em&gt;preview features&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="project"&gt;Project&lt;/h3&gt;
&lt;p&gt;To opt into &lt;em&gt;preview features&lt;/em&gt;, in the &lt;em&gt;csproj&lt;/em&gt; file ensure the &lt;code&gt;EnablePreviewFeatures&lt;/code&gt; setting is set to true:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net7.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;EnablePreviewFeatures&amp;gt;true&amp;lt;/EnablePreviewFeatures&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this the code will now compile successfully and be able to leverage preview/experimental features.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As a library author this is a very useful tool - allowing new experimental functionality to be introduced &amp;quot;safely&amp;quot;. Usage of the functionality is semi-controlled, and the consumers are required to make an informed choice to manually opt into using potentially unstable code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/1d97ea56-9a32-4067-9919-10b9af5623a6"&gt;Marking API's as obsolete or as experimental&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;210: 25-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Distributed caching int ASP.NET Core</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/24-distributed-cache</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/24-distributed-cache</guid>
			<pubDate>Thu, 24 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;ASP.NET Core comes with the &lt;code&gt;IDistributedCache&lt;/code&gt; interface, and a number of implementations to support &lt;code&gt;distributed caching&lt;/code&gt;. The out of the box implementaions include &lt;em&gt;In Memory&lt;/em&gt;, &lt;em&gt;SQL Server&lt;/em&gt;, &lt;em&gt;Redis&lt;/em&gt; and &lt;em&gt;NCache&lt;/em&gt; - however if another implementation is required, a custom provider can also be fairly easily be written.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-need-for-distributed-cache"&gt;The need for distributed cache&lt;/h2&gt;
&lt;p&gt;Before getting to &lt;em&gt;distributed cache&lt;/em&gt; we'll have a quick look at the &lt;em&gt;non-distributed in memory cache&lt;/em&gt; implementation which also comes out of the box with ASP.NET Core. Configuring and leveraging this functionality is incredibly easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// configure dependency injection with the in-memory cache
builder.Services.AddMemoryCache();

var app = builder.Build();

app.MapGet(&amp;quot;/cache&amp;quot;, (IMemoryCache cache) =&amp;gt;
{
    // try get a value with the key &amp;quot;hello&amp;quot; out the cache
    if(cache.TryGetValue(&amp;quot;hello&amp;quot;, out string result))
    {
        Console.WriteLine(&amp;quot;Retrieved from cache&amp;quot;);

        return result;
    }

    // if the value was not found in the cache
    // add it to the cache
    cache.Set(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);

    return &amp;quot;world&amp;quot;;
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;em&gt;IMemoryCache TryGetValue&lt;/em&gt; method is called to get get a value out of the cache by key. If no value is found, then the item is put into the cache and returned. This is a very simple example, with no cache expiry specified.&lt;/p&gt;
&lt;p&gt;The in-memory cache will be entirely suitable if &lt;code&gt;only one instance of an application is running&lt;/code&gt; - the cache is stored in the memory of that one instance of the application. However, if multiple instance of the application are running (in the cloud, or in containers) the &lt;em&gt;in-memory cache is not shared across instances&lt;/em&gt; - each instance will have its own cached. This is where a &lt;code&gt;distributed cache&lt;/code&gt; can be leveraged, with each application instance sharing the cache, and benefiting from the caching done by other instances.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="distributed-cache"&gt;Distributed cache&lt;/h2&gt;
&lt;p&gt;Configuring and using a &lt;code&gt;distributed cache&lt;/code&gt; in ASP.NET Core is &lt;em&gt;almost&lt;/em&gt; as easy as configuring a normal in-memory cache.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// configure in-memory distributed cache
// which is good for testing, but is not truly 
// distributed
builder.Services.AddDistributedMemoryCache();

var app = builder.Build();

// inject IDistributedCache and not IMemoryCache
app.MapGet(&amp;quot;/distributedcache&amp;quot;, async (IDistributedCache cache) =&amp;gt;
{
    string result;

    // (Try) get the byte array value from the cache
    byte[] encodedResult = await cache.GetAsync(&amp;quot;hello&amp;quot;);
    // if a value was returned
    if(encodedResult != null)
    {
        Console.WriteLine(&amp;quot;Retrieved from cache&amp;quot;);

        // convert byte array to string and return
        result = Encoding.UTF8.GetString(encodedResult);
        return result;
    }

    // convert string to byte array 
    encodedResult = Encoding.UTF8.GetBytes(&amp;quot;world&amp;quot;);
    // and configure the cache options
    DistributedCacheEntryOptions options = new DistributedCacheEntryOptions()
        .SetSlidingExpiration(TimeSpan.FromSeconds(10));

    // add the value to the cache
    await cache.SetAsync(&amp;quot;hello&amp;quot;, encodedResult, options);

    return &amp;quot;world&amp;quot;;

});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;While &lt;code&gt;IMemoryCache&lt;/code&gt; can store a &lt;em&gt;string&lt;/em&gt; or &lt;em&gt;object&lt;/em&gt;, &lt;code&gt;IDistributedCache&lt;/code&gt; will only store a &lt;em&gt;byte array&lt;/em&gt;. Additional processing has to be done to convert to and from a byte array when inserting and retrieving values from the cache.
The &lt;code&gt;IDistributedCache&lt;/code&gt; also doesn't have a &lt;em&gt;TryGet&lt;/em&gt; method, only a &lt;em&gt;Get&lt;/em&gt; method, which will return &lt;code&gt;null&lt;/code&gt; if no value for the supplied key is found.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="configuration"&gt;Configuration&lt;/h3&gt;
&lt;p&gt;The configuration of the &lt;code&gt;in-memory distributed cache&lt;/code&gt; cache was simple (as seen above):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDistributedMemoryCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the configuration of the other implementations is not much more complicated. The SQL Server provider for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddDistributedSqlServerCache(act =&amp;gt;
{
   act.SchemaName = &amp;quot;dbo&amp;quot;;
   act.TableName = &amp;quot;AppCache&amp;quot;;
   act.ConnectionString = builder.Configuration.GetConnectionString(&amp;quot;DefaultDatabase&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The actual logic (the endpoint delegate method in the above example) can remain exactly as is.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having a distributed cache is a key feature in many scalable applications, and the easy to configure and use, out of the box functionality provided by ASP.NET Core will be suitable for most application's needs.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mitchelsellers.com/blog/article/understanding-implementing-caching-in-asp-net-core"&gt;Understanding &amp;amp; Implementing Caching in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;209: 24-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Supporting 13 months</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/23-thirteen-months</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/23-thirteen-months</guid>
			<pubDate>Wed, 23 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET has support for &lt;code&gt;13 months&lt;/code&gt; - the &lt;em&gt;Hebrew&lt;/em&gt; and &lt;em&gt;EastAsianLunisolarCalendar&lt;/em&gt; for example, has the concept of leap months, and as such it is possible for a year to consist of 13 months.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="getmonthname"&gt;GetMonthName&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;GetMonthName&lt;/code&gt; method on &lt;code&gt;DateTimeFormatInfo&lt;/code&gt; supports a month parameter value of between 1 and 13.&lt;/p&gt;
&lt;p&gt;For calendars which only support 12 months, sending a value of 13 to the &lt;code&gt;GetMonthName&lt;/code&gt; method will return a blank string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// this will use the current 
// culture calendar
var df = new DateTimeFormatInfo();

Console.WriteLine(df.GetMonthName(1));
Console.WriteLine(df.GetMonthName(13));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of this is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;January

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if we switch using a &lt;em&gt;Calendar&lt;/em&gt; which supports 13 months:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// switch the culture and the calendar
HebrewCalendar hc = new HebrewCalendar();
CultureInfo culture = CultureInfo.CreateSpecificCulture(&amp;quot;he-IL&amp;quot;);
culture.DateTimeFormat.Calendar = hc;
Thread.CurrentThread.CurrentCulture = culture;

// output to the debug window as my Console did not
// support the characters
Debug.WriteLine(culture.DateTimeFormat.GetMonthName(1));
Debug.WriteLine(culture.DateTimeFormat.GetMonthName(13));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;תשרי
אלול
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Debug output is used here instead of the Console, as my default Console Window encoding did not support Hebrew characters (while the Visual Studio output window does by default)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This piece of knowledge is not especially useful or relevent unless one is working with one of the specific calendars/cultures, or one has to support multiple cultures in the application.
It also serves as a reminder that the culture an application executes under is important, and not to always make assumptions about how the application will always operate.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/misconceptions-about-date-and-time.htm"&gt;Misconceptions: 1 year = 12 months&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;208: 23-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Efficient EF deletion</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/22-ef-faster-delete</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/22-ef-faster-delete</guid>
			<pubDate>Tue, 22 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using Entity Framework to perform a delete (prior to EF7), first the record in question is required to be &lt;em&gt;selected from the table&lt;/em&gt; (so that EF change tracking has visibility of it), then is &lt;em&gt;marked as deleted&lt;/em&gt;, and then the actual database delete is performed with  &lt;em&gt;SaveChanges&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Khalid Abuhakmeh has a very interesting idea, which eliminates the need for the extra round trip to &lt;em&gt;select&lt;/em&gt; the data - manually add the item to EF change tracking (without first checking the database), &lt;em&gt;mark it as deleted&lt;/em&gt;, and &lt;em&gt;save the changes&lt;/em&gt;. If a specific exception occurs because the record is not available for deletion, handle that separately.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="use-case"&gt;Use case&lt;/h2&gt;
&lt;p&gt;In our use case, we will define a &lt;em&gt;Delete&lt;/em&gt; endpoint, which when called will delete the &lt;em&gt;Blog&lt;/em&gt; record using the supplied &lt;em&gt;Id&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="traditional-method"&gt;Traditional method&lt;/h3&gt;
&lt;p&gt;Below is a sample of the "traditional" method of handling the use case:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// context is injected from the DI container
// id is supplied as part of the url
app.MapDelete("/blog/v1/{id:int}", async (DemoContext context, int id) =&amp;gt;
{
    // first lookup the blog by the id
    var blog = await context.Blogs.FindAsync(id);

    // if the blog was found
    if(blog != null)
    {
        // mark it as deleted
        context.Remove(blog);
    }

    await context.SaveChangesAsync();

});
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;First, a query is performed against the database to ensure that a &lt;em&gt;Blog&lt;/em&gt; with the specified Id exists (with &lt;em&gt;FindAsync&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;In the case when the record does exist, the row will start being tracked by Entity Framework's change tracker&lt;/li&gt;
&lt;li&gt;The record is flagged as delete, with the &lt;em&gt;Remove&lt;/em&gt; command&lt;/li&gt;
&lt;li&gt;The changes are finally applied to the database, with &lt;em&gt;SaveChangesAsync&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With this method, there are two round trips to the database - in steps 1 and 4.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="efficient-method"&gt;Efficient Method&lt;/h3&gt;
&lt;p&gt;With the more efficient method, one database round trip can be eliminated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// context is injected from the DI container
// id is supplied as part of the url
app.MapDelete("/blog/v1/{id:int}", async (DemoContext context, int id) =&amp;gt;
{
    try
    {
        // create an instance of the object with the
        // supplied id. 
        var blog = new Blog { Id = id };
        // make the change tracker aware of this object
        var contextBlog = context.Blogs.Attach(blog);
        // mark it as deleted
        contextBlog.State = EntityState.Deleted;

        // delete
        await context.SaveChangesAsync();
    }
    catch(DbUpdateConcurrencyException ex)
    {
        Console.WriteLine("Swallowing delete exception.");
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this method:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instead of checking in the database that a record exists with the supplied &lt;em&gt;Id&lt;/em&gt;, it is &lt;em&gt;assumed a record does already exist&lt;/em&gt; with the id&lt;/li&gt;
&lt;li&gt;A record, with just the Id (the primary key value) set, is created, attached to the change tracker, and marked as deleted&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SaveChangesAsync&lt;/em&gt; is then called to perform the actual delete on the database&lt;/li&gt;
&lt;li&gt;If a record with that specific Id does in fact not exist, an exception will be thrown - which is caught and swallowed (with logging)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The outcome in both cases is the same, but an expensive database round trip has been eliminated.&lt;/p&gt;
&lt;p&gt;In the references link below, Khalid Abuhakmeh has additional ideas and code samples on how this functionality can be cleaned and wrapped into an extension method to make usage even easier.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Having run into this exact issue before, this method is very interesting. Exceptions do have an overhead, but the overhead of a database round trip will almost always out-weigh the exception overhead. Definitely consider the "efficient" method if the "traditional pattern is used throughout code.
Having said that, EF7 introduces &lt;a href="https://alwaysdeveloping.net/09/23-ef-bulk-update"&gt;Bulk Update/Delete functionality&lt;/a&gt; which will allow for this nativity in the EF framework - so this method will become obsolete with time.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/more-efficient-deletes-with-entity-framework-core"&gt;More Efficient Deletes With Entity Framework Core&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;207: 22-11-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>List ConvertAll</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/21-list-convertall</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/21-list-convertall</guid>
			<pubDate>Mon, 21 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;List&lt;/code&gt; class has a &lt;code&gt;ConvertAll&lt;/code&gt; method which allows for the conversion of items in a list from one type to another. It operates similar to the LINQ &lt;code&gt;Select&lt;/code&gt; method, but in some use cases will out-perform the LINQ counterpart.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the below example, we have a List of &lt;code&gt;TypeA&lt;/code&gt;, and would like to convert this list to a a list of &lt;code&gt;TypeB&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;The types:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class TypeA
{
    public string TypeAValue { get; set; }
}

public class TypeB
{
    public string TypeBValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Building up a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;TypeA&amp;gt; types = new()
{
  new TypeA(),
  new TypeA(),
  new TypeA(),
  new TypeA(),
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a list ot &lt;em&gt;TypeA&lt;/em&gt;, we'll look at a couple of ways to convert to a list of &lt;em&gt;TypeB&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="linq-select"&gt;LINQ Select&lt;/h3&gt;
&lt;p&gt;This is the more &amp;quot;traditional&amp;quot; way of converting a list (or IEnumerable) from one type to another:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var typeBList = types
    .Select(a =&amp;gt; new TypeB { TypeBValue = a.TypeAValue })
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;em&gt;Select&lt;/em&gt; will operate on &lt;em&gt;TypeA&lt;/em&gt; and instantiate a &lt;em&gt;TypeB&lt;/em&gt; for each &lt;em&gt;TypeA&lt;/em&gt;, setting the instance properties. The output of this is a list of &lt;em&gt;TypeB&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="list-convertall"&gt;List ConvertAll&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ConvertAll&lt;/code&gt; usage is similar to that of the &lt;em&gt;Select&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var typeBList = types
    .ConvertAll(type =&amp;gt; new TypeB { TypeBValue = type.TypeAValue });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each item in the list, a &lt;em&gt;TypeB&lt;/em&gt; instance is instantiated and the properties set with the values from the &lt;em&gt;TypeA&lt;/em&gt; instance.&lt;/p&gt;
&lt;p&gt;A note: &lt;code&gt;ConvertAll&lt;/code&gt; is only available on &lt;em&gt;List&lt;/em&gt;, so if working with an IEnumerable implementation, the &lt;em&gt;ToList&lt;/em&gt; method would need to be called to convert the collection to a list.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;h3 id="items"&gt;10 Items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;194.9 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;9.99 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;29.46 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;177.4 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0713&lt;/td&gt;
&lt;td style="text-align: right;"&gt;448 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;156.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7.43 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.92 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;143.9 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.82&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.16&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0598&lt;/td&gt;
&lt;td style="text-align: right;"&gt;376 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.84&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With only 10 items in the list, the the &lt;code&gt;ConvertAll&lt;/code&gt; method is faster, and more memory performant than the LINQ &lt;code&gt;Select&lt;/code&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="items-1"&gt;10 000 Items&lt;/h3&gt;
&lt;p&gt;As the number of items in the list increases, the performance metrics of the two two methods converge:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;175.6 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.90 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;32.15 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;189.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;50.7813&lt;/td&gt;
&lt;td style="text-align: right;"&gt;25.3906&lt;/td&gt;
&lt;td style="text-align: right;"&gt;312.63 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;174.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.42 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.07 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;173.5 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.97&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.15&lt;/td&gt;
&lt;td style="text-align: right;"&gt;50.7813&lt;/td&gt;
&lt;td style="text-align: right;"&gt;25.3906&lt;/td&gt;
&lt;td style="text-align: right;"&gt;312.55 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With 10 000 items, the two methods effectively perform the same, and both use the same amount of memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="items-2"&gt;100 000 Items&lt;/h3&gt;
&lt;p&gt;The same results can be seen with 100 000 records, as was seen with 10 000 record:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen2&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LinqSelect&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.586 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1298 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2561 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;515.6250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;328.1250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;179.6875&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.05 MB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GenericConvertAll&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.236 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1199 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1970 ms&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.05&lt;/td&gt;
&lt;td style="text-align: right;"&gt;515.6250&lt;/td&gt;
&lt;td style="text-align: right;"&gt;320.3125&lt;/td&gt;
&lt;td style="text-align: right;"&gt;179.6875&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.05 MB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The two methods effectively perform the same, and both use the same amount of memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If currently using &lt;code&gt;Select&lt;/code&gt;, there is not much reason to update code to switch to &lt;code&gt;ConvertAll&lt;/code&gt; - except if micro performance improvements are critical to your application. However if performance is so critical for the application, LINQ is probably not even being used in the first place.&lt;/p&gt;
&lt;p&gt;Having said all that, it is interesting the &lt;code&gt;ConvertAll&lt;/code&gt; method is available and does have performance improvements over using LINQ &lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/advanced-linq/"&gt;Advanced LINQ&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;206: 21-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Succinct initialization pattern</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/18-succinct-init</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/18-succinct-init</guid>
			<pubDate>Fri, 18 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Sometimes objects need to be initialized &lt;em&gt;lazily&lt;/em&gt; - two newer C# features, the &lt;em&gt;null-coalescing assignment operator&lt;/em&gt; &lt;code&gt;??=&lt;/code&gt; and the &lt;em&gt;target-typed new expression&lt;/em&gt; makes the lazy initialization cleaner and more succinct.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the examples, we have a &lt;code&gt;Album&lt;/code&gt; class which contains an &lt;em&gt;optional&lt;/em&gt; list of &lt;code&gt;Song&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Album
{
    private readonly string _name;

    private readonly List&amp;lt;Song&amp;gt; _songs;

    public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
    {
        _name = name;
        _songs = songs;

        // See examples below on how to 
        // do the _songs initialization
    }
}

public class Song
{
    private readonly string _name;

    public Song(string name)
    {
        _name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If no &lt;code&gt;Song&lt;/code&gt; list is passed into the constructor, then the &lt;code&gt;_song&lt;/code&gt; variable needs to be initialized to an &lt;em&gt;empty list&lt;/em&gt;. Doing this will prevent having to have checks throughout the code to determine if the Song list is null or not. There are multiple ways to do this, but this post focuses on the &amp;quot;more traditional&amp;quot; method, and the new &amp;quot;succinct&amp;quot; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="traditional-lazy-init"&gt;Traditional lazy init&lt;/h3&gt;
&lt;p&gt;Traditionally (before any of the newer C# features were introduced), the constructor might look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
{
    _name = name;
    _songs = songs;

    // check if _songs is null
    if(_songs == null)
    {
        // initialize to an empty list
        _songs = new List&amp;lt;Song&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable is checked to determine if its &lt;em&gt;null&lt;/em&gt; or not, and if it is, then explicitly initialized to an empty list. Nothing inherently wrong with this approach - it just takes four lines of code to &lt;em&gt;lazily initialize a variable&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="succinct-lazy-init"&gt;Succinct lazy init&lt;/h3&gt;
&lt;p&gt;As mentioned, the two newer C# features allow for this code to be more succinct:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Album(string name, List&amp;lt;Song&amp;gt; songs = null)
{
    _name = name;
    _songs = songs;

    _songs ??= new();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;null-coalescing assignment operator&lt;/em&gt; &lt;code&gt;??=&lt;/code&gt; assigns the value of the right-hand side to the left-hand side, only if the left-hand side is null&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;target-typed new&lt;/code&gt; expression, &lt;code&gt;new&lt;/code&gt; allows for the inferring of the type from the declaration, instead of having to explicitly specify the type in full&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Four lines of code have been reduced to one!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very minor change, which is not a necessity or requirement when coding - however is does result in cleaner, more succinct code. Over time, it also does reduce coding time by reducing the number of key strokes required by the developer.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidfowl/status/1586592671296290816"&gt;David Fowler Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;205: 18-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Local functions and attributes</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/17-local-attributes</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/17-local-attributes</guid>
			<pubDate>Thu, 17 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;local functions&lt;/code&gt;, it is possible to decorate them, as well as their parameters, with &lt;code&gt;attributes&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="local-function"&gt;Local function&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Local functions&lt;/code&gt; are methods of a type that are nested in another member. They can only be called from their containing member:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{

    // Containing method
    public void DoProcessing()
    {
        // local function/method
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        PerformInternalLogic();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above sample, the &lt;em&gt;PerformInternalLogic&lt;/em&gt; method is a &lt;code&gt;local method&lt;/code&gt; nested in the &lt;em&gt;DoProcessing&lt;/em&gt; method, and can only be called from within the method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="attributes"&gt;Attributes&lt;/h2&gt;
&lt;h3 id="method-attribute"&gt;Method attribute&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Method targeting&lt;/em&gt; attributes can be used on local functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{
    // Containing method
    public void DoProcessing()
    {
        // local function/method
        [Obsolete(&amp;quot;This will be deprecated. Not useful for consumers of your method&amp;quot;)]
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        PerformInternalLogic();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, the &lt;code&gt;Obsolete&lt;/code&gt; attribute was used to decorate the &lt;em&gt;PerformInternalLogic&lt;/em&gt; method (as an indicator that the local method is obsolete and will be removed in future)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="parameter-attribute"&gt;Parameter attribute&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Parameter targeting&lt;/em&gt; attributes can also be used on &lt;em&gt;local function parameters&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Processor
{
    // Containing method
    public void DoProcessing()
    {
        // local function/method
        [Obsolete(&amp;quot;This will be deprecated. Not useful for consumers of your method&amp;quot;)]
        void PerformInternalLogic()
        {
            Console.WriteLine(&amp;quot;Logic being performed...&amp;quot;);
        }

        // local function/method
        void PerformOtherInternalLogic([CallerMemberName] string memberName = &amp;quot;&amp;quot;)
        {
            Console.WriteLine($&amp;quot;Logic being performed called from {memberName}&amp;quot;);
        }

        PerformInternalLogic();

        PerformOtherInternalLogic();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;CallerMemberName&lt;/code&gt; attribute us applied to the parameter of the &lt;em&gt;PerformOtherInternalLogic&lt;/em&gt; method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A fairly niche use case, but if required, it is useful to know it is possible to add attributes to local functions.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.okyrylchuk.dev/a-comprehensive-overview-of-c-9-features#heading-8-attributes-on-local-functions"&gt;8. Attributes on Local Functions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;204: 17-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Builder pattern implicit conversions</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/16-implicit-builder</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/16-implicit-builder</guid>
			<pubDate>Wed, 16 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Usually when using the &lt;code&gt;builder pattern&lt;/code&gt;, a final &lt;code&gt;Build&lt;/code&gt; method (or similarly named method) is invoked to generate the &lt;em&gt;final entity&lt;/em&gt; from the &lt;em&gt;builder entity&lt;/em&gt;. Using an &lt;code&gt;implicit operator&lt;/code&gt;, this final step can be removed, and the &lt;em&gt;final entity&lt;/em&gt; can &lt;code&gt;automatically be generated&lt;/code&gt; from the &lt;em&gt;builder entity&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In these examples, there is a simple &lt;code&gt;Order&lt;/code&gt; entity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record Order(int Id, int lineItemCount, double Total);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is also an &lt;code&gt;OrderBuilder&lt;/code&gt; class, which is used to build an &lt;code&gt;Order&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class OrderBuilder
{
    // store some order information
    private int _id;
    private int _lineItemCount;
    private double _total;

    // method to give an order an id
    public OrderBuilder WithId(int Id)
    {
        _id = Id;
        return this;
    }

    // add a simple line item to the order
    public OrderBuilder WithLineItem(double lineItemAmount)
    {
        _lineItemCount++;
        _total += lineItemAmount;

        return this;
    }

    // create an Order from the OrderBuilder information
    public Order Build()
    {
        return new Order(_id, _lineItemCount, _total);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="build-method"&gt;Build method&lt;/h3&gt;
&lt;p&gt;Usage of the above &lt;em&gt;builder&lt;/em&gt; is easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var order = new OrderBuilder()
    .WithId(100) // give the order an id
    .WithLineItem(99) // add line items
    .WithLineItem(149)
    .Build(); // remember to build!

Console.WriteLine(order);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above is the typical usage of the &lt;em&gt;builder pattern&lt;/em&gt; - building up the entity using various methods, and then at the end calling a &lt;code&gt;Build&lt;/code&gt; method to create the final entity (&lt;code&gt;Order&lt;/code&gt; in this example) using the information supplied to the &lt;em&gt;builder&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The output of the order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Order { Id = 100, lineItemCount = 2, Total = 248 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing inherently wrong or incorrect with this code or approach - however an implicit operator can be added to the &lt;code&gt;OrderBuilder&lt;/code&gt; class to make the pattern and classes even easier to use.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="implicit"&gt;Implicit&lt;/h3&gt;
&lt;p&gt;Adding the following &lt;code&gt;implicit operator&lt;/code&gt; to the &lt;em&gt;OrderBuilder&lt;/em&gt; class, allows for the &lt;code&gt;Build&lt;/code&gt; method to &lt;em&gt;automatically be invoked&lt;/em&gt; when converting the &lt;em&gt;OrderBuilder&lt;/em&gt; instance to an &lt;em&gt;Order&lt;/em&gt; instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static implicit operator Order(OrderBuilder b) =&amp;gt; b.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the above added to the &lt;em&gt;OrderBuilder&lt;/em&gt; class, the following is now possible:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// instead of &amp;quot;var&amp;quot;, the actual type
// Order is used
Order order = new OrderBuilder()
    .WithId(101)
    .WithLineItem(100)
    .WithLineItem(29);
// No Build required!

Console.WriteLine(order);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this code snippet, as the &lt;em&gt;OrderBuilder&lt;/em&gt; is being converted to &lt;em&gt;Order&lt;/em&gt; implicitly, the &lt;code&gt;implicit operator&lt;/code&gt; is called which calls the &lt;em&gt;Build&lt;/em&gt; method to convert the &lt;em&gt;OrderBuilder&lt;/em&gt; to an &lt;em&gt;Order&lt;/em&gt; automatically. No need for the &lt;code&gt;Build&lt;/code&gt; method to be used!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is a small update to the code, but for the developers consuming the classes, the overall &lt;em&gt;developer experience&lt;/em&gt; is improved. This gives the developer the flexibility to use the class how they would like - either using the &lt;em&gt;Build&lt;/em&gt; method, or doing the &lt;em&gt;implicit conversion&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://josef.codes/bonus-builder-pattern-with-the-implicit-operator-using-c-sharp/"&gt;Bonus: Builder Pattern with the implicit operator using c#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;203: 16-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Foreach loops and indexes</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index</guid>
			<pubDate>Tue, 15 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Often when iterating through a list using a &lt;code&gt;foreach&lt;/code&gt; loop, an index to the item's position in the list is also required - instead of using a separate &lt;em&gt;index variable&lt;/em&gt;, a &lt;code&gt;tuple can be used to keep track of the item and it's index&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="manually-tracking-index"&gt;Manually tracking index&lt;/h2&gt;
&lt;p&gt;Sometimes while iterating, the index of the item in the list is required - usually this is done by creating a separate variable and manually increasing it in each iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// variable used to keep track of the index
int loopIndex = 0;
foreach(var item in list)
{
    // access the item and the index
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {loopIndex}&amp;quot;);

    // don't forget to increase the index
    loopIndex++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the item from the list can be accessed, as well as the index (position) of the item in the list. The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach is entirely valid, however it does require additional effort, and the developer needs to remember to increase the index variable. There is a cleaner, simpler approach (however, it &lt;em&gt;might&lt;/em&gt; come with a performance cost)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="tuple-index"&gt;Tuple index&lt;/h2&gt;
&lt;p&gt;Instead of manually creating and incrementing an index variable, this can be done automatically &lt;em&gt;with the foreach loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// instead of iterating through the list directly
// select the items of the list into a tuple, along
// with the index
foreach(var (item, index) in 
    list.Select((item, index) =&amp;gt; (item, index)))
{
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {index}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the items in the list are select into a list of &lt;em&gt;tuples&lt;/em&gt;, each tuple containing the item itself, as well as the index. Iterating over this new list gives us access to both these values.&lt;/p&gt;
&lt;p&gt;The output is the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cleaner, simpler and less prone to errors (forgetting to increment the index manually)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively simple tip, but one which does make things easier as a developer -  however depending on the list size and the list type, could result in a performance hit. If the list is generally relatively small, the performance hit shouldn't be noticeable and the code is cleaner. But still perform benchmark and use the best solution for your use case&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidpine7/status/1584553974236971008"&gt;David Pine Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;202: 15-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>String comparison with StringComparer</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison</guid>
			<pubDate>Mon, 14 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When comparing strings, instead of using &lt;code&gt;ToLower()&lt;/code&gt; (or &lt;code&gt;ToUpper&lt;/code&gt;) with the comparison operator &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;StringComparer.OrdinalIgnoreCase.Equals&lt;/code&gt; can be used, which is faster and uses less memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;There are a number of different ways to compare strings in C# - this post will explore a number of these methods, as well as compare their performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="section"&gt;==&lt;/h3&gt;
&lt;p&gt;The most basic method is to use the comparison operator &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using ==&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1 == value2}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1 == value3}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using ==
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with this approach is that the &lt;em&gt;case of the string is not taken into account&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tolowertoupper"&gt;ToLower/ToUpper&lt;/h3&gt;
&lt;p&gt;An often use method, is to use the comparison operator, but to &lt;code&gt;ToUpper&lt;/code&gt; or &lt;code&gt;ToLower&lt;/code&gt; the string for comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using == and ToLower&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToLower() == value2.ToLower()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToLower() == value3.ToLower()}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

Console.WriteLine(&amp;quot;Using == and ToUpper&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToUpper() == value2.ToUpper()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToUpper() == value3.ToUpper()}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using == and ToLower
value1 and value2: True
value1 and value3: False
-----
Using == and ToUpper
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both methods yield the same, accurate result.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="string.equals"&gt;string.Equals&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;string&lt;/code&gt; class has an &lt;code&gt;Equals&lt;/code&gt; method, which can also be used for comparison. One version is a &lt;em&gt;static method&lt;/em&gt;, and the other is an &lt;em&gt;instance method&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

// instance Equals method
Console.WriteLine(&amp;quot;Using instance Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.Equals(value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.Equals(value3)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

// Static Equals method
Console.WriteLine(&amp;quot;Using static Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using instance Equals
value1 and value2: False
value1 and value3: False
-----
Using static Equals
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basic version of &lt;code&gt;Equals&lt;/code&gt; does not take the string case into account - however there is an additional parameter which can be passed to the &lt;code&gt;Equals&lt;/code&gt; method to define how the comparison is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using static Equals OrdinalIgnoreCase&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using string.Equals OrdinalIgnoreCase
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="stringcomparer"&gt;StringComparer&lt;/h3&gt;
&lt;p&gt;The final method is using &lt;code&gt;StringComparer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using StringComparer&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {StringComparer.OrdinalIgnoreCase.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {StringComparer.OrdinalIgnoreCase.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using StringComparer
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Finally, we can benchmark all the different methods:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BasicComparison&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.972 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0392 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0348 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.974 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToLower&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.073 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.8145 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7619 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.187 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.34&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.61&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToUpper&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.095 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.6650 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.7548 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.910 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.74&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.32&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringInstanceEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.903 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0465 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0388 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.912 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringStaticEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.896 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0272 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0227 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.899 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringEqualOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.083 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1480 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1584 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.078 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.09&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringComparerOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.770 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0669 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0559 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.762 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.42&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, once can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In all instances where the case of the string is taken into account, performance is slower&lt;/li&gt;
&lt;li&gt;The often used &lt;code&gt;ToUpper/ToLower&lt;/code&gt; method is the slowest a large margin, and the only method to use memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringComparer&lt;/code&gt; is the most performant technique to use when a comparison needs to be done while ignoring the case&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Realistically, in most applications the performance of a string comparison is not going to have any material effect on performance. However if the application does a large number of string comparisons, the accumulative effect could be slightly noticeable and it might be worth investigating the use of &lt;code&gt;StringComparer&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/Tullo/status/1583491663577481219"&gt;&amp;#64;Tullo Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;201: 14-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>