<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Fri, 23 Sep 2022 05:06:56 GMT</pubDate>
		<lastBuildDate>Fri, 23 Sep 2022 05:06:56 GMT</lastBuildDate>
		<item>
			<title>Bulk update (and delete) in EF7</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/23-ef-bulk-update</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/23-ef-bulk-update</guid>
			<pubDate>Fri, 23 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;New functionality is being introduced with Entity Framework 7 which enables the ability to perform &lt;code&gt;bulk updates and deletes&lt;/code&gt; on the database, without having to first load the relevent records into memory. This results in &lt;code&gt;better memory usage&lt;/code&gt;, as well as &lt;code&gt;increased performance&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="availability"&gt;Availability&lt;/h2&gt;
&lt;p&gt;As of the time of this post, this functionality is only available via the EF nightly builds for &lt;code&gt;Microsoft.EntityFrameworkCore&lt;/code&gt; and &lt;code&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/code&gt; available at the &lt;a href="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json"&gt;following NuGet feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This URL can be added as a package source in the &lt;em&gt;NuGet Package Manager -&amp;gt; Package Sources&lt;/em&gt; in Visual Studio to enable access to the nightly build NuGet packages.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the sample below, we have a table of 10 000 &lt;em&gt;Blog&lt;/em&gt; records - we want to update the &lt;em&gt;Description&lt;/em&gt; column value for all records which have an &lt;code&gt;Id value of 20 or less&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In both EF6 and EF7 examples, the &lt;em&gt;OnConfiguring&lt;/em&gt; method of the DbContext has been updated to enable &lt;em&gt;sensitive logging&lt;/em&gt; and &lt;em&gt;console logging&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;optionsBuilder.EnableSensitiveDataLogging(true);
    optionsBuilder.LogTo((string query) =&amp;gt;
    {
        Console.WriteLine(query);
    }, LogLevel.Information);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="prior-to-ef7"&gt;Prior to EF7&lt;/h3&gt;
&lt;p&gt;In existing versions of Entity Framework, the relevent records have to be selected into memory (so the change tracker is tracking them), updated, and then the changes saved back to the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get all blogs into memory/change tracker
var updateBlogs = context.Blogs.Where(b =&amp;gt; b.Id &amp;lt;= 20).ToList();

// update the value
updateBlogs.ForEach(ub =&amp;gt; ub.Description = &amp;quot;EF6 Bulk Update&amp;quot;);

// save...multiple updates
context.Blogs.UpdateRange(updateBlogs);
var result = await context.SaveChangesAsync();

Console.WriteLine($&amp;quot;Numbers of records updated: {result}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the update code, results in the following output (abbreviated in places):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt; Executed DbCommand (90ms) [Parameters=[&amp;#64;p3='1', &amp;#64;p0='2022-07-12T06:47:24.1400000', 
 &amp;#64;p1='EF6 Bulk Update' (Size = 4000), &amp;#64;p2='DD50AA26-FB55-4985-B5D5-C9D2DE98AFB3' (Size = 4000), 
 &amp;#64;p7='2', &amp;#64;p4='2022-07-12T06:47:24.1400000', &amp;#64;p5='EF6 Bulk Update' (Size = 4000), 
 &amp;#64;p6='4BF98BB3-A4BD-4652-AC29-F6A6EE1BE524' (Size = 4000), &amp;#64;p11='3', &amp;#64;p8='2022-07-12T06:47:24.1400000', 
 &amp;#64;p9='EF6 Bulk Update' (Size = 4000), &amp;#64;p10='3C41C714-1670-4978-85DF-956F14FB8863' (Size = 4000), 
 &amp;#64;p15='4', &amp;#64;p12='2022-07-12T06:47:24.1430000', &amp;#64;p13='EF6 Bulk Update' (Size = 4000), 
 &amp;#64;p14='91929DC9-BE25-4027-9554-1B6EEF108E12' (Size = 4000), &amp;#64;p19='5', &amp;#64;p16='2022-07-12T06:47:24.1430000', 
 &amp;#64;p17='EF6 Bulk Update' (Size = 4000), &amp;#64;p18='28DAF144-2ADB-42F4-9838-64F2DC192480' (Size = 4000), &amp;#64;p23='6' 
 .... 
 ....
SET NOCOUNT ON;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p0, [Description] = &amp;#64;p1, [Title] = &amp;#64;p2
OUTPUT 1
WHERE [Id] = &amp;#64;p3;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p4, [Description] = &amp;#64;p5, [Title] = &amp;#64;p6
OUTPUT 1
WHERE [Id] = &amp;#64;p7;
UPDATE [Blog] SET [DateCreated] = &amp;#64;p8, [Description] = &amp;#64;p9, [Title] = &amp;#64;p10
OUTPUT 1
...
...
Numbers of records updated: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output, we can see that multiple &lt;em&gt;UPDATE&lt;/em&gt; statements are executed, &lt;code&gt;one UPDATE for each record&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ef7"&gt;EF7&lt;/h3&gt;
&lt;p&gt;With EF 7, an &lt;code&gt;ExecuteUpdateAsync extension method&lt;/code&gt; is now available on &lt;code&gt;IQueryable&lt;/code&gt;, enabling bulk updates.&lt;/p&gt;
&lt;p&gt;The syntax is a little more complex than using the EF6 technique:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var updatedCount = await context
    .Blogs
    // filter records to be updated
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    // execute the bulk update
    .ExecuteUpdateAsync(record =&amp;gt; record
        // specify which column to update
        // as well as the value
        .SetProperty(blog =&amp;gt; blog.Description, desc =&amp;gt; &amp;quot;EF7 Bulk Update&amp;quot;)
    );

Console.WriteLine($&amp;quot;Numbers of records updated: {updatedCount}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the output when executed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;UPDATE [b]
    SET [b].[Description] = N'EF7 Bulk Update'
FROM [Blog] AS [b]
WHERE [b].[Id] &amp;lt;= 20

Numbers of records updated: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The generated SQL is &lt;code&gt;much simpler and more concise&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is possible to also &lt;em&gt;update multiple columns&lt;/em&gt; at the same time by &lt;code&gt;chaining SetProperty methods together&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var updatedCount = await context
    .Blogs
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    .ExecuteUpdateAsync(record =&amp;gt; record
        // update the description and date modified
        .SetProperty(blog =&amp;gt; blog.Description, desc =&amp;gt; &amp;quot;EF7 Bulk Update&amp;quot;)
        .SetProperty(blog =&amp;gt; blog.DateModified, date =&amp;gt; DateTime.Now)
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Benchmarking the two samples above using BenchmarkDotnet::&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EF6Update&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,222.8 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;126.60 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;367.29 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;302 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EF7Update&lt;/td&gt;
&lt;td style="text-align: right;"&gt;428.9 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.23 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;5.81 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.19&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12.6953&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.9766&lt;/td&gt;
&lt;td style="text-align: right;"&gt;79 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, we can see that the EF7 methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is &lt;code&gt;5 times faster than EF6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;uses almost &lt;code&gt;4 times less memory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="bulk-delete"&gt;Bulk Delete&lt;/h2&gt;
&lt;p&gt;For completeness, a &lt;code&gt;bulk delete method&lt;/code&gt; is also available as part of EF7. It can be leveraged as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var deletedCount = await context
    .Blogs
    .Where(b =&amp;gt; b.Id &amp;lt;= 20)
    .ExecuteDeleteAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will result in SQL similar to that of the bulk update - a &lt;em&gt;single bulk delete statement&lt;/em&gt; instead of multiple, one per record.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very welcome addition to the Entity Framework libraries, greatly speeding up specific uses cases. A specific use case I'm personally interested in, is &lt;em&gt;extracting data for publishing, and then flagging the data as &amp;quot;published&amp;quot;&lt;/em&gt;. Currently this involves having to load the data into memory, so the change tracker is tracking it, updating the records, and then having EF update each record as &amp;quot;published&amp;quot; individually.&lt;/p&gt;
&lt;p&gt;With EF7, the data can be retrieved without tracking, thus saving on memory usage, and then updated as &amp;quot;published&amp;quot; in bulk.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://timdeschryver.dev/blog/new-in-entity-framework-7-bulk-operations-with-executedelete-and-executeupdate#number-of-rows-affected"&gt;New in Entity Framework 7: Bulk Operations with ExecuteDelete and ExecuteUpdate&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;167: 23-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Extend the middleware pipeline with IStartupFilter</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/22-startup-filters</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/22-startup-filters</guid>
			<pubDate>Thu, 22 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IStartupFilter&lt;/code&gt; interface can be used to extend either the &lt;em&gt;start&lt;/em&gt; or the &lt;em&gt;end&lt;/em&gt; the middleware pipeline.&lt;/p&gt;
&lt;p&gt;Any implementations of &lt;code&gt;IStartupFilter&lt;/code&gt; will automatically be called on application build &lt;code&gt;before any other middleware configuration&lt;/code&gt; is called.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="manual-middleware"&gt;Manual middleware&lt;/h2&gt;
&lt;p&gt;In the below example the basic &lt;em&gt;weatherforecast&lt;/em&gt; template is being extended to contain a manually added middleware component:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var summaries = new[]
{
    &amp;quot;Freezing&amp;quot;, &amp;quot;Bracing&amp;quot;, &amp;quot;Chilly&amp;quot;, &amp;quot;Cool&amp;quot;, &amp;quot;Mild&amp;quot;, &amp;quot;Warm&amp;quot;, &amp;quot;Balmy&amp;quot;, &amp;quot;Hot&amp;quot;, &amp;quot;Sweltering&amp;quot;, &amp;quot;Scorching&amp;quot;
};

app.MapGet(&amp;quot;/weatherforecast&amp;quot;, () =&amp;gt;
{
    // print out a message
    Console.WriteLine(&amp;quot;Weatherforecast endpoint called&amp;quot;);

    var forecast = Enumerable.Range(1, 5).Select(index =&amp;gt;
        new WeatherForecast
        (
            DateTime.Now.AddDays(index),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
});

// add the custom middleware manually
app.UseMiddleware&amp;lt;ManualMiddleware&amp;gt;();

app.Run();

internal record WeatherForecast(DateTime Date, int TemperatureC, string? Summary)
{
    public int TemperatureF =&amp;gt; 32 + (int)(TemperatureC / 0.5556);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The definition of &lt;code&gt;ManualMiddleware&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ManualMiddleware
{
    private readonly RequestDelegate _next;

    public ManualMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
       // this should be output before the request to 
       // forwarded onto the next component in the pipeline
       Console.WriteLine($&amp;quot;In the manually added &amp;quot; +
            $&amp;quot;middleware: {nameof(ManualMiddleware)}. &amp;quot; +
            $&amp;quot;The current datetime is '{DateTime.Now}'&amp;quot;);

        // call the next component with the context
        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling the endpoint, the console output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;In the manually added middleware: ManualMiddleware. The current datetime is '2022/09/20 06:40:23'
Weatherforecast endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the component added to the middleware is invoked before forwarding the request onto the next component, and eventually the endpoint.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="istartupfilter-middleware"&gt;IStartupFilter middleware&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;IStartupFilter&lt;/code&gt; only has one method to implement, &lt;code&gt;Configure&lt;/code&gt;, which takes an &lt;code&gt;Action&amp;lt;IApplicationBuilder&amp;gt;&lt;/code&gt; as an argument, and also return an &lt;code&gt;Action&amp;lt;IApplicationBuilder&amp;gt;&lt;/code&gt;. Below is our custom implementation of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CustomFilter : IStartupFilter
{
    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        return builder =&amp;gt;
        {
            // perform the custom build configuration
            Console.WriteLine($&amp;quot;Configured via {nameof(CustomFilter)}&amp;quot;);
            builder.UseMiddleware&amp;lt;HelloMiddleware&amp;gt;();

            // call the next item in the build pipeline
            next(builder);

            // add here to  change the end of the middleware pipeline
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;build pipeline&lt;/code&gt; operates similarly to how the &lt;code&gt;middleware pipeline&lt;/code&gt; operates - the custom component performs its build logic, before passing on the &lt;em&gt;build request&lt;/em&gt; to the next item in the build pipeline.&lt;/p&gt;
&lt;p&gt;In the above, the custom logic is writing a message to the console and then adding &lt;code&gt;another custom middleware component&lt;/code&gt; to the middleware pipeline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class HelloMiddleware
{
    private readonly RequestDelegate _next;

    public HelloMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        Console.WriteLine($&amp;quot;Hello from {nameof(HelloMiddleware)}. &amp;quot; +
            $&amp;quot;The current datetime is '{DateTime.Now}'&amp;quot;);

        await _next.Invoke(httpContext);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final step to putting it all together is to add the &lt;code&gt;CustomFilter&lt;/code&gt; implementation to the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IStartupFilter, CustomFilter&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the application start, the following is output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Configured via CustomFilter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then when calling the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Hello from HelloMiddleware. The current datetime is '2022/08/25 06:48:35'
In the manually added middleware: ManualMiddleware. The current datetime is '2022/08/25 06:48:35'
Weatherforecast endpoint called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output we can see, that the &lt;code&gt;middleware added using the IStartupFilter is invoked before the manually added middleware&lt;/code&gt;. We have used the &lt;em&gt;IStartupFilter&lt;/em&gt; implementation to add an item to the start of the middleware pipeline , achieved by only adding the &lt;em&gt;IStartupFilter&lt;/em&gt; implementation to the dependency injection container.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="flow-summary"&gt;Flow summary&lt;/h2&gt;
&lt;p&gt;A summary of what we have covered so far, and how the various pieces fit together&lt;/p&gt;
&lt;h3 id="application-startup"&gt;Application startup&lt;/h3&gt;
&lt;p&gt;On application startup:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;em&gt;IStartupFilter&lt;/em&gt; implementation &lt;em&gt;CustomFilter&lt;/em&gt; is &lt;code&gt;added to the dependency injection&lt;/code&gt; container.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;WebApplication instance is run&lt;/code&gt;, with the &lt;em&gt;app.Run()&lt;/em&gt; command:
&lt;ol&gt;
&lt;li&gt;All implementations of &lt;em&gt;IStartupFilter&lt;/em&gt; are retrieved from the dependency injection container, and the &lt;code&gt;Configure&lt;/code&gt; method on the implementation invoked
In this above sample, the &lt;code&gt;Configure&lt;/code&gt; adds the &lt;em&gt;HelloMiddleware&lt;/em&gt; component to the start of the middleware pipeline.&lt;/li&gt;
&lt;li&gt;All other middleware components are configured
In this above sample, the &lt;em&gt;ManualMiddleware&lt;/em&gt; component is added to the middleware pipeline&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The middleware pipeline is now ready to receive requests.&lt;/p&gt;
&lt;h3 id="request-received"&gt;Request received&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;When a request is received, it will flow through the middleware pipeline, component by component in the order in which they were added to the pipeline:
&lt;ol&gt;
&lt;li&gt;The request is passed to the &lt;em&gt;HelloMiddleware&lt;/em&gt; component and the &amp;quot;hello&amp;quot; message is output (added via &lt;em&gt;IStartupFilter&lt;/em&gt; implementation)&lt;/li&gt;
&lt;li&gt;The request is passed to the &lt;em&gt;ManualMiddleware&lt;/em&gt; components and the relevent message is output (added explicitly)&lt;/li&gt;
&lt;li&gt;The request is then passed to the endpoint handler, to return generate the weather data (defined explicitly)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally most applications would not have a need for this functionality, but there are a couple of cases where it could be especially useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As a library author, and the library needs to inject middleware at the beginning or the end of the middleware pipeline&lt;/li&gt;
&lt;li&gt;Conversely, if a library is injecting middleware at the beginning or end of the pipeline and you as the application author needs to inject a component before/after the library.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-istartupfilter-in-asp-net-core/"&gt;Exploring IStartupFilter in ASP.NET Core &lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;166: 22-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Simplifying command line argument with switch mappings</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/21-commandline-mappings</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/21-commandline-mappings</guid>
			<pubDate>Wed, 21 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with command line argument, &lt;code&gt;switch mappings&lt;/code&gt; can be used to create &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;short keys&lt;/code&gt; for the arguments, simplifying their usage for the consumer of the application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="command-line-setup"&gt;Command line setup&lt;/h2&gt;
&lt;p&gt;By default, arguments passed to an application will automatically be made available through the &lt;em&gt;IConfiguration&lt;/em&gt; interface/implementation. Consider the below minimal endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getarguments&amp;quot;, (IConfiguration config) =&amp;gt;
{
    // access the arguments using the key, via
    // the IConfiguration implementation
    return new
    {
        Argument1 = config[&amp;quot;argument1&amp;quot;],
        Argument2 = config[&amp;quot;argument2&amp;quot;],
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Command line arguments can be passed to the application with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet run argument1=hello argument2=world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or by specifying the arguments in the &lt;em&gt;launchSettings.json&lt;/em&gt; file and executing in Visual Studio:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt; &amp;quot;CommandLineMapping&amp;quot;: {
    &amp;quot;commandName&amp;quot;: &amp;quot;Project&amp;quot;,
    &amp;quot;commandLineArgs&amp;quot;: &amp;quot;argument1=hello argument2=world&amp;quot;,
    &amp;quot;launchBrowser&amp;quot;: true,
    &amp;quot;launchUrl&amp;quot;: &amp;quot;getarguments&amp;quot;,
    &amp;quot;environmentVariables&amp;quot;: {
    &amp;quot;ASPNETCORE_ENVIRONMENT&amp;quot;: &amp;quot;Development&amp;quot;
    },
    &amp;quot;dotnetRunMessages&amp;quot;: true,
    &amp;quot;applicationUrl&amp;quot;: &amp;quot;http://localhost:5259&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;em&gt;getarguments&lt;/em&gt; endpoint, we see the following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;argument1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;argument2&amp;quot;: &amp;quot;world&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This all functions because under the hood, on startup, &lt;code&gt;builder.Configuration.AddCommandLine(args)&lt;/code&gt; is being called. This explicitly maps the command line arguments to the .NET &lt;em&gt;IConfiguration&lt;/em&gt; implementation, making the arguments available to access.&lt;/p&gt;
&lt;p&gt;So far so good - but suppose we want change the argument names from &lt;em&gt;argument1&lt;/em&gt; and &lt;em&gt;argument2&lt;/em&gt; to &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;. We don't want to remove support for the full names (as we don't want to create a breaking change), but if an argument called &lt;code&gt;arg1&lt;/code&gt; is passed in, we want it to map to &lt;em&gt;argument1&lt;/em&gt; No code which specifically looks for an argument called &lt;em&gt;argument1&lt;/em&gt; is required to change.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="aliases"&gt;Aliases&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;builder.Configuration.AddCommandLine&lt;/code&gt; has an overloaded method which takes in a &lt;code&gt;switch mapping&lt;/code&gt; to perform a mapping, which can explicitly be called to created argument aliases.&lt;/p&gt;
&lt;p&gt;On startup:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define the mappings between the alias and the argument
Dictionary&amp;lt;string, string&amp;gt; mappings = new Dictionary&amp;lt;string, string&amp;gt;()
{
    [&amp;quot;--arg1&amp;quot;] = &amp;quot;argument1&amp;quot;,
    [&amp;quot;--arg2&amp;quot;] = &amp;quot;argument2&amp;quot;,
};
// explicitly call AddCommandLine with the mappings
builder.Configuration.AddCommandLine(args, mappings);

// build the application
var app = builder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alias switch mappings are defined using a double dash (&lt;code&gt;--&lt;/code&gt;) and an alias name (&lt;em&gt;arg1&lt;/em&gt;) which then will be mapped to an full argument (&lt;em&gt;argument1&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;If the endpoint it updated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getarguments&amp;quot;, (IConfiguration config) =&amp;gt;
{
    return new
    {
        Argument1 = config[&amp;quot;argument1&amp;quot;],
        Argument2 = config[&amp;quot;argument2&amp;quot;],
        Arg1 = config[&amp;quot;arg1&amp;quot;],
        Arg2 = config[&amp;quot;arg2&amp;quot;]
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when executing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt; dotnet run --arg1=hello --arg2=world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The response is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;argument1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;argument2&amp;quot;: &amp;quot;world&amp;quot;,
  &amp;quot;arg1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;arg2&amp;quot;: &amp;quot;world&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The value supplied for &lt;em&gt;arg1&lt;/em&gt;, is available through &lt;em&gt;IConfiguration[&amp;quot;arg1&amp;quot;]&lt;/em&gt; as well as &lt;em&gt;IConfiguration[&amp;quot;argument1&amp;quot;]&lt;/em&gt;, thanks to the &lt;code&gt;switch mapping!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If the dashes are omitted:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt; dotnet run arg1=hello arg2=world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the response is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;argument1&amp;quot;: null,
  &amp;quot;argument2&amp;quot;: null,
  &amp;quot;arg1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;arg2&amp;quot;: &amp;quot;world&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The arguments are still available through the normal base configuration mechanism using &lt;em&gt;IConfiguration[&amp;quot;arg1&amp;quot;]&lt;/em&gt; but are &lt;strong&gt;not&lt;/strong&gt; mapped to, and available through, &lt;em&gt;IConfiguration[&amp;quot;argument1&amp;quot;]&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="short-key"&gt;Short key&lt;/h2&gt;
&lt;p&gt;Just as with aliases, it is also possible to map an argument to &lt;code&gt;short key&lt;/code&gt; using a single dash prefix &lt;code&gt;-&lt;/code&gt;. The setup is the same as described above with aliases:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define the mappings between the alias and the argument
Dictionary&amp;lt;string, string&amp;gt; mappings = new Dictionary&amp;lt;string, string&amp;gt;()
{
    [&amp;quot;--arg1&amp;quot;] = &amp;quot;argument1&amp;quot;,
    [&amp;quot;--arg2&amp;quot;] = &amp;quot;argument2&amp;quot;,
    [&amp;quot;-a1&amp;quot;] = &amp;quot;argument1&amp;quot;,
    [&amp;quot;-a2&amp;quot;] = &amp;quot;argument2&amp;quot;,
};
// explicitly call AddCommandLine with the mappings
builder.Configuration.AddCommandLine(args, mappings);

// build the application
var app = builder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the updated endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/getarguments&amp;quot;, (IConfiguration config) =&amp;gt;
{
    return new
    {
        Argument1 = config[&amp;quot;argument1&amp;quot;],
        Argument2 = config[&amp;quot;argument2&amp;quot;],
        Arg1 = config[&amp;quot;arg1&amp;quot;],
        Arg2 = config[&amp;quot;arg2&amp;quot;],
        a1 = config[&amp;quot;a1&amp;quot;],
        a2 = config[&amp;quot;a2&amp;quot;]
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Short keys&lt;/code&gt; also are used in the similar way to aliases, but with a &lt;code&gt;single dash&lt;/code&gt; and a &lt;code&gt;space instead of equals (=)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet run -a1 hello -a2 world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The response from the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;argument1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;argument2&amp;quot;: &amp;quot;world&amp;quot;,
  &amp;quot;arg1&amp;quot;: null,
  &amp;quot;arg2&amp;quot;: null,
  &amp;quot;a1&amp;quot;: null,
  &amp;quot;a2&amp;quot;: null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A single dash switch value cannot be access directly, as seen in the above results which reflect &lt;code&gt;null&lt;/code&gt; when trying to access the values directly. The short keys have to be mapped to and accessed via the full key.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="mix-and-match"&gt;Mix and match&lt;/h2&gt;
&lt;p&gt;The various techniques can be mixed and match when supplying the value to the command lines. All of the below options will yield the same (simplified) output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt; dotnet run --argument1=hello --arg2 world
 dotnet run -a1 hello --arg2=world
 dotnet run --arg1=hello -a2 world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;argument1&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;argument2&amp;quot;: &amp;quot;world&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;If your application requires command line argument - consider configuring &lt;code&gt;alias keys&lt;/code&gt; and &lt;code&gt;short keys&lt;/code&gt;. They are simple to configure, and provide an easier, quicker and more convenient way to pass in arguments to the application for the end user.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline?view=dotnet-plat-ext-6.0#microsoft-extensions-configuration-commandlineconfigurationextensions-addcommandline(microsoft-extensions-configuration-iconfigurationbuilder-system-string()-system-collections-generic-idictionary((system-string-system-string)))"&gt;CommandLineConfigurationExtensions.AddCommandLine Method&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;165: 21-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Representing an external operation with TaskCompletionSource</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/20-taskcompletionsource</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/20-taskcompletionsource</guid>
			<pubDate>Tue, 20 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;TaskCompletionSource&lt;/code&gt; instance can be used to represent an external asynchronous operation, allowing the external operation to be &lt;em&gt;awaited&lt;/em&gt; on.&lt;/p&gt;
&lt;p&gt;This is especially useful when required to wait on a callback method to be invoked before proceeding with the execution of code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="requirement"&gt;Requirement&lt;/h2&gt;
&lt;p&gt;Consider the use case where an application can request that a file (containing website information in this example) be created asynchronous. Once the file is created, a callback handler method will be invoked to notify the caller that the file has been created.&lt;/p&gt;
&lt;p&gt;Consider the below async method to request the file. The calling application has no control over this method - it just calls the &lt;em&gt;RequestFileCreation&lt;/em&gt; method, specifying the &lt;em&gt;folder&lt;/em&gt; and the &lt;em&gt;callback event&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Task RequestFileCreation(string folder, Func&amp;lt;string, Task&amp;gt; callback)
{
    Task.Run(async () =&amp;gt;
    {
        // simulate the time it takes to create the file!
        await Task.Delay(1000);

        // invoke the callback method, notifying the called
        // the file has been created
        // filename is hardcoded in the example
        await callback.Invoke(&amp;quot;alwaysdeveloping.txt&amp;quot;);
    });

    return Task.CompletedTask;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the method is invoked, a separate task is created (and not &lt;em&gt;awaited&lt;/em&gt;) to run a process to have the file created asynchronously. Once the file is created, the specified callback back is invoked.&lt;/p&gt;
&lt;p&gt;The issue with this approach is that when invoking the &lt;code&gt;RequestFileCreation&lt;/code&gt; method there is &lt;code&gt;no reliable way to wait for the file to be created&lt;/code&gt; if we need to perform some additional processing on the file after it has been created:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task GetWebsiteInformation()
{
    Console.WriteLine($&amp;quot;Start of '{nameof(GetWebsiteInformation)}' method&amp;quot;);

    // call the method to request the file be created
    // the await is NOT awaiting the creation of the file, but is 
    // awaiting the request to create the file
    await RequestFileCreation(&amp;quot;C:\\inputfiles&amp;quot;, (file) =&amp;gt;
    {
        Console.WriteLine($&amp;quot;File '{file}' processed successfully&amp;quot;);

        return Task.CompletedTask;
    });

    // Need to do some additional processing based on the
    // contents of the file here

    Console.WriteLine($&amp;quot;End of '{nameof(GetWebsiteInformation)}' method&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When executed, the result is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Start of 'GetWebsiteInformation' method
End of 'GetWebsiteInformation' method
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is executed and exits &lt;code&gt;without waiting for the file to be created and subsequent processing to be done&lt;/code&gt;. We need a way to &lt;code&gt;wait for the file to be created&lt;/code&gt;, before performing additional processing and exiting the method.&lt;/p&gt;
&lt;p&gt;This is exactly the situation &lt;code&gt;TaskCompletionSource&lt;/code&gt; is able to solve!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="taskcompletionsource"&gt;TaskCompletionSource&lt;/h2&gt;
&lt;p&gt;Incorporating the &lt;code&gt;TaskCompletionSource&lt;/code&gt; into the process is very straight forward.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;RequestFileCreation&lt;/em&gt; method remains exactly as it was above, but the &lt;code&gt;GetWebsiteInformation&lt;/code&gt; is updated to be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task GetWebsiteInformation()
{
    Console.WriteLine($&amp;quot;Start of '{nameof(GetWebsiteInformation)}' method&amp;quot;);

    // create a TaskCompletionSource&amp;lt;T&amp;gt; instance where T
    // is the return type 
    TaskCompletionSource&amp;lt;string&amp;gt; tcs = new TaskCompletionSource&amp;lt;string&amp;gt;();

    // in the callback handler method, call the SetResult
    // on TaskCompletionSource instance.
    await RequestFileCreation(&amp;quot;C:\\inputfiles&amp;quot;, (file) =&amp;gt;
    {
        Console.WriteLine($&amp;quot;File '{file}' processed successfully&amp;quot;);

        tcs.SetResult(file);

        return Task.CompletedTask;
    });

    Console.WriteLine($&amp;quot;Waiting for a file to be created&amp;quot;);
    // await the TaskCompletionSource instance task
    // Once the SetResult method has been set, the task will be 
    // considered completed
    var fileName = await tcs.Task;

    Console.WriteLine($&amp;quot;File created! Performing additional processing&amp;quot;);
    // Need to do some additional processing based on the
    // contents of the file here
    
    Console.WriteLine($&amp;quot;End of '{nameof(GetWebsiteInformation)}' method&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a few moving parts here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Declare an instance of &lt;em&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/em&gt; where T is the type to be returned&lt;/li&gt;
&lt;li&gt;When the callback method is invoked (once the file is created), the &lt;em&gt;SetResult&lt;/em&gt; method of &lt;em&gt;TaskCompletionSource&lt;/em&gt; is called with the information to be passed through the &lt;em&gt;TaskCompletionSource&lt;/em&gt; Task (the string filename in this example)&lt;/li&gt;
&lt;li&gt;When required to wait for the file to be created, the &lt;em&gt;TaskCompletionSource.Task&lt;/em&gt; is awaited. This task will be considered completed once the &lt;em&gt;SetResult method is called&lt;/em&gt; in the callback&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Executing the above method now has the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Start of 'GetWebsiteInformation' method
Waiting for a file to be created
File 'alwaysdeveloping.txt' processed successfully
File created! Performing additional processing
End of 'GetWebsiteInformation' method
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see, the output is exactly what we want. A request for the file to be created is initiated - the code then waits for the file to be created (the callback method being invoked), before processing continues.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="other-set-methods"&gt;Other Set methods&lt;/h2&gt;
&lt;p&gt;Not demonstrated in this post, but there are two other &lt;code&gt;Set&lt;/code&gt; methods available on the _&lt;em&gt;TaskCompletionSource&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SetException&lt;/code&gt;: transitions the underlying Task into a &lt;em&gt;Failed&lt;/em&gt; state.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetCanceled&lt;/code&gt;: transitions the underlying Task into a &lt;em&gt;Canceled&lt;/em&gt; state.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;An incredibly valuable class to be aware of when one needs to wait on an &lt;em&gt;external asynchronous operation&lt;/em&gt; (such as a callback event), while also being able to convey information out of the external operation to the scope &lt;em&gt;awaiting&lt;/em&gt; the call.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://youtu.be/N-ofc345-58?list=PLqqD43D6Mqz0AIDkHqaZDKaEKXdfMiIAo&amp;amp;t=1610"&gt;Async Web API testing with TaskCompletionSource (Microservices with .NET 6.0) - FeedR episode #11&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;164: 20-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>UTF8 string literals in C#11</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/19-string-literals</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/19-string-literals</guid>
			<pubDate>Mon, 19 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with C# 11 (being released later this year, coinciding with the .NET 7 release) the conversion from a &lt;code&gt;string literal to a byte[]&lt;/code&gt; is becoming &lt;em&gt;easier, faster, and more efficient&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The byte[] is often used in dealing with streams (for example) and with the current, and prior C# versions, the conversation from a string to byte[] required as explicit conversion. However with C#11, this conversion is simplified, but also gains a large performance boost.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-10-and-prior"&gt;C# 10 and prior&lt;/h2&gt;
&lt;p&gt;In the current (and prior) versions of C#, when a string literal is required to be converted to a byte[], the &lt;code&gt; System.Text.Encoding.X.GetBytes&lt;/code&gt; method is used (where X is the encoding method, UTF8 specifically in this post):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;byte[] bytes = System.Text.Encoding.UTF8.GetBytes(&amp;quot;alwaysdeveloping.net&amp;quot;);

using var stream = new MemoryStream();
stream.Write(bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While not especially complicated, this does involve an explicit method call to perform the conversion.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-11"&gt;C# 11&lt;/h2&gt;
&lt;p&gt;With C#11, it's possible to do this with an implicit conversion:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;

using var stream = new MemoryStream();
stream.Write(spanBytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although a &lt;em&gt;ReadOnlySpan&lt;/em&gt; can be used whereever a &lt;em&gt;byte[]&lt;/em&gt; is required, if a &lt;em&gt;byte[]&lt;/em&gt; is specifically needed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;
byte[] bytes = spanBytes.ToArray();

using var stream = new MemoryStream();
stream.Write(bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;u8&lt;/code&gt; suffix on the string, indicates to the compiler that it should convert the string value into an array of bytes - or more specifically in this case, a &lt;code&gt;ReadOnlySpan of bytes&lt;/code&gt;. Using a &lt;em&gt;ReadOnlySpan&lt;/em&gt; is more efficient and uses no additional memory - but if a byte[] is specifically required, the &lt;em&gt;ToArray&lt;/em&gt; method can be leveraged to get a &lt;em&gt;byte[]&lt;/em&gt; from the &lt;em&gt;ReadOnlySpan&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Below are a couple of simple benchmarks run to compare the performance and memory usage of the old and new methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
[Benchmark(Baseline = true)]
public void GetBytes()
{
    byte[] bytes = System.Text.Encoding.UTF8.GetBytes(&amp;quot;alwaysdeveloping.net&amp;quot;);
}

[Benchmark]
public void StringLiteral()
{
    ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GetBytes&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.5843 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4163 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6956 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.6017 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0076&lt;/td&gt;
&lt;td style="text-align: right;"&gt;48 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringLiteral&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0198 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0209 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0241 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0085 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.001&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As one can see, the new method is &lt;code&gt;exponentially faster&lt;/code&gt; and requires &lt;code&gt;zero additional memory&lt;/code&gt; when compared with the current method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="extend-features"&gt;Extend features&lt;/h2&gt;
&lt;p&gt;In the initial announcement and previews of this feature, the implicit conversion was done without specifying the &lt;code&gt;u8&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;byte[] array = &amp;quot;hello&amp;quot;;  
Span&amp;lt;byte&amp;gt; span = &amp;quot;dog&amp;quot;; 
ReadOnlySpan&amp;lt;byte&amp;gt; span = &amp;quot;cat&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, in subsequent previews, the &lt;code&gt;u8&lt;/code&gt; was added to specifically indicate that the string literal should be converted to &lt;em&gt;UTF8&lt;/em&gt;. Hopefully in future C# language updates, more encoding methods are added, to at least bring this feature on par with using &lt;em&gt;System.Text.Encoding.X.GetBytes&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small update on the surface, but if your application makes heavy use of string literals and encoding, converting to this new feature should gain you a performance boost.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://gsferreira.com/archive/2022/csharp-11-utf-8-string-literals-ignore-everything-you-have-seen-so-far/"&gt;Literals - Ignore everything you have seen so far&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#utf-8-string-literals"&gt;C# 11 Preview Updates – Raw string literals, UTF-8 and more!&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;163: 19-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Application lifetime events with IHostApplicationLifetime</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/16-application-lifetime</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/16-application-lifetime</guid>
			<pubDate>Fri, 16 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Application &lt;code&gt;OnStarted&lt;/code&gt;, &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; event handlers can be registered using the &lt;code&gt;IHostApplicationLifetime&lt;/code&gt; interface (and implementation), to run logic when the application &lt;em&gt;starts&lt;/em&gt;, is &lt;em&gt;stopping&lt;/em&gt; and has &lt;em&gt;stopped&lt;/em&gt; respectively.&lt;/p&gt;
&lt;p&gt;Zero or many event handlers can dynamically be registered to handle the required logic at the correct application lifetime event.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="registering-handlers"&gt;Registering handlers&lt;/h2&gt;
&lt;?# InfoBlock ?&gt;
&lt;p&gt;The &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; events are &lt;strong&gt;NOT&lt;/strong&gt; called when debugging the application using Visual Studio. The application has to be run using &lt;code&gt;dotnet run&lt;/code&gt; from the command line to have these events successfully invoked whilst developing. More on this below under the &lt;em&gt;Graceful shutdown&lt;/em&gt; section.&lt;/p&gt;
&lt;?#/ InfoBlock ?&gt;
&lt;h3 id="api"&gt;Api&lt;/h3&gt;
&lt;p&gt;Registering callback handlers for the events is done by injecting &lt;code&gt;IHostApplicationLifetime&lt;/code&gt;, and calling the &lt;em&gt;Register&lt;/em&gt; method on the relevent &lt;em&gt;CancellationToken&lt;/em&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Define an endpoint, which when called will register a callback
// method for each of the events
app.MapGet(&amp;quot;/registerevents&amp;quot;, (
    IHostApplicationLifetime hostApplicationLifetime) =&amp;gt;
{
    // register each of the events
    hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
    hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
    hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
});

app.Run();

void OnStarted()
{
    Console.WriteLine(&amp;quot;Application OnStarted - api&amp;quot;);
}

void OnStopping()
{
    Console.WriteLine(&amp;quot;Application OnStopping - api&amp;quot;);
}

void OnStopped()
{
    Console.WriteLine(&amp;quot;Application OnStopped - api&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the application (using &lt;em&gt;dotnet run&lt;/em&gt;) and then closing the application (using &lt;code&gt;Ctrl-C&lt;/code&gt;) &lt;em&gt;without calling the endpoint&lt;/em&gt;, will result in &lt;em&gt;no callback events being called&lt;/em&gt; - as none have been registered.&lt;/p&gt;
&lt;p&gt;However executing the application, and invoking the &lt;code&gt;/registerevents&lt;/code&gt; endpoint, will result in the &lt;em&gt;OnStarted&lt;/em&gt; callback event being called immediately, and the other two &lt;em&gt;OnClosing&lt;/em&gt; and &lt;em&gt;OnClosed&lt;/em&gt; events called when the application is shutdown. The output of the application (other logging output removed):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Application OnStarted - api
Application OnStopping - api
Application OnStopped - api
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="worker"&gt;Worker&lt;/h3&gt;
&lt;p&gt;Callback events can also be registered with &lt;code&gt;background/worker&lt;/code&gt; services when they are instantiated. Updating the default .NET Worker template:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Worker : BackgroundService
{
    private readonly ILogger&amp;lt;Worker&amp;gt; _logger;

    private readonly IHostApplicationLifetime _hostApplicationLifetime;

    // inject IHostApplicationLifetime
    public Worker(ILogger&amp;lt;Worker&amp;gt; logger, IHostApplicationLifetime hostApplicationLifetime)
    {
        _logger = logger;
        _hostApplicationLifetime = hostApplicationLifetime;

        // register the callback methods
        _hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
        _hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
        _hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation(&amp;quot;Worker running at: {time}&amp;quot;, DateTimeOffset.Now);
            await Task.Delay(1000, stoppingToken);
        }
    }

    private void OnStarted()
    {
        Console.WriteLine(&amp;quot;Application OnStarted - worker&amp;quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine(&amp;quot;Application OnStopping - worker&amp;quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine(&amp;quot;Application OnStopped - worker&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This background service can be registered in the same api application used in the previous minimal api example, using:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddHostedService&amp;lt;Worker&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now executing the application, invoking the endpoint and then closing the application will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Application OnStarted - worker
Application OnStarted - api
Application OnStopping - api
Application OnStopping - worker
Application OnStopped - api
Application OnStopped - worker
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="graceful-shutdown"&gt;Graceful shutdown&lt;/h2&gt;
&lt;p&gt;While the &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; events are useful for performing logic when the application is &lt;em&gt;stopping&lt;/em&gt; and &lt;em&gt;stopped&lt;/em&gt; - these events are only called in the case of a &lt;code&gt;graceful shutdown&lt;/code&gt;. For example, in the case when debugging using Visual Studio - when the debugging session is stopped, a graceful shutdown is &lt;strong&gt;not&lt;/strong&gt; performed, and as such the stopping/stopped events are not invoked. &lt;code&gt;Application functionality should not assume that the 'OnStopping' and 'OnStopped' events will always be called.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The two closing events &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; are especially useful, and can be leveraged to perform application cleanup tasks on closing (while not depending on them always being executing). For example, clearing any lingering cache files, or persisting any in memory logs to disk can be executing when the application is stopping/stopped.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-6.0#ihostapplicationlifetime"&gt;IHostApplicationLifetime&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;162: 16-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Streaming responses from a minimal api </title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/15-min-api-yield</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/15-min-api-yield</guid>
			<pubDate>Thu, 15 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Using &lt;em&gt;&amp;quot;usual techniques&amp;quot;&lt;/em&gt;, it is not possible to stream a response from a minimal api, as the &lt;code&gt;yield keyword cannot be used inside an anonymous method or lambda expression&lt;/code&gt;. To work around this limitation, a &lt;code&gt;local function&lt;/code&gt; can be created which returns &lt;em&gt;IAsyncEnumerable&lt;/em&gt;, and the local function result in turn, is returned from the minimal api.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limitation"&gt;Limitation&lt;/h2&gt;
&lt;p&gt;Suppose we need to define an endpoint, which when called will stream a &lt;em&gt;bool response&lt;/em&gt; indicating if current date time minute is 13 or not (not very practical or useful, but will work for demo purposes):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/isminute13&amp;quot;, async () =&amp;gt;
{
    // when the endpoint is called, loop until
    // the user cancels
    while (true)
    {
        // return a bool indicating if the current minute is 13
        yield return (DateTime.Now.Minute == 13);

        // wait 1 second, and repeat
        await Task.Delay(1000);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue here, is that it &lt;code&gt;does not compile&lt;/code&gt;, as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The yield statement cannot be used inside an anonymous method or lambda expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, there is a way around this constraint of the lambda expression!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="local-function"&gt;Local function&lt;/h2&gt;
&lt;p&gt;The error itself gives a clue on how to solve the problem - yield cannot be used inside a &lt;em&gt;anonymous method or lambda expression&lt;/em&gt;, so &lt;code&gt;why don't not instead create and use a non-anonymous method!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/isminute13&amp;quot;, () =&amp;gt;
{
    // move all previous logic into this local method
    async IAsyncEnumerable&amp;lt;bool&amp;gt; DateTimeStream()
    {
        while (true)
        {
            yield return (DateTime.Now.Minute == 13);
            await Task.Delay(1000);
        }
    }

    // return the result of the method
    return DateTimeStream();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above code, and calling the endpoint will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[false,false,false,false,false,false,false,false,false,true,true,true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every second a new bool will be appended to the response, indicating if the minute is 13 or not.&lt;/p&gt;
&lt;p&gt;Simple, easy solution with minimal additional coding!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Streaming responses from an api is not something I've seen leveraged much before - however with the simplicity of configuring a minimal api for streaming, it is quick and easy to get an application up and running to determine if streaming can add value to the application or business.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidfowl/status/1436706303586410503"&gt;David Fowler Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;161: 15-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Auto-default struct property values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/14-struct-default</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/14-struct-default</guid>
			<pubDate>Wed, 14 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with C# 11 (being released later this year, coinciding with the .NET 7 release) the compiler will now ensure that &lt;code&gt;fields on a struct will be initialized to their default value&lt;/code&gt; if not explicitly set.&lt;/p&gt;
&lt;p&gt;With the current, and prior C# versions, all fields on a struct need to explicitly be set when a struct instance is initialized using a defined constructor.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-10-and-prior"&gt;C# 10 and prior&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Song&lt;/em&gt; struct, which contains a number of properties related to a Song:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct Song
{
    public int Id { get; init; }

    public string Name { get; init; }

    // this property is required to have
    // a default value
    public string Artist { get; init; } = &amp;quot;Unavailable&amp;quot;;

    // this property is required to have
    // a default value
    public int SongLength { get; init; } = 0;

    // As this constructor doesn't set all properties
    // those unset properties need an explicit default value
    public Song(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public Song(int id, string name, string artist, int length)
    {
        Id = id;
        Name = name;
        Artist = artist;
        SongLength = length;
    }

    public override string ToString() =&amp;gt; $&amp;quot;{Id}: Song with name '{Name}' &amp;quot; +
        $&amp;quot;by '{Artist}' is {SongLength} seconds long&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, the &lt;em&gt;Artist&lt;/em&gt; and &lt;em&gt;SongLength&lt;/em&gt; properties need to &lt;code&gt;explicitly have a default value set&lt;/code&gt;, as there is a constructor which does not set them.&lt;/p&gt;
&lt;p&gt;If the default values are removed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public string Artist { get; init; } 

public int SongLength { get; init; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then a compiler error will occur:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Auto-implemented property 'Song.Artist' must be fully assigned before 
    control is returned to the caller. Consider updating to language 
    version '11.0' to auto-default the property.	
Auto-implemented property 'Song.SongLength' must be fully assigned 
    before control is returned to the caller. Consider updating to language 
    version '11.0' to auto-default the property.	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error even has a suggestion on how to resolve the issue (assuming you have C# 11 preview version installed).&lt;/p&gt;
&lt;p&gt;For completeness, here is an example of using the above struct:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(1, &amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 469);
Console.WriteLine(song);

var halfSong = new Song(1, &amp;quot;Everlong&amp;quot;);
Console.WriteLine(halfSong);

var defaultSong = default(Song);
Console.WriteLine(defaultSong);

var blankSong = new Song();
Console.WriteLine(blankSong);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1: Song with name 'Everlong' by 'Foo Fighters' is 469 seconds long
1: Song with name 'Everlong' by 'Unavailable' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output, one can see that when calling one of the &lt;code&gt;defined constructors&lt;/code&gt;, all the properties need to be &lt;code&gt;explicitly set&lt;/code&gt; - either in the constructor itself, or with a default value. However when using one of the &lt;code&gt;other techniques to instantiate&lt;/code&gt;, the property values &lt;code&gt;will be set to the type's default value&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-11"&gt;C# 11&lt;/h2&gt;
&lt;p&gt;When using C# 11 (currently this means having a preview version of .NET7 installer, and updating the csproj file to contain &lt;code&gt;&amp;lt;LangVersion&amp;gt;preview&amp;lt;/LangVersion&amp;gt;&lt;/code&gt;), the struct can be updated to be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct Song
{
    public int Id { get; init; }

    public string Name { get; init; }

    // now these properties don't require
    // a default value
    public string Artist { get; init; }

    public int SongLength { get; init; }

    public Song(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public Song(int id, string name, string artist, int length)
    {
        Id = id;
        Name = name;
        Artist = artist;
        SongLength = length;
    }

    public override string ToString() =&amp;gt; $&amp;quot;{Id}: Song with name '{Name}' &amp;quot; +
        $&amp;quot;by '{Artist}' is {SongLength} seconds long&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when instantiated, &lt;code&gt;not all properties of the struct need to be explicitly set&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Executing the same sample code as above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(1, &amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 469);
Console.WriteLine(song);

var halfSong = new Song(1, &amp;quot;Everlong&amp;quot;);
Console.WriteLine(halfSong);

var defaultSong = default(Song);
Console.WriteLine(defaultSong);

var blankSong = new Song();
Console.WriteLine(blankSong);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1: Song with name 'Everlong' by 'Foo Fighters' is 469 seconds long
1: Song with name 'Everlong' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling a defined constructor which doesn't set all properties, &lt;code&gt;the unset properties will be set to the type's default value&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A minor update to the language, but which will result in a more familiar, intuitive and expected experience for the experienced C# developer, which have worked with previous versions of the the runtime, and are familiar with the behavior of classes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dev.to/dotnetsafer/5-new-c-11-features-you-might-have-missed-32d8"&gt;Auto-default struct&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;160: 14-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Correlation using the Activity class</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</guid>
			<pubDate>Tue, 13 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with &lt;code&gt;distributed systems&lt;/code&gt;, the built in &lt;code&gt;Activity&lt;/code&gt; class can be used to automatically correlate requests across the various systems.&lt;/p&gt;
&lt;p&gt;For each unique request to an api (for example) a new activity root id is generated. If however, the specific api makes a call into another api, the activity root id is persisted across the http call, allowing the two calls to be linked together and related together when querying or reporting on the data.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-endpoint"&gt;Single endpoint&lt;/h2&gt;
&lt;p&gt;First, we'll look at how to get access to the &lt;code&gt;activity id&lt;/code&gt;. To do this we generate a simple minimal endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, (IHttpClientFactory httpFactory) =&amp;gt;
{
    // Output the root Id, and the current Id
     Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the static &lt;code&gt;Activity&lt;/code&gt; class is used, to access the &lt;em&gt;Current&lt;/em&gt; activity, and output the &lt;em&gt;Root Id&lt;/em&gt; as well as the &lt;em&gt;Id&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Calling the endpoint a few times, results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id: 319d4ff500ce3100c2a3017531e023e4 | Id: 00-319d4ff500ce3100c2a3017531e023e4-e4c21e8cfae4db47-00
Root Id: 7de97ec9692106503aaabab105951bdf | Id: 00-7de97ec9692106503aaabab105951bdf-fa3c7b807eda8800-00
Root Id: e1868729b9f3db8c40942ffb1daf24c9 | Id: 00-e1868729b9f3db8c40942ffb1daf24c9-79de739f0d38d58c-00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time the endpoint is invoked, and new &lt;em&gt;Root Id and Id&lt;/em&gt; is generated, with the &lt;em&gt;Id&lt;/em&gt; containing the &lt;em&gt;Root Id&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-endpoints"&gt;Multiple endpoints&lt;/h2&gt;
&lt;p&gt;Next, we define a second endpoint - for this example the second endpoint is defined in the same project as the first endpoint, but the exact same behavior would be experienced if the endpoint was contained in a separate application.&lt;/p&gt;
&lt;p&gt;This second endpoint will return it's &lt;em&gt;Root Id and Id&lt;/em&gt; as a string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint2&amp;quot;, () =&amp;gt;
{
    return $&amp;quot;Second Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Second Id: {Activity.Current.Id}&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we update the first endpoint to call the second endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
        Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    // call the second endpoint
    var client = httpFactory.CreateClient();
    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);

    // output the response (which contains the Id's)
    // from the second endpoint
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    Console.WriteLine(&amp;quot;------&amp;quot;);

    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when the first endpoint is called, we see the following (formatted to make it easier to compare):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        8f1e949168197f1185135e963eab68bc | Unit Id:   00-8f1e949168197f1185135e963eab68bc-2adc30476d372b95-00
Second Root Id: 8f1e949168197f1185135e963eab68bc | Second Id: 00-8f1e949168197f1185135e963eab68bc-d18ddb27c96b1a1b-00
------
Root Id:        2b39afb72f3773289d8d141b2ef030d4 | Unit Id:   00-2b39afb72f3773289d8d141b2ef030d4-77be0c303ee8028a-00
Second Root Id: 2b39afb72f3773289d8d141b2ef030d4 | Second Id: 00-2b39afb72f3773289d8d141b2ef030d4-66e8aa928caf5619-00
------
Root Id:        46d2eedeacdfe46a89888598886a5186 | Unit Id:   00-46d2eedeacdfe46a89888598886a5186-f7e42f6b6d868069-00
Second Root Id: 46d2eedeacdfe46a89888598886a5186 | Second Id: 00-46d2eedeacdfe46a89888598886a5186-1af4f5b27e45f9f7-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the &lt;code&gt;root id is the same across the http call&lt;/code&gt;, even though it is being returned from a separate endpoint in another service. The &lt;em&gt;Unit Id&lt;/em&gt; portion of the &lt;em&gt;Id&lt;/em&gt; changes though, indicating a smaller unit of work is being performed as part of the larger &lt;em&gt;root&lt;/em&gt; piece of work.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="child-activity"&gt;Child activity&lt;/h2&gt;
&lt;p&gt;We've seen how the the &lt;em&gt;Root Id&lt;/em&gt; is shared across http calls - now we look at how to get the same functionality when performing smaller units of work not involving http calls.&lt;/p&gt;
&lt;p&gt;Once again we update first endpoint, this time to start a child activity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
    Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    var client = httpFactory.CreateClient();

    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    
    // start with the child activity
    using var childActivity = new Activity(&amp;quot;MessagePublishing&amp;quot;);
    childActivity.Start();

    // a message is published to a message broker here, with the 
    // Id as metadata/correlationId
    Console.WriteLine($&amp;quot;Child Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Child Id: {Activity.Current.Id}&amp;quot;);

    childActivity.Stop();
    Console.WriteLine(&amp;quot;------&amp;quot;);

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here a child activity is manually started, and within the scope of the child activity - a message is published to a message broker (for example).&lt;/p&gt;
&lt;p&gt;Invoking the endpoint now results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        00a695a71d140a4105750a0cb04d9408 | Id:        00-00a695a71d140a4105750a0cb04d9408-4aba3488957c9a75-00
Second Root Id: 00a695a71d140a4105750a0cb04d9408 | Second Id: 00-00a695a71d140a4105750a0cb04d9408-e29b9eb28fe6d34f-00
Child Root Id:  00a695a71d140a4105750a0cb04d9408 | Child Id:  00-00a695a71d140a4105750a0cb04d9408-2a6e2ad5d7916142-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the above, we can see that manually declaring and &lt;em&gt;starting&lt;/em&gt; an activity will result in a &lt;em&gt;new Id&lt;/em&gt; to be generated, but using the same &lt;em&gt;Root Id&lt;/em&gt; as the parent.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="why-the-need"&gt;Why the need?&lt;/h2&gt;
&lt;p&gt;So why the need for a &lt;em&gt;Root Id&lt;/em&gt; and &lt;em&gt;correlation&lt;/em&gt; - all of this is to &lt;code&gt;gain better observability into how an application is performing&lt;/code&gt;. This data can be output and collected, either using industry standard tools and formatting (&lt;a href="https://opentelemetry.io/"&gt;for example OpenTelemetry&lt;/a&gt;), or by rolling our one's own reporting database - either way though, this provides insight into how each portion of a larger distributed transaction are linked together, and how each portion is performing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Distributed systems can become very complex, and observability is key in managing the stability and performance of the various systems - the &lt;code&gt;Activity&lt;/code&gt; class provides an easy, simple way to manage the correlation between the various systems and processes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.activity?view=net-6.0"&gt;Activity Class&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;159: 13-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Constructors with default values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</guid>
			<pubDate>Mon, 12 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Constructor and minimal api parameters&lt;/code&gt; can have &lt;code&gt;default values&lt;/code&gt;, allowing for dependency injection to work - while not actually working. Specifying a default value allows for the application to &lt;em&gt;run with a default implementation&lt;/em&gt; even if the services has not been registered with the dependency injection container.&lt;/p&gt;
&lt;p&gt;This is not something one would usually do as a standard practice, but in specific use cases it does have a place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;In the below examples, we have an interface, and a couple of implementations:&lt;/p&gt;
&lt;p&gt;The interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IDependencyInterface 
{
    string GetName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// a default implementation
public class DefaultImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(DefaultImplementation);
    }
}

// and another implementation
public class OtherImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(OtherImplementation);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="injection"&gt;Injection&lt;/h3&gt;
&lt;p&gt;Usually to make use of the functionality provided by the interface and the associated implementation, the service is registered with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Depending on the implementation the application requires:
builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
// OR
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then is injected into the relevent constructor, or minimal api delegate in the below sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// explicitly tell it to get the IDependencyInterface implementation
// from the DI service collection
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface injected) =&amp;gt;
{
    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="di-assumption"&gt;DI Assumption&lt;/h3&gt;
&lt;p&gt;In the above setup, the runtime assumes that the necessary registrations with the dependency injection container have take place. If neither of the following registrations are  done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when trying to inject &lt;em&gt;IDependencyInterface&lt;/em&gt;, the following error will be experienced:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;InvalidOperationException: No service for type 'IDependencyInterface' has been registered.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We've told the runtime and dependency injection container to &lt;em&gt;inject the IDependencyInterface implementation, but have not made it aware of any implementations!&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-value"&gt;Default value&lt;/h3&gt;
&lt;p&gt;Generally if in control of the entire dependency injection container registration, one should ensure that the required registrations are performed, and the error is resolved.&lt;/p&gt;
&lt;p&gt;However, in some cases this might not be possible - for example if developing a library package, there is no direct control over what the developer configures with the dependency injection container.&lt;br /&gt;
As a developer of the library package, one could just allow the exception to occur, which directs the developer to configure the dependency injection container correctly. Another, arguably more developer friendly technique, is to &lt;code&gt;automatically set a default implementation if one is not explicitly set&lt;/code&gt;. This does require a few updates to the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// make the parameter nullable, the default value will be null.
// In the case of a constructor (vs this minimal api delegate)
// the value can explicitly be set to null if desired:
// IDependencyInterface? injected = null
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface? injected) =&amp;gt;
{
    // if it is null, set it to the default implementation
    injected ??= new DefaultImplementation();

    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two changes are made to code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the parameter as &lt;code&gt;nullable&lt;/code&gt; using the &lt;code&gt;?&lt;/code&gt; operator&lt;/li&gt;
&lt;li&gt;Instantiate the parameter to the &lt;code&gt;default implementation&lt;/code&gt; if the value of the parameter is null&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now if &lt;code&gt;no implementation is registered&lt;/code&gt; for IDependencyInterface, the application will still function and use the &lt;code&gt;default implementation&lt;/code&gt; specified.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, this is not a practice which is generally recommended - however in the case of developing an external library (which requires a dependency), there is no guarantee the host application has injected the required dependencies. By making use of &lt;code&gt;default values&lt;/code&gt; the library will &lt;em&gt;still function with default configuration&lt;/em&gt;, but allows for &lt;code&gt;specific implementations to be overwritten&lt;/code&gt; by the developer if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/CFDevelop/status/1556055501661929472"&gt;Christian Findlay Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;158: 12-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>