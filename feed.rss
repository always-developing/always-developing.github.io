<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Mon, 19 Sep 2022 05:12:28 GMT</pubDate>
		<lastBuildDate>Mon, 19 Sep 2022 05:12:28 GMT</lastBuildDate>
		<item>
			<title>UTF8 string literals in C#11</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/19-string-literals</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/19-string-literals</guid>
			<pubDate>Mon, 19 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with C# 11 (being released later this year, coinciding with the .NET 7 release) the conversion from a &lt;code&gt;string literal to a byte[]&lt;/code&gt; is becoming &lt;em&gt;easier, faster, and more efficient&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The byte[] is often used in dealing with streams (for example) and with the current, and prior C# versions, the conversation from a string to byte[] required as explicit conversion. However with C#11, this conversion is simplified, but also gains a large performance boost.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-10-and-prior"&gt;C# 10 and prior&lt;/h2&gt;
&lt;p&gt;In the current (and prior) versions of C#, when a string literal is required to be converted to a byte[], the &lt;code&gt; System.Text.Encoding.X.GetBytes&lt;/code&gt; method is used (where X is the encoding method, UTF8 specifically in this post):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;byte[] bytes = System.Text.Encoding.UTF8.GetBytes(&amp;quot;alwaysdeveloping.net&amp;quot;);

using var stream = new MemoryStream();
stream.Write(bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While not especially complicated, this does involve an explicit method call to perform the conversion.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-11"&gt;C# 11&lt;/h2&gt;
&lt;p&gt;With C#11, it's possible to do this with an implicit conversion:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;

using var stream = new MemoryStream();
stream.Write(spanBytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although a &lt;em&gt;ReadOnlySpan&lt;/em&gt; can be used whereever a &lt;em&gt;byte[]&lt;/em&gt; is required, if a &lt;em&gt;byte[]&lt;/em&gt; is specifically needed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;
byte[] bytes = spanBytes.ToArray();

using var stream = new MemoryStream();
stream.Write(bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;u8&lt;/code&gt; suffix on the string, indicates to the compiler that it should convert the string value into an array of bytes - or more specifically in this case, a &lt;code&gt;ReadOnlySpan of bytes&lt;/code&gt;. Using a &lt;em&gt;ReadOnlySpan&lt;/em&gt; is more efficient and uses no additional memory - but if a byte[] is specifically required, the &lt;em&gt;ToArray&lt;/em&gt; method can be leveraged to get a &lt;em&gt;byte[]&lt;/em&gt; from the &lt;em&gt;ReadOnlySpan&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;Below are a couple of simple benchmarks run to compare the performance and memory usage of the old and new methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
[Benchmark(Baseline = true)]
public void GetBytes()
{
    byte[] bytes = System.Text.Encoding.UTF8.GetBytes(&amp;quot;alwaysdeveloping.net&amp;quot;);
}

[Benchmark]
public void StringLiteral()
{
    ReadOnlySpan&amp;lt;byte&amp;gt; spanBytes = &amp;quot;alwaysdeveloping.net&amp;quot;u8;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen 0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GetBytes&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.5843 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4163 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6956 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;19.6017 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0076&lt;/td&gt;
&lt;td style="text-align: right;"&gt;48 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringLiteral&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0198 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0209 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0241 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0085 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.001&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As one can see, the new method is &lt;code&gt;exponentially faster&lt;/code&gt; and requires &lt;code&gt;zero additional memory&lt;/code&gt; when compared with the current method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="extend-features"&gt;Extend features&lt;/h2&gt;
&lt;p&gt;In the initial announcement and previews of this feature, the implicit conversion was done without specifying the &lt;code&gt;u8&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;byte[] array = &amp;quot;hello&amp;quot;;  
Span&amp;lt;byte&amp;gt; span = &amp;quot;dog&amp;quot;; 
ReadOnlySpan&amp;lt;byte&amp;gt; span = &amp;quot;cat&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, in subsequent previews, the &lt;code&gt;u8&lt;/code&gt; was added to specifically indicate that the string literal should be converted to &lt;em&gt;UTF8&lt;/em&gt;. Hopefully in future C# language updates, more encoding methods are added, to at least bring this feature on par with using &lt;em&gt;System.Text.Encoding.X.GetBytes&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small update on the surface, but if your application makes heavy use of string literals and encoding, converting to this new feature should gain you a performance boost.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://gsferreira.com/archive/2022/csharp-11-utf-8-string-literals-ignore-everything-you-have-seen-so-far/"&gt;Literals - Ignore everything you have seen so far&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#utf-8-string-literals"&gt;C# 11 Preview Updates – Raw string literals, UTF-8 and more!&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;163: 19-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Automatic redirect on http status code</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/10/10-status-code-pages</guid>
			<pubDate>Mon, 19 Sep 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;UseStatusCodePagesWithRedirects&lt;/code&gt; method can be used to redirect the client to an error page in the case of a non-successful request (400-599 range)&lt;/p&gt;
&lt;p&gt;This method returns a &lt;em&gt;301-Found&lt;/em&gt; to the client, and then redirects to the &lt;em&gt;redirect endpoint&lt;/em&gt; which will return a status code of &lt;em&gt;200-Success&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is often used when the app:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should redirect the client to a different endpoint, perhaps to have a different application process the error. In the browser, the redirect endpoint will be reflected&lt;/li&gt;
&lt;li&gt;Doesn't need to preserve and return the original status code with the initial redirect response back to the client&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="middleware-setup"&gt;Middleware setup&lt;/h2&gt;
&lt;p&gt;First step is to enable the automatic redirect functionality - this step is very straight-froward, and entails adding a single middleware components:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = builder.Build();

// other middleware setup goes here
app.UseStatusCodePagesWithRedirects("/error?status={0}");
// other middleware setup goes here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the middleware is instructed to redirect any responses (which are not successful) to the &lt;code&gt;/error&lt;/code&gt; endpoint. The endpoint can include a &lt;code&gt;{0}&lt;/code&gt; placeholder which will contain the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="error-endpoint"&gt;Error endpoint&lt;/h2&gt;
&lt;p&gt;Next, up the &lt;code&gt;/error&lt;/code&gt; endpoint is defined.&lt;/p&gt;
&lt;p&gt;Here the &lt;em&gt;Map&lt;/em&gt; method is used - this takes an &lt;em&gt;IApplicationBuilder&lt;/em&gt; as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.Map("/error", errorApp =&amp;gt;
{
    errorApp.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync($"This is a redirected " +
            $"error message status {context.Request.Query["status"]}");
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For all &lt;em&gt;error&lt;/em&gt; responses, the message will be output along with the &lt;em&gt;http status code&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="execution"&gt;Execution&lt;/h2&gt;
&lt;p&gt;A number of other endpoints were also defined to simulate different status code responses:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/500response", context =&amp;gt;
{
    context.Response.StatusCode = 500;
    return Task.CompletedTask;
});

app.MapGet("/401response", context =&amp;gt;
{
    context.Response.StatusCode = 401;
    return Task.CompletedTask;
});

app.MapGet("/200response", context =&amp;gt;
{
    context.Response.StatusCode = 200;
    return Task.CompletedTask;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browsing to the &lt;code&gt;/500response&lt;/code&gt; from a browser, for example, will return the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;This is a redirected error message status 500
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And looking at the &lt;em&gt;Network&lt;/em&gt; tab of the browse, one can see that the initial status code returned is &lt;code&gt;302&lt;/code&gt;, followed by the &lt;code&gt;200 on redirect&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/statuscode.png" alt="HTTP Status code"&gt;&lt;/p&gt;
&lt;p&gt;Now, on error (500 status code), the caller is routed to a generic error page, with a &lt;em&gt;200&lt;/em&gt; response, and the actual error in the content of the page.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;For a lot of situations this might not be especially useful, as the return message and status code is not especially useful to the calling application to act on.&lt;/p&gt;
&lt;p&gt;For a customer facing application this could be useful (providing the actual error is logged and recorded somewhere) as the customer doesn't care about the details of the eror, but for a backend api-to-api call, the string response is not especially useful.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dodyg/practical-aspnetcore/tree/net6.0/projects/diagnostics/diagnostics-5"&gt;Status Pages&lt;/a&gt;&lt;br&gt;
&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-6.0#usestatuscodepageswithredirects"&gt;UseStatusCodePages&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;178: 10-10-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Application lifetime events with IHostApplicationLifetime</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/16-application-lifetime</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/16-application-lifetime</guid>
			<pubDate>Fri, 16 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Application &lt;code&gt;OnStarted&lt;/code&gt;, &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; event handlers can be registered using the &lt;code&gt;IHostApplicationLifetime&lt;/code&gt; interface (and implementation), to run logic when the application &lt;em&gt;starts&lt;/em&gt;, is &lt;em&gt;stopping&lt;/em&gt; and has &lt;em&gt;stopped&lt;/em&gt; respectively.&lt;/p&gt;
&lt;p&gt;Zero or many event handlers can dynamically be registered to handle the required logic at the correct application lifetime event.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="registering-handlers"&gt;Registering handlers&lt;/h2&gt;
&lt;?# InfoBlock ?&gt;
&lt;p&gt;The &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; events are &lt;strong&gt;NOT&lt;/strong&gt; called when debugging the application using Visual Studio. The application has to be run using &lt;code&gt;dotnet run&lt;/code&gt; from the command line to have these events successfully invoked whilst developing. More on this below under the &lt;em&gt;Graceful shutdown&lt;/em&gt; section.&lt;/p&gt;
&lt;?#/ InfoBlock ?&gt;
&lt;h3 id="api"&gt;Api&lt;/h3&gt;
&lt;p&gt;Registering callback handlers for the events is done by injecting &lt;code&gt;IHostApplicationLifetime&lt;/code&gt;, and calling the &lt;em&gt;Register&lt;/em&gt; method on the relevent &lt;em&gt;CancellationToken&lt;/em&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Define an endpoint, which when called will register a callback
// method for each of the events
app.MapGet(&amp;quot;/registerevents&amp;quot;, (
    IHostApplicationLifetime hostApplicationLifetime) =&amp;gt;
{
    // register each of the events
    hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
    hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
    hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
});

app.Run();

void OnStarted()
{
    Console.WriteLine(&amp;quot;Application OnStarted - api&amp;quot;);
}

void OnStopping()
{
    Console.WriteLine(&amp;quot;Application OnStopping - api&amp;quot;);
}

void OnStopped()
{
    Console.WriteLine(&amp;quot;Application OnStopped - api&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the application (using &lt;em&gt;dotnet run&lt;/em&gt;) and then closing the application (using &lt;code&gt;Ctrl-C&lt;/code&gt;) &lt;em&gt;without calling the endpoint&lt;/em&gt;, will result in &lt;em&gt;no callback events being called&lt;/em&gt; - as none have been registered.&lt;/p&gt;
&lt;p&gt;However executing the application, and invoking the &lt;code&gt;/registerevents&lt;/code&gt; endpoint, will result in the &lt;em&gt;OnStarted&lt;/em&gt; callback event being called immediately, and the other two &lt;em&gt;OnClosing&lt;/em&gt; and &lt;em&gt;OnClosed&lt;/em&gt; events called when the application is shutdown. The output of the application (other logging output removed):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Application OnStarted - api
Application OnStopping - api
Application OnStopped - api
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="worker"&gt;Worker&lt;/h3&gt;
&lt;p&gt;Callback events can also be registered with &lt;code&gt;background/worker&lt;/code&gt; services when they are instantiated. Updating the default .NET Worker template:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Worker : BackgroundService
{
    private readonly ILogger&amp;lt;Worker&amp;gt; _logger;

    private readonly IHostApplicationLifetime _hostApplicationLifetime;

    // inject IHostApplicationLifetime
    public Worker(ILogger&amp;lt;Worker&amp;gt; logger, IHostApplicationLifetime hostApplicationLifetime)
    {
        _logger = logger;
        _hostApplicationLifetime = hostApplicationLifetime;

        // register the callback methods
        _hostApplicationLifetime.ApplicationStarted.Register(OnStarted);
        _hostApplicationLifetime.ApplicationStopping.Register(OnStopping);
        _hostApplicationLifetime.ApplicationStopped.Register(OnStopped);
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation(&amp;quot;Worker running at: {time}&amp;quot;, DateTimeOffset.Now);
            await Task.Delay(1000, stoppingToken);
        }
    }

    private void OnStarted()
    {
        Console.WriteLine(&amp;quot;Application OnStarted - worker&amp;quot;);
    }

    private void OnStopping()
    {
        Console.WriteLine(&amp;quot;Application OnStopping - worker&amp;quot;);
    }

    private void OnStopped()
    {
        Console.WriteLine(&amp;quot;Application OnStopped - worker&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This background service can be registered in the same api application used in the previous minimal api example, using:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddHostedService&amp;lt;Worker&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now executing the application, invoking the endpoint and then closing the application will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Application OnStarted - worker
Application OnStarted - api
Application OnStopping - api
Application OnStopping - worker
Application OnStopped - api
Application OnStopped - worker
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="graceful-shutdown"&gt;Graceful shutdown&lt;/h2&gt;
&lt;p&gt;While the &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; events are useful for performing logic when the application is &lt;em&gt;stopping&lt;/em&gt; and &lt;em&gt;stopped&lt;/em&gt; - these events are only called in the case of a &lt;code&gt;graceful shutdown&lt;/code&gt;. For example, in the case when debugging using Visual Studio - when the debugging session is stopped, a graceful shutdown is &lt;strong&gt;not&lt;/strong&gt; performed, and as such the stopping/stopped events are not invoked. &lt;code&gt;Application functionality should not assume that the 'OnStopping' and 'OnStopped' events will always be called.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;The two closing events &lt;code&gt;OnStopping&lt;/code&gt; and &lt;code&gt;OnStopped&lt;/code&gt; are especially useful, and can be leveraged to perform application cleanup tasks on closing (while not depending on them always being executing). For example, clearing any lingering cache files, or persisting any in memory logs to disk can be executing when the application is stopping/stopped.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-6.0#ihostapplicationlifetime"&gt;IHostApplicationLifetime&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;162: 16-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Streaming responses from a minimal api </title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/15-min-api-yield</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/15-min-api-yield</guid>
			<pubDate>Thu, 15 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Using &lt;em&gt;&amp;quot;usual techniques&amp;quot;&lt;/em&gt;, it is not possible to stream a response from a minimal api, as the &lt;code&gt;yield keyword cannot be used inside an anonymous method or lambda expression&lt;/code&gt;. To work around this limitation, a &lt;code&gt;local function&lt;/code&gt; can be created which returns &lt;em&gt;IAsyncEnumerable&lt;/em&gt;, and the local function result in turn, is returned from the minimal api.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="limitation"&gt;Limitation&lt;/h2&gt;
&lt;p&gt;Suppose we need to define an endpoint, which when called will stream a &lt;em&gt;bool response&lt;/em&gt; indicating if current date time minute is 13 or not (not very practical or useful, but will work for demo purposes):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/isminute13&amp;quot;, async () =&amp;gt;
{
    // when the endpoint is called, loop until
    // the user cancels
    while (true)
    {
        // return a bool indicating if the current minute is 13
        yield return (DateTime.Now.Minute == 13);

        // wait 1 second, and repeat
        await Task.Delay(1000);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue here, is that it &lt;code&gt;does not compile&lt;/code&gt;, as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The yield statement cannot be used inside an anonymous method or lambda expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, there is a way around this constraint of the lambda expression!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="local-function"&gt;Local function&lt;/h2&gt;
&lt;p&gt;The error itself gives a clue on how to solve the problem - yield cannot be used inside a &lt;em&gt;anonymous method or lambda expression&lt;/em&gt;, so &lt;code&gt;why don't not instead create and use a non-anonymous method!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/isminute13&amp;quot;, () =&amp;gt;
{
    // move all previous logic into this local method
    async IAsyncEnumerable&amp;lt;bool&amp;gt; DateTimeStream()
    {
        while (true)
        {
            yield return (DateTime.Now.Minute == 13);
            await Task.Delay(1000);
        }
    }

    // return the result of the method
    return DateTimeStream();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above code, and calling the endpoint will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;[false,false,false,false,false,false,false,false,false,true,true,true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every second a new bool will be appended to the response, indicating if the minute is 13 or not.&lt;/p&gt;
&lt;p&gt;Simple, easy solution with minimal additional coding!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Streaming responses from an api is not something I've seen leveraged much before - however with the simplicity of configuring a minimal api for streaming, it is quick and easy to get an application up and running to determine if streaming can add value to the application or business.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidfowl/status/1436706303586410503"&gt;David Fowler Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;161: 15-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Auto-default struct property values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/14-struct-default</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/14-struct-default</guid>
			<pubDate>Wed, 14 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Coming with C# 11 (being released later this year, coinciding with the .NET 7 release) the compiler will now ensure that &lt;code&gt;fields on a struct will be initialized to their default value&lt;/code&gt; if not explicitly set.&lt;/p&gt;
&lt;p&gt;With the current, and prior C# versions, all fields on a struct need to explicitly be set when a struct instance is initialized using a defined constructor.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-10-and-prior"&gt;C# 10 and prior&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Song&lt;/em&gt; struct, which contains a number of properties related to a Song:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct Song
{
    public int Id { get; init; }

    public string Name { get; init; }

    // this property is required to have
    // a default value
    public string Artist { get; init; } = &amp;quot;Unavailable&amp;quot;;

    // this property is required to have
    // a default value
    public int SongLength { get; init; } = 0;

    // As this constructor doesn't set all properties
    // those unset properties need an explicit default value
    public Song(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public Song(int id, string name, string artist, int length)
    {
        Id = id;
        Name = name;
        Artist = artist;
        SongLength = length;
    }

    public override string ToString() =&amp;gt; $&amp;quot;{Id}: Song with name '{Name}' &amp;quot; +
        $&amp;quot;by '{Artist}' is {SongLength} seconds long&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, the &lt;em&gt;Artist&lt;/em&gt; and &lt;em&gt;SongLength&lt;/em&gt; properties need to &lt;code&gt;explicitly have a default value set&lt;/code&gt;, as there is a constructor which does not set them.&lt;/p&gt;
&lt;p&gt;If the default values are removed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public string Artist { get; init; } 

public int SongLength { get; init; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then a compiler error will occur:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Auto-implemented property 'Song.Artist' must be fully assigned before 
    control is returned to the caller. Consider updating to language 
    version '11.0' to auto-default the property.	
Auto-implemented property 'Song.SongLength' must be fully assigned 
    before control is returned to the caller. Consider updating to language 
    version '11.0' to auto-default the property.	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error even has a suggestion on how to resolve the issue (assuming you have C# 11 preview version installed).&lt;/p&gt;
&lt;p&gt;For completeness, here is an example of using the above struct:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(1, &amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 469);
Console.WriteLine(song);

var halfSong = new Song(1, &amp;quot;Everlong&amp;quot;);
Console.WriteLine(halfSong);

var defaultSong = default(Song);
Console.WriteLine(defaultSong);

var blankSong = new Song();
Console.WriteLine(blankSong);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1: Song with name 'Everlong' by 'Foo Fighters' is 469 seconds long
1: Song with name 'Everlong' by 'Unavailable' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output, one can see that when calling one of the &lt;code&gt;defined constructors&lt;/code&gt;, all the properties need to be &lt;code&gt;explicitly set&lt;/code&gt; - either in the constructor itself, or with a default value. However when using one of the &lt;code&gt;other techniques to instantiate&lt;/code&gt;, the property values &lt;code&gt;will be set to the type's default value&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="c-11"&gt;C# 11&lt;/h2&gt;
&lt;p&gt;When using C# 11 (currently this means having a preview version of .NET7 installer, and updating the csproj file to contain &lt;code&gt;&amp;lt;LangVersion&amp;gt;preview&amp;lt;/LangVersion&amp;gt;&lt;/code&gt;), the struct can be updated to be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct Song
{
    public int Id { get; init; }

    public string Name { get; init; }

    // now these properties don't require
    // a default value
    public string Artist { get; init; }

    public int SongLength { get; init; }

    public Song(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public Song(int id, string name, string artist, int length)
    {
        Id = id;
        Name = name;
        Artist = artist;
        SongLength = length;
    }

    public override string ToString() =&amp;gt; $&amp;quot;{Id}: Song with name '{Name}' &amp;quot; +
        $&amp;quot;by '{Artist}' is {SongLength} seconds long&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when instantiated, &lt;code&gt;not all properties of the struct need to be explicitly set&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Executing the same sample code as above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(1, &amp;quot;Everlong&amp;quot;, &amp;quot;Foo Fighters&amp;quot;, 469);
Console.WriteLine(song);

var halfSong = new Song(1, &amp;quot;Everlong&amp;quot;);
Console.WriteLine(halfSong);

var defaultSong = default(Song);
Console.WriteLine(defaultSong);

var blankSong = new Song();
Console.WriteLine(blankSong);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1: Song with name 'Everlong' by 'Foo Fighters' is 469 seconds long
1: Song with name 'Everlong' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
0: Song with name '' by '' is 0 seconds long
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling a defined constructor which doesn't set all properties, &lt;code&gt;the unset properties will be set to the type's default value&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A minor update to the language, but which will result in a more familiar, intuitive and expected experience for the experienced C# developer, which have worked with previous versions of the the runtime, and are familiar with the behavior of classes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dev.to/dotnetsafer/5-new-c-11-features-you-might-have-missed-32d8"&gt;Auto-default struct&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;160: 14-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Correlation using the Activity class</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/13-activity-correlation</guid>
			<pubDate>Tue, 13 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When working with &lt;code&gt;distributed systems&lt;/code&gt;, the built in &lt;code&gt;Activity&lt;/code&gt; class can be used to automatically correlate requests across the various systems.&lt;/p&gt;
&lt;p&gt;For each unique request to an api (for example) a new activity root id is generated. If however, the specific api makes a call into another api, the activity root id is persisted across the http call, allowing the two calls to be linked together and related together when querying or reporting on the data.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-endpoint"&gt;Single endpoint&lt;/h2&gt;
&lt;p&gt;First, we'll look at how to get access to the &lt;code&gt;activity id&lt;/code&gt;. To do this we generate a simple minimal endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, (IHttpClientFactory httpFactory) =&amp;gt;
{
    // Output the root Id, and the current Id
     Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the static &lt;code&gt;Activity&lt;/code&gt; class is used, to access the &lt;em&gt;Current&lt;/em&gt; activity, and output the &lt;em&gt;Root Id&lt;/em&gt; as well as the &lt;em&gt;Id&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Calling the endpoint a few times, results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id: 319d4ff500ce3100c2a3017531e023e4 | Id: 00-319d4ff500ce3100c2a3017531e023e4-e4c21e8cfae4db47-00
Root Id: 7de97ec9692106503aaabab105951bdf | Id: 00-7de97ec9692106503aaabab105951bdf-fa3c7b807eda8800-00
Root Id: e1868729b9f3db8c40942ffb1daf24c9 | Id: 00-e1868729b9f3db8c40942ffb1daf24c9-79de739f0d38d58c-00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time the endpoint is invoked, and new &lt;em&gt;Root Id and Id&lt;/em&gt; is generated, with the &lt;em&gt;Id&lt;/em&gt; containing the &lt;em&gt;Root Id&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-endpoints"&gt;Multiple endpoints&lt;/h2&gt;
&lt;p&gt;Next, we define a second endpoint - for this example the second endpoint is defined in the same project as the first endpoint, but the exact same behavior would be experienced if the endpoint was contained in a separate application.&lt;/p&gt;
&lt;p&gt;This second endpoint will return it's &lt;em&gt;Root Id and Id&lt;/em&gt; as a string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint2&amp;quot;, () =&amp;gt;
{
    return $&amp;quot;Second Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Second Id: {Activity.Current.Id}&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we update the first endpoint to call the second endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
        Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    // call the second endpoint
    var client = httpFactory.CreateClient();
    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);

    // output the response (which contains the Id's)
    // from the second endpoint
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    Console.WriteLine(&amp;quot;------&amp;quot;);

    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when the first endpoint is called, we see the following (formatted to make it easier to compare):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        8f1e949168197f1185135e963eab68bc | Unit Id:   00-8f1e949168197f1185135e963eab68bc-2adc30476d372b95-00
Second Root Id: 8f1e949168197f1185135e963eab68bc | Second Id: 00-8f1e949168197f1185135e963eab68bc-d18ddb27c96b1a1b-00
------
Root Id:        2b39afb72f3773289d8d141b2ef030d4 | Unit Id:   00-2b39afb72f3773289d8d141b2ef030d4-77be0c303ee8028a-00
Second Root Id: 2b39afb72f3773289d8d141b2ef030d4 | Second Id: 00-2b39afb72f3773289d8d141b2ef030d4-66e8aa928caf5619-00
------
Root Id:        46d2eedeacdfe46a89888598886a5186 | Unit Id:   00-46d2eedeacdfe46a89888598886a5186-f7e42f6b6d868069-00
Second Root Id: 46d2eedeacdfe46a89888598886a5186 | Second Id: 00-46d2eedeacdfe46a89888598886a5186-1af4f5b27e45f9f7-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the &lt;code&gt;root id is the same across the http call&lt;/code&gt;, even though it is being returned from a separate endpoint in another service. The &lt;em&gt;Unit Id&lt;/em&gt; portion of the &lt;em&gt;Id&lt;/em&gt; changes though, indicating a smaller unit of work is being performed as part of the larger &lt;em&gt;root&lt;/em&gt; piece of work.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="child-activity"&gt;Child activity&lt;/h2&gt;
&lt;p&gt;We've seen how the the &lt;em&gt;Root Id&lt;/em&gt; is shared across http calls - now we look at how to get the same functionality when performing smaller units of work not involving http calls.&lt;/p&gt;
&lt;p&gt;Once again we update first endpoint, this time to start a child activity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/endpoint1&amp;quot;, async (IHttpClientFactory httpFactory) =&amp;gt;
{
    Console.WriteLine($&amp;quot;Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Id: {Activity.Current.Id}&amp;quot;);

    var client = httpFactory.CreateClient();

    client.BaseAddress = new Uri(&amp;quot;http://localhost:5065&amp;quot;);
    var response = await client.GetAsync(&amp;quot;endpoint2&amp;quot;);
    Console.WriteLine(await response.Content.ReadAsStringAsync());
    
    // start with the child activity
    using var childActivity = new Activity(&amp;quot;MessagePublishing&amp;quot;);
    childActivity.Start();

    // a message is published to a message broker here, with the 
    // Id as metadata/correlationId
    Console.WriteLine($&amp;quot;Child Root Id: {Activity.Current.RootId} | &amp;quot; +
        $&amp;quot;Child Id: {Activity.Current.Id}&amp;quot;);

    childActivity.Stop();
    Console.WriteLine(&amp;quot;------&amp;quot;);

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here a child activity is manually started, and within the scope of the child activity - a message is published to a message broker (for example).&lt;/p&gt;
&lt;p&gt;Invoking the endpoint now results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Root Id:        00a695a71d140a4105750a0cb04d9408 | Id:        00-00a695a71d140a4105750a0cb04d9408-4aba3488957c9a75-00
Second Root Id: 00a695a71d140a4105750a0cb04d9408 | Second Id: 00-00a695a71d140a4105750a0cb04d9408-e29b9eb28fe6d34f-00
Child Root Id:  00a695a71d140a4105750a0cb04d9408 | Child Id:  00-00a695a71d140a4105750a0cb04d9408-2a6e2ad5d7916142-00
------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the above, we can see that manually declaring and &lt;em&gt;starting&lt;/em&gt; an activity will result in a &lt;em&gt;new Id&lt;/em&gt; to be generated, but using the same &lt;em&gt;Root Id&lt;/em&gt; as the parent.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="why-the-need"&gt;Why the need?&lt;/h2&gt;
&lt;p&gt;So why the need for a &lt;em&gt;Root Id&lt;/em&gt; and &lt;em&gt;correlation&lt;/em&gt; - all of this is to &lt;code&gt;gain better observability into how an application is performing&lt;/code&gt;. This data can be output and collected, either using industry standard tools and formatting (&lt;a href="https://opentelemetry.io/"&gt;for example OpenTelemetry&lt;/a&gt;), or by rolling our one's own reporting database - either way though, this provides insight into how each portion of a larger distributed transaction are linked together, and how each portion is performing.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Distributed systems can become very complex, and observability is key in managing the stability and performance of the various systems - the &lt;code&gt;Activity&lt;/code&gt; class provides an easy, simple way to manage the correlation between the various systems and processes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.activity?view=net-6.0"&gt;Activity Class&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;159: 13-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Constructors with default values</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/12-constructor-default-value</guid>
			<pubDate>Mon, 12 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Constructor and minimal api parameters&lt;/code&gt; can have &lt;code&gt;default values&lt;/code&gt;, allowing for dependency injection to work - while not actually working. Specifying a default value allows for the application to &lt;em&gt;run with a default implementation&lt;/em&gt; even if the services has not been registered with the dependency injection container.&lt;/p&gt;
&lt;p&gt;This is not something one would usually do as a standard practice, but in specific use cases it does have a place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;In the below examples, we have an interface, and a couple of implementations:&lt;/p&gt;
&lt;p&gt;The interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IDependencyInterface 
{
    string GetName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// a default implementation
public class DefaultImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(DefaultImplementation);
    }
}

// and another implementation
public class OtherImplementation : IDependencyInterface
{
    public string GetName()
    {
        return nameof(OtherImplementation);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="injection"&gt;Injection&lt;/h3&gt;
&lt;p&gt;Usually to make use of the functionality provided by the interface and the associated implementation, the service is registered with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Depending on the implementation the application requires:
builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
// OR
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then is injected into the relevent constructor, or minimal api delegate in the below sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// explicitly tell it to get the IDependencyInterface implementation
// from the DI service collection
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface injected) =&amp;gt;
{
    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="di-assumption"&gt;DI Assumption&lt;/h3&gt;
&lt;p&gt;In the above setup, the runtime assumes that the necessary registrations with the dependency injection container have take place. If neither of the following registrations are  done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddTransient&amp;lt;IDependencyInterface, DefaultImplementation&amp;gt;();
builder.Services.AddTransient&amp;lt;IDependencyInterface, OtherImplementation&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when trying to inject &lt;em&gt;IDependencyInterface&lt;/em&gt;, the following error will be experienced:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;InvalidOperationException: No service for type 'IDependencyInterface' has been registered.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We've told the runtime and dependency injection container to &lt;em&gt;inject the IDependencyInterface implementation, but have not made it aware of any implementations!&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-value"&gt;Default value&lt;/h3&gt;
&lt;p&gt;Generally if in control of the entire dependency injection container registration, one should ensure that the required registrations are performed, and the error is resolved.&lt;/p&gt;
&lt;p&gt;However, in some cases this might not be possible - for example if developing a library package, there is no direct control over what the developer configures with the dependency injection container.&lt;br /&gt;
As a developer of the library package, one could just allow the exception to occur, which directs the developer to configure the dependency injection container correctly. Another, arguably more developer friendly technique, is to &lt;code&gt;automatically set a default implementation if one is not explicitly set&lt;/code&gt;. This does require a few updates to the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// make the parameter nullable, the default value will be null.
// In the case of a constructor (vs this minimal api delegate)
// the value can explicitly be set to null if desired:
// IDependencyInterface? injected = null
app.MapGet(&amp;quot;/name&amp;quot;, ([FromServices]IDependencyInterface? injected) =&amp;gt;
{
    // if it is null, set it to the default implementation
    injected ??= new DefaultImplementation();

    return injected.GetName();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two changes are made to code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the parameter as &lt;code&gt;nullable&lt;/code&gt; using the &lt;code&gt;?&lt;/code&gt; operator&lt;/li&gt;
&lt;li&gt;Instantiate the parameter to the &lt;code&gt;default implementation&lt;/code&gt; if the value of the parameter is null&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now if &lt;code&gt;no implementation is registered&lt;/code&gt; for IDependencyInterface, the application will still function and use the &lt;code&gt;default implementation&lt;/code&gt; specified.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, this is not a practice which is generally recommended - however in the case of developing an external library (which requires a dependency), there is no guarantee the host application has injected the required dependencies. By making use of &lt;code&gt;default values&lt;/code&gt; the library will &lt;em&gt;still function with default configuration&lt;/em&gt;, but allows for &lt;code&gt;specific implementations to be overwritten&lt;/code&gt; by the developer if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/CFDevelop/status/1556055501661929472"&gt;Christian Findlay Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;158: 12-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Delay SQL execution with WAITFOR</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/09-sql-waitfor</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/09-sql-waitfor</guid>
			<pubDate>Fri, 09 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;SQL is a &lt;code&gt;WAITFOR&lt;/code&gt; command which an be used to delay the execution of a proceeding SQL statement. One of two options can be supplied to the &lt;code&gt;WAITFOR&lt;/code&gt; statement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TIME&lt;/code&gt;: waits until the  time of day specified before executing the next statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELAY&lt;/code&gt;: waits for the time span specified before executing the next statement&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-format"&gt;WAITFOR Format&lt;/h2&gt;
&lt;p&gt;The format and usage of &lt;code&gt;WAITFOR&lt;/code&gt; is straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;WAITFOR DELAY 'time_to_pass' | TIME 'time_to_execute'
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-delay"&gt;WAITFOR DELAY&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WAITFOR DELAY&lt;/code&gt; will wait the &lt;code&gt;specified time span&lt;/code&gt; before executing the next command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO

WAITFOR DELAY '00:00:05';
GO

PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-09-08 20:39:51.2166773
2022-09-08 20:39:56.2387040

Completion time: 2022-09-08T20:39:56.2397037+02:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A time span between &lt;code&gt;00:00:00.001&lt;/code&gt; and &lt;code&gt;23:59:59.998&lt;/code&gt; can be specified - anything longer will result in an error.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="waitfor-time"&gt;WAITFOR TIME&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WAITFOR TIME&lt;/code&gt; will wait until the &lt;code&gt;specified time of day&lt;/code&gt; before executing the next command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO

WAITFOR TIME '20:47:00';
GO

PRINT CONVERT(varchar, SYSDATETIME(), 121)
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above will result in the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-08-15 20:46:48.9212859
2022-08-15 20:47:00.0130443

Completion time: 2022-08-15T20:47:00.0140433+02:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we only had to wait &lt;em&gt;12 seconds&lt;/em&gt;, but the wait could be longer depending on the time specified. Only a &lt;code&gt;time can be specified, not a particular date&lt;/code&gt;. If the next execution of the specified time is the following day, the wait until the time is reached the following day.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scheduling"&gt;Scheduling&lt;/h2&gt;
&lt;p&gt;The below is an &lt;em&gt;example&lt;/em&gt; of how the functionality can be used to executing a command on a specific schedule. This technique is used for demo purposes not necessarily recommended for a production use case.&lt;/p&gt;
&lt;p&gt;The following will execute the command every second for a full minute, once a day:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- wait until a specific time
WAITFOR TIME '20:52:00';
GO

-- while it is the 53th minute
WHILE(DATEPART(MINUTE, GETDATE()) &amp;lt; 54)
BEGIN
        -- print out the date time
	BEGIN
		PRINT CONVERT(varchar, SYSDATETIME(), 121)
	END

        -- wait for 1 second
	BEGIN
		WAITFOR DELAY '00:00:01';
	END
END
GO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;2022-08-15 20:52:00.0145585
2022-08-15 20:52:01.0162047
2022-08-15 20:52:02.0209920
2022-08-15 20:52:03.0229534
.
.
.
2022-08-15 20:53:56.6402032
2022-08-15 20:53:57.6424606
2022-08-15 20:53:58.6450557
2022-08-15 20:53:59.6499793
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not necessarily a command which will see every day usage, it could prove useful to simulate a specific &amp;quot;real world&amp;quot; scenario when there is a time span between statements, either for testing or investigation purposes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mssqltips.com/sqlservertip/7344/delay-sql-code-execution-with-sql-waitfor/"&gt;SQL WAITFOR Command to Delay SQL Code Execution&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;157: 09-09-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Formatting interpolated strings</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/08-interpolation-formatting</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/08-interpolation-formatting</guid>
			<pubDate>Thu, 08 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using &lt;code&gt;string interpolation&lt;/code&gt;, the colon &lt;code&gt;:&lt;/code&gt; operator can be used, followed by the &lt;code&gt;format string&lt;/code&gt; to specify how the string should be formatted. This can be used instead of the &lt;code&gt;ToString&lt;/code&gt; method with a specified format.&lt;/p&gt;
&lt;p&gt;This post is about &lt;code&gt;interpolated strings&lt;/code&gt; however the technique will also work when using the &lt;code&gt;index component&lt;/code&gt; (using &lt;em&gt;String.Format&lt;/em&gt; with &lt;code&gt;{0}&lt;/code&gt; instead the string).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="format"&gt;Format&lt;/h2&gt;
&lt;p&gt;In a previous post, we learnt how to &lt;a href="https://alwaysdeveloping.net/08/03-string-interpolation-alignment"&gt;align the string when performing string interpolation&lt;/a&gt; - but when using this method (and other composite string techniques) there also an optional &lt;em&gt;formatString&lt;/em&gt; component.&lt;/p&gt;
&lt;p&gt;The full syntax for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string interpolation&lt;/code&gt; is: &lt;code&gt;{&amp;lt;interpolationExpression&amp;gt;[,&amp;lt;alignment&amp;gt;][:&amp;lt;formatString&amp;gt;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;composite formatting&lt;/code&gt; is: &lt;code&gt;{index[,alignment][:formatString]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post will focus on the &lt;em&gt;formatString&lt;/em&gt; portion - this provides a shortcut to using the &lt;code&gt;.ToString(format)&lt;/code&gt; method on the relevent entity.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;In the examples below, the &lt;em&gt;ToString&lt;/em&gt; method, and the &lt;em&gt;interpolated format string&lt;/em&gt; method are compared, with the same format string, and shown to produce the same output. It is also shown when no format string is specified, the `general ("G") format specifier is used (for numeric, datetime and enumeration).&lt;/p&gt;
&lt;h3 id="datetime"&gt;DateTime&lt;/h3&gt;
&lt;p&gt;Below we see how to format a &lt;code&gt;DateTime&lt;/code&gt; using the more traditional &lt;em&gt;ToString&lt;/em&gt; method, and then the &lt;em&gt;format string&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;DateTime current  = DateTime.Now;
Console.WriteLine($"Current Datetime:{current}");
Console.WriteLine($"Current Datetime:{current.ToString("MM/dd/yyyy hh:mm:ss.fff")}");
Console.WriteLine($"Current Datetime:{current:MM/dd/yyyy hh:mm:ss.fff}");

Console.WriteLine($"Current Datetime:{current.ToString("hh:mm")}");
Console.WriteLine($"Current Datetime:{current:hh:mm}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Current Datetime:2022/08/15 05:56:53
Current Datetime:09/07/2022 05:54:25.527
Current Datetime:09/07/2022 05:54:25.527
Current Datetime:05:54
Current Datetime:05:54
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Same output with the two methods, but when using the &lt;em&gt;interpolated format string&lt;/em&gt; method, the code is more concise and (arguably) cleaner.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="guid"&gt;Guid&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;Guid&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Guid newGuid = Guid.NewGuid();
Console.WriteLine($"Guid value: {newGuid}");
Console.WriteLine($"Guid value: {newGuid.ToString("B")}");
Console.WriteLine($"Guid value: {newGuid:B}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Guid value: bcaf5b5e-14be-4156-a480-a87614a900f4
Guid value: {bcaf5b5e-14be-4156-a480-a87614a900f4}
Guid value: {bcaf5b5e-14be-4156-a480-a87614a900f4}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="timespan"&gt;TimeSpan&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;TimeSpan&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;TimeSpan travelTime = new TimeSpan(1, 6, 24, 1);
Console.WriteLine($"Travel time: {travelTime}");
Console.WriteLine($"Travel time: {travelTime.ToString("g")}");
Console.WriteLine($"Travel time: {travelTime:g}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Travel time: 1.06:24:01
Travel time: 1:6:24:01
Travel time: 1:6:24:01
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="numeric"&gt;Numeric&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;numeric&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int cost = 5699;
Console.WriteLine($"Cost: {cost}");
Console.WriteLine($"Cost: {cost.ToString("c")}");
Console.WriteLine($"Cost: {cost:c}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cost: 5699
Cost: R5&amp;nbsp;699,00
Cost: R5&amp;nbsp;699,00
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="enum"&gt;Enum&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;Enum&lt;/code&gt; example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ConsoleColor drawColor = ConsoleColor.Green;
Console.WriteLine($"Draw color: {drawColor}");
Console.WriteLine($"Draw color: {drawColor.ToString("D")}");
Console.WriteLine($"Draw color: {drawColor:D}");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Draw color: Green
Draw color: 10
Draw color: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is &lt;code&gt;not a new or revolutionary feature&lt;/code&gt;. I tend to use the &lt;code&gt;ToString&lt;/code&gt; method when formatting strings, not really aware that there was an alternative. Using the &lt;code&gt;:formatString&lt;/code&gt; method is not going to drastically change the maintainability, readability or performance of the code - but it does require slightly less typing and removes one additional method call (&lt;em&gt;ToString&lt;/em&gt;) so personally I will be using this method more frequently going forward.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting#format-string-component"&gt;Composite formatting: Format string component&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;156: 08-09-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>.NET 7 API output caching</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/09/07-output-cache</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/09/07-output-cache</guid>
			<pubDate>Wed, 07 Sep 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Built in &lt;code&gt;output caching&lt;/code&gt; support is being introduced with .NET 7, providing &lt;code&gt;caching functionality for minimal api responses&lt;/code&gt;. The functionality is highly configurable allowing for fast, yet accurate responses from a minimal api.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="endpoints"&gt;Endpoints&lt;/h2&gt;
&lt;h3 id="default-endpoint"&gt;Default endpoint&lt;/h3&gt;
&lt;p&gt;In these examples, a simple minimal api endpoint will be used as a base, which &lt;em&gt;returns the current datetime when invoked&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/date", () =&amp;gt;
{
    return DateTime.Now;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="default-caching"&gt;Default caching&lt;/h3&gt;
&lt;p&gt;Let's start by adding default caching to the endpoint. There are basically 3 steps to be performed to configure output caching (these are the same three steps that apply to most  API functionality):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Configure the &lt;code&gt;dependency injection container&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddOutputCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure the api &lt;code&gt;middleware pipeline&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseOutputCache();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Define the endpoint, and &lt;code&gt;apply the output cache functionality to the endpoint&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datedefaultcache", () =&amp;gt;
{
    return DateTime.Now;
}).CacheOutput();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Invoking the &lt;code&gt;/date&lt;/code&gt; endpoint will always result in a new return value, however invoking &lt;code&gt;/datedefaultcache&lt;/code&gt; a cached value will be returned (apart from the first time it is invoked). By default, the response is cached for 60 seconds.&lt;/p&gt;
&lt;p&gt;Inspecting the response headers (by using a tool like Postman, for example), one can see the age of the cached response (in seconds) is included:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/response-age.png" alt="Response age - 17 seconds old"&gt;&lt;/p&gt;
&lt;p&gt;By default, once the cache is 60 seconds old, it expires and the next request to the endpoint will generate a new cache.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="caching-policy"&gt;Caching policy&lt;/h3&gt;
&lt;p&gt;It is also possible to define one or more &lt;code&gt;cache policy&lt;/code&gt; which allows for finer control of the behavior over the caching mechanism. A policy can either be defined as part of the &lt;code&gt;AddOutputCache&lt;/code&gt; call, and then applied to one or many endpoints (as is shown in the example immediately below), or defined when applying caching to a specific endpoint (as shown in an &lt;em&gt;VaryBy&lt;/em&gt; example further down).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define the &lt;code&gt;caching policy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddOutputCache(options =&amp;gt;
{
    options.AddPolicy("ignore-cache", p =&amp;gt; p
        .With(ctx =&amp;gt; !ctx.HttpContext.Request.Headers.ContainsKey("ignore-cache"))
    );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This policy looks for the presence of a header called &lt;em&gt;ignore-cache&lt;/em&gt; and only applies the cache policy if the header is &lt;strong&gt;not&lt;/strong&gt; present (irrespective of the header value)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Apply the policy&lt;/code&gt; to an endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// option to ignore
app.MapGet("/dateignorecache", () =&amp;gt;
{
    return DateTime.Now;
}).CacheOutput("ignore-cache");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking this endpoint will result in default caching behavior, &lt;em&gt;unless&lt;/em&gt; a header named &lt;code&gt;ignore-cache&lt;/code&gt; is included in the request, in which case caching will be ignored.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="caching-varyby"&gt;Caching VaryBy&lt;/h3&gt;
&lt;p&gt;Another feature which can be leveraged, is the ability to &lt;code&gt;cache by a specific value&lt;/code&gt;. The built in options available are to cache:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By query&lt;/li&gt;
&lt;li&gt;By header&lt;/li&gt;
&lt;li&gt;By value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the below example, the output is &lt;code&gt;cached by the query string value 'timezone'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimezone", (string? timezone) =&amp;gt;
{
    // insert some logic to get the correct datetime
    // based on the timezone
    return DateTime.Now;

}).CacheOutput(p =&amp;gt; p.VaryByQuery("timezone"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the endpoint is invoked with a specific timezone (&lt;em&gt;/datetimezone&lt;code&gt;?timezone=CAT&lt;/code&gt;&lt;/em&gt; for example), the output will be cached while the same timezone query string is provided. If another timezone is provided (&lt;em&gt;/datetimezone&lt;code&gt;?timezone=GMT&lt;/code&gt;&lt;/em&gt; for example), the same cache used for CAT is &lt;strong&gt;not applied&lt;/strong&gt; and a new cache will be generated specific for &lt;code&gt;GMT&lt;/code&gt;. The cache will &lt;code&gt;vary by a query string value&lt;/code&gt;. The same logic can be applied to a header value, or any other custom value.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="evicting-cache"&gt;Evicting cache&lt;/h3&gt;
&lt;p&gt;In some instances it might be required to &lt;code&gt;manually invalidate a cache&lt;/code&gt; if we know the content is no longer valid. The below example is very simple (for demo purposes), but the same mechanism can be extended for more elaborate use cases:&lt;/p&gt;
&lt;p&gt;The first step is to &lt;code&gt;tag the output cache&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimetag", () =&amp;gt;
{
    return DateTime.Now;

}).CacheOutput(t =&amp;gt; t.Tag("current"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here when the &lt;code&gt;/datetimetag&lt;/code&gt; endpoint is called, the output cache is tagged with the name &lt;em&gt;"current"&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The implementation of &lt;code&gt;IOutputCacheStore&lt;/code&gt; (configured with dependency injection using the &lt;em&gt;AddOutputCache&lt;/em&gt; method) can then be injected where and when required to &lt;code&gt;evict&lt;/code&gt; (invalidate) a cache using the tag.&lt;/p&gt;
&lt;p&gt;In this example, another endpoint is defined which will evict the cache for the &lt;code&gt;/datetimetag&lt;/code&gt; endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet("/datetimeclear", (IOutputCacheStore cache) =&amp;gt;
{
    // evict the cache tagged with "current"
    cache.EvictByTagAsync("current", default);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Another very useful and easy to configure feature coming with .NET 7 (along with &lt;a href="https://alwaysdeveloping.net/08/31-rate-limiting"&gt;rate limiting&lt;/a&gt;, for example) - making minimal api's even more powerful and bringing it closer to parity with the more traditional MVC (controllers) approach.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=0WvGwOoK-CI"&gt;Nick Chapsas - The NEW caching you should be using in .NET 7&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;155: 07-09-2022&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>