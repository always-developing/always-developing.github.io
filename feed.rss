<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2023</copyright>
		<pubDate>Tue, 03 Jan 2023 03:38:04 GMT</pubDate>
		<lastBuildDate>Tue, 03 Jan 2023 03:38:04 GMT</lastBuildDate>
		<item>
			<title>Converting values with EF</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/03-ef-value-converter</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/03-ef-value-converter</guid>
			<pubDate>Tue, 03 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;An EntityFramework &lt;code&gt;ValueConverter&lt;/code&gt; can be used to convert a property from one value or type to another when reading to and writing from the database.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;In the example, the C# class has a &lt;code&gt;DateTime&lt;/code&gt; property, however when saved in the database, this property will be stored as a &lt;code&gt;long&lt;/code&gt; (BIGINT in SQL) - a value representing the &lt;em&gt;DateTime as ticks&lt;/em&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="scaffolding"&gt;Scaffolding&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;Blog&lt;/em&gt; class looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table("Blog")]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the &lt;em&gt;DateCreated&lt;/em&gt; is of type &lt;code&gt;DateTime&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;DBContext&lt;/em&gt; implementation is configured as per usual:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            @"Server=.\SQLEXPRESS;Database=ValueConverter;Integrated Security=True;TrustServerCertificate=True");
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id="definition"&gt;Definition&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;code&gt;ValueConverter&lt;/code&gt; - this is done by inheriting from &lt;code&gt;ValueConverter&amp;lt;TModel, TProvider&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The converter defined below will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Provide functionality to convert from &lt;em&gt;DateTime&lt;/em&gt; to &lt;em&gt;long&lt;/em&gt; when writing to the database&lt;/li&gt;
&lt;li&gt;Provide functionality to convert from &lt;em&gt;long&lt;/em&gt; to &lt;em&gt;DateTime&lt;/em&gt; when reading from the database&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal class DateCreatedConverter : ValueConverter&amp;lt;DateTime, long&amp;gt;
{
    // constructor calls into the base constructor
    // with the two methods to do the conversion
    public DateCreatedConverter()
    : base(modelValue =&amp;gt; ToTicks(modelValue), 
        provValue =&amp;gt; ToDateTime(provValue)) { }

    // convert a long to DateTime - for when reading
    // from the database
    private static DateTime ToDateTime(long ticks)
    {
        return new DateTime(ticks);
    }

    // convert a DateTime to long - for when writing
    // do the database
    private static long ToTicks(DateTime datetime)
    {
        return datetime.Ticks;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The base &lt;code&gt;ValueConverter&amp;lt;DateTime, long&amp;gt;&lt;/code&gt; constructor takes two parameters - two &lt;em&gt;Expressions&lt;/em&gt; for doing the conversion between the values. Our class defines two methods defining the logic for how the conversion is to the happen, and then passes these methods to the &lt;em&gt;base constructor&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The same blueprint can be used to define more complex conversions between property values.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="registration"&gt;Registration&lt;/h3&gt;
&lt;p&gt;Now that we have the converter defined, the next step is to register it with the Entity Framework infrastructure. This is done either in an &lt;code&gt;IEntityTypeConfiguration&lt;/code&gt; implementation for the specific entity, or in this example, in the &lt;em&gt;OnModelCreating&lt;/em&gt; method of the DbContext:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            @"Server=.\SQLEXPRESS;Database=ValueConverter;Integrated Security=True;TrustServerCertificate=True");
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // define that the specific property 
        // on the specific entity has the converter
        modelBuilder.Entity&amp;lt;Blog&amp;gt;()
            .Property(b =&amp;gt; b.DateCreated)
            .HasConversion&amp;lt;DateCreatedConverter&amp;gt;();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the specific &lt;em&gt;property&lt;/em&gt; on the specific &lt;em&gt;entity&lt;/em&gt; is specified to have the converter.&lt;/p&gt;
&lt;p&gt;That's all there is to it! Entity Framework will now &lt;code&gt;automatically apply the conversion when reading to and writing from the database&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;When interacting with the database using Entity Framework, the &lt;code&gt;ValueConverter&lt;/code&gt; is automatically used. This includes when creating the table based on the entity schema:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Blog blog = new Blog
{
    Id = 1,
    Title = "My first post",
    Description = "My very first blog ever!",
    DateCreated = DateTime.Now,
};

DemoContext context = new DemoContext();
context.Database.EnsureCreated();
await context.Blogs.AddAsync(blog);
await context.SaveChangesAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we look at the data in the database, the &lt;em&gt;DateCreated&lt;/em&gt; property is stored as a BIGINT (the SQL equivalent of a long):&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alwaysdeveloping.net/database.png" alt="Conversion in the database"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful feature when needing to convert data/value types between code and the database - some relatively simple configuration, and Entity Framework takes care of the rest.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://shadynagy.com/value-converters-efcore/"&gt;Value converters in Entity Framework Code (EF Core)&lt;/a&gt;&lt;/p&gt;
&lt;!--?# DailyDrop ?--&gt;226: 03-01-2023&lt;!--?#/ DailyDrop ?--&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>.NET 8 Exception helpers</title>
			<link>https://alwaysdeveloping.net/dailydrop/2023/01/02-exception-helpers</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2023/01/02-exception-helpers</guid>
			<pubDate>Mon, 02 Jan 2023 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;A number of &lt;em&gt;helper&lt;/em&gt; methods are being introduced with .NET 8, which make the process of &lt;code&gt;checking values and throwing exception&lt;/code&gt; a lot simpler.&lt;/p&gt;
&lt;p&gt;Keep in mind .NET 8 is in pre-release, so the functionality could potentially change or be removed before the final .NET8 release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="existing-helper"&gt;Existing helper&lt;/h2&gt;
&lt;p&gt;An example of an existing (prior to .NET 8) exception helper method, is the &lt;code&gt;ArgumentException.ThrowIfNullOrEmpty&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;Instead of having to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ManualThrowException(string strParam)
{
    if (string.IsNullOrEmpty(strParam))
    {
        throw new Exception($&amp;quot;{nameof(strParam)} is null or empty&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ThrowIfNullOrEmpty&lt;/code&gt; method can be used, which checks the value of the parameter and throws the exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ThrowNullOrEmptyException(string strParam)
{
    ArgumentException.ThrowIfNullOrEmpty(strParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="new-helpers"&gt;New helpers&lt;/h2&gt;
&lt;p&gt;There are a number of new static helper methods (on &lt;em&gt;ArgumentOutOfRangeException&lt;/em&gt;) being introduced, which include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ThrowIfZero&lt;/li&gt;
&lt;li&gt;ThrowIfNegative&lt;/li&gt;
&lt;li&gt;ThrowIfNegativeOrZero&lt;/li&gt;
&lt;li&gt;ThrowIfGreaterThan&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The usage and functionality of these are the same as &lt;code&gt;ThrowIfNullOrEmpty&lt;/code&gt; - the parameter is checked, and an exception is throw if the check fails.&lt;/p&gt;
&lt;p&gt;To check if a int value is &lt;em&gt;zero or negative&lt;/em&gt;, instead of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void ManualThrowZeroNegativeException(int intParam)
{
    if (intParam &amp;lt;= 0)
    {
        throw new Exception($&amp;quot;{nameof(intParam)} is less than or equal to zero&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void EnhancedThrowZeroNegativeException(int intParam)
{
    ArgumentOutOfRangeException.ThrowIfNegative(intParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If thrown, the exception generated is also more informative than before, including the parameter name in the exception text:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;'intParam' must be a non-negative value.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result - more readable code, and quicker and easier for a developer to thrown an exception.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small and simple helper method update - but one will facilitate cleaner, simpler and more readable code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/f4bc6fcc-5691-4f72-b9bb-75aeeb59230a"&gt;New ArgumentException and ArgumentOutOfRangeException helpers in .NET 8&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;225: 02-01-2023&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Entity Framework conventions</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/16-ef-conventions</guid>
			<pubDate>Fri, 16 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Entity Framework comes out of the box with a number of default &lt;em&gt;conventions&lt;/em&gt; - however &lt;code&gt;new conventions can easily be added&lt;/code&gt; to an application specific EF configuration to customize how Entity Framework operates.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;By default, when a &lt;code&gt;string&lt;/code&gt; property on an entity is mapped to a SQL database column, it will be generated as &lt;code&gt;nvarchar(max)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the DbContext configuration, some additional logging for demo purposes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DemoContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=ConfigConventions;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

        // enable additional logging for demo purposes
        optionsBuilder.EnableSensitiveDataLogging(true);
        optionsBuilder.LogTo((string query) =&amp;gt;
        {
            Console.WriteLine(query);
        }, LogLevel.Information);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;CREATE TABLE SQL&lt;/em&gt; generated is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(max) NOT NULL,
    [Description] nvarchar(max) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As one can see, the default for C# properties of type &lt;code&gt;string&lt;/code&gt; is &lt;code&gt;nvarchar(max)&lt;/code&gt; - next we'll go through the various steps to change the convention for &lt;em&gt;non-explicitly set string&lt;/em&gt; properties from &lt;code&gt;nvarchar(max)&lt;/code&gt; to &lt;code&gt;nvarchar(256)&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-definition"&gt;Convention definition&lt;/h3&gt;
&lt;p&gt;The first step is to define the &lt;em&gt;convention&lt;/em&gt; to change the default string length. This is achieved by implementing the &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; interface (which inherits the &lt;code&gt;IConvention&lt;/code&gt; interface). The &lt;code&gt;IModelFinalizingConvention&lt;/code&gt; implementations, as the name suggests, are executed once the model has mostly been built (using the built-in and other custom conventions), and is being &lt;em&gt;finalized&lt;/em&gt;. This is the &amp;quot;safest&amp;quot; time to execute custom conventions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MaxStringLengthConvention : IModelFinalizingConvention
{
    private readonly int _maxLength;

    public MaxStringLengthConvention(int maxLength)
	{
        this._maxLength = maxLength;
    }

    // implement the only method on the interface
    public void ProcessModelFinalizing(IConventionModelBuilder modelBuilder, 
        IConventionContext&amp;lt;IConventionModelBuilder&amp;gt; context)
    {
        // iterate through each type defined in the EF model
        // and through each property and check if a string
        foreach (var property in modelBuilder.Metadata.GetEntityTypes()
                     .SelectMany(entityType =&amp;gt; entityType.GetDeclaredProperties()
                                    .Where( property =&amp;gt; property.ClrType == typeof(string))))
        {
            // set the max length based on the value passed in
            property.Builder.HasMaxLength(_maxLength);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The implementation for this convention effectively checks &lt;em&gt;each type&lt;/em&gt; and &lt;em&gt;each property&lt;/em&gt; on the type to see if it is of type &lt;em&gt;string&lt;/em&gt; - if so, the max length is set based on the max length specified on initialization.&lt;/p&gt;
&lt;p&gt;Now to register the newly created convention!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="convention-configuration"&gt;Convention configuration&lt;/h3&gt;
&lt;p&gt;The convention is required to be registered with Entity Framework - so EF knows to apply the convention to the model (adn when to apply it)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ConfigureConventions&lt;/code&gt; method is &lt;em&gt;overridden&lt;/em&gt; on the &lt;em&gt;DbContext&lt;/em&gt;, and the convention(s) registered:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    configurationBuilder.Conventions.Add(_ =&amp;gt; new MaxStringLengthConvention(256));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;With the convention configured, the SQL generated now looks as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(256) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All string properties/columns are set to have a length of 256 by default.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="explicitly-set-properties"&gt;Explicitly set properties&lt;/h3&gt;
&lt;p&gt;Entity Framework is smart enough to know that if the &lt;em&gt;max length&lt;/em&gt; has explicitly been set on a property/column, then the default length set by the convention will &lt;code&gt;not be applied&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the &lt;em&gt;Title&lt;/em&gt; property on the &lt;em&gt;Blog&lt;/em&gt; was set to have a max length of 500:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    [MaxLength(500)]
    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated is now as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE [Blog] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(500) NOT NULL,
    [Description] nvarchar(256) NOT NULL,
    [DateCreated] datetime2 NOT NULL,
    CONSTRAINT [PK_Blog] PRIMARY KEY ([Id])
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An explicitly defined max length on a property, takes precedence over the max length specified by the convention.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While all of the above could have been achieved by overwriting the &lt;code&gt;OnModelCreating&lt;/code&gt; method on the &lt;em&gt;DbContext&lt;/em&gt;, the conventions approach is more flexible and reusable. The conventions can be packaged and shared across teams in an enterprise to ensure consistent database standards.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=6apfe1L1FhY&amp;amp;t=2041s"&gt;.NET Data Community Standup - EF7 Custom Model Conventions&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;224: 16-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Holiday Break 2022</title>
			<link>https://alwaysdeveloping.net/p/2022-12-holiday</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/p/2022-12-holiday</guid>
			<pubDate>Fri, 16 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="until-next-year"&gt;Until next year&lt;/h2&gt;
&lt;p&gt;Today will be the final Daily Drop post for 2022 - alwaysdeveloping.net is taking a break until the begining of January. The learning and growing will continue, just not the posts. Until next year!&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>.NET8 Frozen collection</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/15-frozen-collection</guid>
			<pubDate>Thu, 15 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;.NET8 &lt;em&gt;potentially&lt;/em&gt; introduces a new collection type called a &lt;code&gt;Frozen collection&lt;/code&gt; - this post will explore the new collection, and see how to compares to existing collection implementations.&lt;/p&gt;
&lt;p&gt;As .NET8 is still currently in alpha, the &lt;code&gt;Frozen collection&lt;/code&gt; as well as any specific functionality it may offer could change before the final release.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;To see how the &lt;code&gt;Frozen collection&lt;/code&gt; operates, below it is used along with other common collection implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create a base list of 10 items
List&amp;lt;int&amp;gt; baseList = Enumerable
    .Range(1, 10).ToList();

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

// now add another item to the list
baseList.Add(11);

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 11
ReadOnlyList count: 11
FrozenSet count: 10
ImmutableList count: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see, that when &lt;em&gt;adding an item to the underlying list&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;ReadOnlyList&lt;/code&gt; count also increases, as it is a readonly view into the underlying list&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt; count is &lt;em&gt;not increased&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what's the difference between the &lt;code&gt;FrozenSet&lt;/code&gt; and &lt;code&gt;ImmutableList&lt;/code&gt;?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="set-vs-list"&gt;Set vs List&lt;/h2&gt;
&lt;p&gt;As per their name, the &lt;code&gt;FrozenSet&lt;/code&gt; is a &lt;em&gt;set&lt;/em&gt;, while the &lt;code&gt;ImmutableList&lt;/code&gt; is a &lt;em&gt;list&lt;/em&gt; - &lt;code&gt;a set cannot contain duplicates and is unordered&lt;/code&gt;, unlike a list. Consider the following code, similar to the previous example, but now with duplicate items:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
List&amp;lt;int&amp;gt; baseList = Enumerable.Range(1, 10)
    .ToList();
// add duplicate items to the base list
baseList.Add(1);
baseList.Add(2);
baseList.Add(3);

ReadOnlyCollection&amp;lt;int&amp;gt; readonlyList = 
    baseList.AsReadOnly();
FrozenSet&amp;lt;int&amp;gt; frozenSet = baseList.ToFrozenSet();
ImmutableList&amp;lt;int&amp;gt; immutableList = 
    baseList.ToImmutableList();

Console.WriteLine($&amp;quot;List count: {baseList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ReadOnlyList count: {readonlyList.Count}&amp;quot;);
Console.WriteLine($&amp;quot;FrozenSet count: {frozenSet.Count}&amp;quot;);
Console.WriteLine($&amp;quot;ImmutableList count: {immutableList.Count}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 13
ReadOnlyList count: 13
FrozenSet count: 10
ImmutableList count: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 3 duplicate items are automatically removed when converting the base list to a set.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="another-collection-type"&gt;Another collection type&lt;/h2&gt;
&lt;p&gt;So why the need for another specialized collection type - &lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Steven Giesel&lt;/a&gt; benchmark's the performance of the &lt;code&gt;FrozenSet&lt;/code&gt; against other collection types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is substantially &lt;em&gt;quicker&lt;/em&gt; vs the other types when &lt;em&gt;performing a lookup&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;it is however &lt;em&gt;slower&lt;/em&gt; when creating the set vs creating the other types&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A new specialized collection type, which might not see every day use by the majority, but which, with the right use case, can improve the performance of the code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/34e0fd95-0b3f-40f2-ba2a-36d1d4eb5601"&gt;Frozen collections in .NET 8&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;223: 15-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>New HTTP methods</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/14-http-query</guid>
			<pubDate>Wed, 14 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Standards have been published for a new HTTP method, &lt;code&gt;QUERY&lt;/code&gt;, which aims to effectively be a merge between the GET and POST methods.&lt;/p&gt;
&lt;p&gt;While this post will focus on handling the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, the same configuration and logic could be applied to any custom HTTP method (although not advised)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="the-need-for-query"&gt;The need for QUERY&lt;/h2&gt;
&lt;p&gt;First, a quick word on the need for the QUERY method. When using the GET method, all information to be passed to the server is contained in the URL as a &lt;em&gt;GET method does not have a body&lt;/em&gt;. The problem is that URL's have a finite length and when this limit is reached, often developers will switch to using a POST method which allows for more complex and lengthy information to be &lt;em&gt;passed in the body&lt;/em&gt;.
While this technique will work, the two different methods will generally have different caching mechanisms and a POST method may not offer the same performance as a GET method.&lt;/p&gt;
&lt;p&gt;The QUERY method aims to address this, by effectively providing a method which operates like the &amp;quot;GET&amp;quot; method, but which allows for a body to be posted to the server.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="defining-the-endpoint"&gt;Defining the endpoint&lt;/h2&gt;
&lt;p&gt;Defining an endpoint which uses a custom or new HTTP method is surprisingly easy - the &lt;code&gt;MapMethods&lt;/code&gt; method can be used, with a list of &lt;em&gt;httpMethods&lt;/em&gt; the endpoint supports:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// define an endpoint with QUERY http method
app.MapMethods(&amp;quot;/query&amp;quot;, new[] { &amp;quot;QUERY&amp;quot; }, async (HttpContext context) =&amp;gt;
{
    string? text = null;
    var request = context.Request;

    // the body has to be read manually
    if (!request.Body.CanSeek)
    {
        request.EnableBuffering();
    }

    if (request.Body.CanRead)
    {
        // read the body as a stream, and then set the
        // reader position back to the start
        request.Body.Position = 0;
        var reader = new StreamReader(request.Body, Encoding.UTF8);
        text = await reader.ReadToEndAsync();
        request.Body.Position = 0;
    }

    // return the body
    return Results.Ok($&amp;quot;Querying data using body: {text}&amp;quot;);

})
// give the endpoint a name, just making it easier to 
// find later. Not required
.WithName(&amp;quot;query&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here an endpoint &lt;code&gt;/query&lt;/code&gt; is defined, which uses the HTTP method &lt;code&gt;QUERY&lt;/code&gt;. The endpoint will read the contents of the body supplied with the HTTP request, and return it back to the caller.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;WithName&lt;/em&gt; method is used to name the endpoint, which will be used in the next step to easily build up the URL to be invoked - this is not strictly required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="calling-the-endpoint"&gt;Calling the endpoint&lt;/h2&gt;
&lt;p&gt;Calling the endpoint is a &lt;em&gt;little&lt;/em&gt; tricker, as the typical tools one might use (e.g. Postman) will not support the new or custom HTTP method. In this example, the C# HttpClient will be used to call the &lt;code&gt;QUERY&lt;/code&gt; endpoint - we are going to &lt;em&gt;create a GET endpoint, which will call the QUERY endpoint&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/callquery&amp;quot;, async (HttpContext context, 
    LinkGenerator generator) =&amp;gt;
{
    var client = new HttpClient();

    // set the http method as QUERY
    var request = new HttpRequestMessage(
        new HttpMethod(&amp;quot;QUERY&amp;quot;),
        // get the URL by the name specified
        generator.GetUriByName(context, &amp;quot;query&amp;quot;, null)
    );

    // set the body of the QUERY call
    request.Content = new StringContent(&amp;quot;This is a body of a QUERY call&amp;quot;, 
        Encoding.UTF8, &amp;quot;text/plain&amp;quot;);

    // call the QUERY endpoint
    var response = client.Send(request);
    var result = await response.Content.ReadAsStringAsync();

    // the expected result should be the same 
    // as the body specified
    return result;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Invoking the &lt;code&gt;/callquery&lt;/code&gt; endpoint yields the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;&amp;quot;Querying data using body: This is a body of a QUERY call&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Success! We have successfully defined an endpoint which uses the &lt;code&gt;QUERY&lt;/code&gt; HTTP method, which was successfully invoked with a body supplied.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="simplifying-the-code"&gt;Simplifying the code&lt;/h2&gt;
&lt;p&gt;The above is a very rough implementation of the &lt;code&gt;QUERY&lt;/code&gt; (or any custom HTTP method) implementation - in &lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Khalid Abuhakmeh's post&lt;/a&gt;, he has some good ways to simplify the code, and make it more generic. I suggest having a look at the techniques mentioned in his post on how to streamline the code for reuse.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful &lt;em&gt;experiment&lt;/em&gt; to see how support for any HTTP method support can be added relatively easily. There are limitation of custom HTTP methods - including the above mention support from 3rd party applications (Postman) as well as libraries (Swashbuckle), as well as limited or no support from caching or load balancing mechanisms.&lt;/p&gt;
&lt;p&gt;With reference to the &lt;code&gt;QUERY&lt;/code&gt; HTTP method - personally I like this, and will make sue of this, so I hope it does get adopted in the mainstream in future.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/adding-experimental-http-methods-to-aspnet-core"&gt;Adding Experimental HTTP Methods To ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;222: 14-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>EF tags and interceptors</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/13-ef-tags</guid>
			<pubDate>Tue, 13 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tags&lt;/code&gt;, in conjunction with an &lt;code&gt;IInterceptor&lt;/code&gt; implementation, can be used to intercept SQL commands before being executed on the database, and modify them to fix the tag requirements.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;In the examples below, we are using DbContext setup the standard way, with a &lt;code&gt;Blog&lt;/code&gt; DbSet.&lt;/p&gt;
&lt;p&gt;As per normal, to get a list of all &lt;em&gt;Blogs&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var normalQuery = context.Blogs.ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll look at how to &lt;em&gt;tag&lt;/em&gt; the queries with a &lt;code&gt;nolock&lt;/code&gt; tag, and then how to &lt;em&gt;intercept&lt;/em&gt; the query, look presence of the &lt;em&gt;tag&lt;/em&gt;, and modify the query to include &lt;code&gt;nolock&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tagging-queries"&gt;Tagging queries&lt;/h3&gt;
&lt;p&gt;The first step is to &lt;em&gt;tag&lt;/em&gt; the query with the &lt;code&gt;nolock&lt;/code&gt; tag - this is relatively straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var nolockQuery = context
    .Blogs
    .TagWith(&amp;quot;Nolock&amp;quot;)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the generated SQL is inspected, one will see the query is now tagged as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 1 completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="interceptor"&gt;Interceptor&lt;/h3&gt;
&lt;p&gt;The next step is to &lt;em&gt;intercept&lt;/em&gt; the query before it's executed on the database and modify it - luckily this is also fairly straightforward, as Entity Framework has a built in mechanism for this.&lt;/p&gt;
&lt;p&gt;To create an &lt;em&gt;interceptor&lt;/em&gt; (in this example) all that is required is to inherit from &lt;code&gt;DbCommandInterceptor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inherit DbCommandInterceptor
public class NoLockInterceptor : DbCommandInterceptor
{
    // overwrite the ReaderExecuting method
    public override InterceptionResult&amp;lt;DbDataReader&amp;gt; ReaderExecuting(DbCommand command, 
        CommandEventData eventData, 
        InterceptionResult&amp;lt;DbDataReader&amp;gt; result)
    {
        // if the query generated by EF starts with &amp;quot;nolock&amp;quot;
        if(command.CommandText.StartsWith(&amp;quot;-- Nolock&amp;quot;, StringComparison.Ordinal))
        {
            // append &amp;quot;nolock&amp;quot; to the end
            command.CommandText += &amp;quot; (NOLOCK)&amp;quot;;
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ReaderExecuting&lt;/code&gt; method is executed before the query is about to be executed - in this method, the query is (crudely) checked to see if it has been &lt;em&gt;tagged&lt;/em&gt; for &lt;code&gt;nolock&lt;/code&gt;, and if so, the &lt;code&gt;NOLOCK&lt;/code&gt; keyword is added to the end of the query.&lt;/p&gt;
&lt;p&gt;This is very crude and only for demo purposes - it is not production ready. Ror example, this does not take into account any &lt;em&gt;WHERE&lt;/em&gt; statements in the SQL.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dbcontext"&gt;DbContext&lt;/h3&gt;
&lt;p&gt;Now that we have the &lt;em&gt;interceptor&lt;/em&gt; defined, the next step is to register it with EF.&lt;/p&gt;
&lt;p&gt;In this demo, this is done in the &lt;em&gt;OnConfiguring&lt;/em&gt; method of the &lt;code&gt;DbContext&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(
        &amp;#64;&amp;quot;Server=.\SQLEXPRESS;Database=EFTagging;Integrated Security=True;TrustServerCertificate=True&amp;quot;);

    // add the interceptor
    optionsBuilder.AddInterceptors(new NoLockInterceptor());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuration is now completed!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="generated-sql"&gt;Generated SQL&lt;/h3&gt;
&lt;p&gt;When querying (without an predicate in this sample) and tagging the query, the &lt;code&gt;nolock&lt;/code&gt; keyword is automatically added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// query without tagging
var normalQuery = context.Blogs.ToList();

//query with the tag
var nolockQuery = context.Blogs.TagWith(&amp;quot;Nolock&amp;quot;).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL generated by the two queries.&lt;/p&gt;
&lt;p&gt;Without the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the tag:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;-- Nolock

SELECT [b].[Id], [b].[DateCreated], [b].[Description], [b].[Title]
FROM [Blog] AS [b] (NOLOCK)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A useful and interesting way to combine two EF features - the &lt;em&gt;tagging&lt;/em&gt; and &lt;em&gt;interception&lt;/em&gt; features. Manually modifying SQL generated by EF can be dangerous as there are a lot of options and variations to the SQL generated - so do it with caution and test extensively.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/DaveCallanIE/status/1599379983817879552"&gt;Dave Callan Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;221: 13-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Enum iteration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/12-enum-iteration</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/12-enum-iteration</guid>
			<pubDate>Mon, 12 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;code&gt;Enum.GetValues&lt;/code&gt; method value be used to get an array of the enum values, which can be output as a &lt;em&gt;string&lt;/em&gt; or corresponding compatible &lt;em&gt;underlying value&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="enum.getvalues"&gt;Enum.GetValues&lt;/h2&gt;
&lt;p&gt;The function and usage of &lt;code&gt;Enum.GetValues&lt;/code&gt; is very simple - it &lt;em&gt;converts an enum into an array of the enum values&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following enum:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum OrderStatus
{
    New = 0,
    Processing = 1,
    Fulfilled = 2,
    OutOnDelivery = 3,
    Delivered = 4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be converted to an array as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;OrderStatus[] enumItems = Enum.GetValues&amp;lt;OrderStatus&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This array can now be iterated over, and output either as a &lt;em&gt;string&lt;/em&gt; or &lt;em&gt;compatible underlying type&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;foreach (var item in Enum.GetValues&amp;lt;OrderStatus&amp;gt;())
{
    // output the string value
    Console.WriteLine(item);

    // output the underlying value
    Console.WriteLine((int)item);
    // this would also work
    //Console.WriteLine((double)item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;New
0
Processing
1
Fulfilled
2
OutOnDelivery
3
Delivered
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simple, easy and very useful.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small but useful piece of knowledge for today.  This can be leveraged to automatically populate a UI dropdown with available options, for example, instead of having multiple places with a list of possible values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/enumerate-enum-csharp/"&gt;How to Enumerate an Enum in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;220: 12-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Fast, potentially unsafe iteration</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/09-unsafe-add</guid>
			<pubDate>Fri, 09 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CollectionsMarshal&lt;/code&gt;, &lt;code&gt;MemoryMarshal&lt;/code&gt; and &lt;code&gt;Unsafe&lt;/code&gt; can be used in conjunction to create a &lt;em&gt;very fast&lt;/em&gt; &lt;code&gt;method of iteration&lt;/code&gt; (possibly the fastest method of performing for loops in C#)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="iteration"&gt;Iteration&lt;/h2&gt;
&lt;p&gt;The technique may look a bit complex and complicated at first glance (or at least more complex than a normal &lt;code&gt;for&lt;/code&gt; loop) - but going through it step-by-step it is actually relatively simple. This technique is also not as &lt;code&gt;safe&lt;/code&gt; as the traditional method, due to the way memory is being handled in a potentially &lt;code&gt;unsafe&lt;/code&gt; way.&lt;/p&gt;
&lt;p&gt;The full code snippet is at the bottom of the section, but for now we'll have a look at it step-by-step.&lt;/p&gt;
&lt;p&gt;Assume we have a list of 50 items we want to iterate through:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="list-to-span"&gt;List to Span&lt;/h3&gt;
&lt;p&gt;The first step is to convert the &lt;code&gt;List&lt;/code&gt; to a &lt;code&gt;Span&lt;/code&gt;, using the &lt;em&gt;System.Runtime.InteropServices.CollectionsMarshal.AsSpan&lt;/em&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the &lt;code&gt;Span&lt;/code&gt; is in use, (as per the documentation) &lt;em&gt;items should not be added or removed from List&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="span-reference"&gt;Span reference&lt;/h3&gt;
&lt;p&gt;The next step is to get a reference to the &lt;em&gt;element of the span at index 0&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref int searchLocation = ref MemoryMarshal.GetReference(itemsAsSpan);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;em&gt;searchLocation&lt;/em&gt; is effectively now pointing to the first item in the &lt;em&gt;Span&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="iterate"&gt;Iterate&lt;/h3&gt;
&lt;p&gt;Next, we can perform the actual iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// for loop as per usual
for (int i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    // Instead of using itemsAsSpan[i], which is still fast
    // we start with the first item (searchLocation)
    // and offset it by i items
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop is defined as per normal, but instead of accessing the &lt;code&gt;Span&lt;/code&gt; item at position &lt;em&gt;i&lt;/em&gt; as one usually would (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), the &lt;code&gt;Unsafe.Add&lt;/code&gt; method is used.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unsafe.Add&lt;/code&gt; &lt;em&gt;adds an element offset to the given reference&lt;/em&gt; - in this case it will use &lt;em&gt;searchLocation&lt;/em&gt;, the first item in the Span as the given reference, and offset by &lt;em&gt;i items&lt;/em&gt; each time.
Each iteration, the offset is larger (as i increases) and as the given reference, &lt;em&gt;searchLocation&lt;/em&gt;, stays the same the item being referenced each loop is different.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="code-snippet"&gt;Code snippet&lt;/h3&gt;
&lt;p&gt;The full code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;List&amp;lt;int&amp;gt; loopItems = Enumerable.Range(1, 50).ToList();
Span&amp;lt;int&amp;gt; itemsAsSpan = CollectionsMarshal.AsSpan(loopItems);

for (var i = 0; i &amp;lt; itemsAsSpan.Length; i++)
{
    var item = Unsafe.Add(ref searchLocation, i);
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;A full breakdown of the performance can be seen on Nick Chapsas's video, &lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8&amp;amp;t=490s"&gt;right here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But in short, using &lt;code&gt;the above method is the fastest way to iterate&lt;/code&gt;, slightly beating out using the index on the span (&lt;em&gt;itemsAsSpan[i]&lt;/em&gt;), but significantly faster than all other methods (for loop, foreach loop etc)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This should probably not be the go-to iteration method for all applications in all use cases - however, when performance is critical and every fraction of a second is important, then this kind of optimization could make a difference.
As mentioned, this technique is less &amp;quot;safe&amp;quot; than the usual &lt;em&gt;for&lt;/em&gt; or &lt;em&gt;foreach&lt;/em&gt; methods, so should be used with caution.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=cwBrWn4m9y8"&gt;The weirdest way to loop in C# is also the fastest&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;219: 09-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>EF7 GroupBy support</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/12/08-ef-group-by</guid>
			<pubDate>Thu, 08 Dec 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Prior to Entity Framework 7, having a LINQ &lt;code&gt;GroupBy&lt;/code&gt; as the final operator in a query would result in an exception being thrown - EF7 adds support for this scenario, allowing &lt;code&gt;GroupBy&lt;/code&gt; to be the final operator.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="scenario"&gt;Scenario&lt;/h2&gt;
&lt;p&gt;In this scenario, we have a simple &lt;em&gt;Blog&lt;/em&gt; class, setup as a &lt;em&gt;DbSet&lt;/em&gt; in a &lt;em&gt;DbContext&lt;/em&gt;, configured to connect to SQL Server:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Table(&amp;quot;Blog&amp;quot;)]
public  class Blog
{
    public int Id { get; set; }

    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime DateCreated { get; set; }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suppose we want to &lt;em&gt;select all Blogs&lt;/em&gt;, but &lt;code&gt;group them by the DateCreated&lt;/code&gt; - lets see how this can be done.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="before-ef7"&gt;Before EF7&lt;/h3&gt;
&lt;p&gt;If we try perform the &lt;em&gt;GroupBy&lt;/em&gt; as the final operation &lt;code&gt;prior to EF7&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we're not querying the actual database
// just getting the query which would be 
// generated
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

Console.WriteLine(query);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An exception is thrown!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The LINQ expression 'DbSet&amp;lt;Blog&amp;gt;().GroupBy(b =&amp;gt; b.DateCreated)' could not be translated. 
Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To perform this, the &lt;em&gt;group by&lt;/em&gt; logic would need to be done in code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();

// get all relevent blogs, ungrouped
var List&amp;lt;Blog&amp;gt; = context.Blogs.ToList();

// group the blogs by date in code
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? blogByDate = 
    blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the requirement to group by &lt;em&gt;DateCreated&lt;/em&gt; is definitely do-able, just maybe not as simple and intuitive to do as it should be.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ef7"&gt;EF7&lt;/h3&gt;
&lt;p&gt;EF7 makes implementing the same requirement a little bit easier. Upgrading to EF7, and executing the exact same code as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get an instance of the DBContext
DemoContext context = new DemoContext();

// we not querying the actual database
// just getting the query the following would
// generate
var query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToQueryString();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now yields the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;SELECT [b].[DateCreated], [b].[Id], [b].[Description], [b].[Title]
FROM [Blog] AS [b]
ORDER BY [b].[DateCreated]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;GroupBy&lt;/em&gt; is not perform on the database itself, but is again, performed in code - just this time it is done automatically by EF.&lt;/p&gt;
&lt;p&gt;The output type is the same as when the operation is performed manually:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var context = new DemoContext();
List&amp;lt;IGrouping&amp;lt;DateTime, Blog&amp;gt;&amp;gt;? query = context
    .Blogs
    .GroupBy(b =&amp;gt; b.DateCreated)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively small enhancement to EF, but one which makes building up queries in EF using LINQ more intuitive, and results in the developer having to do slightly less work overall.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/okyrylchuk/status/1595887786535575554"&gt;Oleg Kyrylchuk Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;218: 08-12-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>