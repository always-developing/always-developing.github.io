<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Tue, 15 Nov 2022 04:00:00 GMT</pubDate>
		<lastBuildDate>Tue, 15 Nov 2022 04:00:00 GMT</lastBuildDate>
		<item>
			<title>Foreach loops and indexes</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/15-foreach-index</guid>
			<pubDate>Tue, 15 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Often when iterating through a list using a &lt;code&gt;foreach&lt;/code&gt; loop, an index to the item's position in the list is also required - instead of using a separate &lt;em&gt;index variable&lt;/em&gt;, a &lt;code&gt;tuple can be used to keep track of the item and it's index&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="manually-tracking-index"&gt;Manually tracking index&lt;/h2&gt;
&lt;p&gt;Sometimes while iterating, the index of the item in the list is required - usually this is done by creating a separate variable and manually increasing it in each iteration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// variable used to keep track of the index
int loopIndex = 0;
foreach(var item in list)
{
    // access the item and the index
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {loopIndex}&amp;quot;);

    // don't forget to increase the index
    loopIndex++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, the item from the list can be accessed, as well as the index (position) of the item in the list. The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach is entirely valid, however it does require additional effort, and the developer needs to remember to increase the index variable. There is a cleaner, simpler approach (however, it &lt;em&gt;might&lt;/em&gt; come with a performance cost)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="tuple-index"&gt;Tuple index&lt;/h2&gt;
&lt;p&gt;Instead of manually creating and incrementing an index variable, this can be done automatically &lt;em&gt;with the foreach loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// list with 5 items
var list = new List&amp;lt;int&amp;gt;();
list.AddRange(Enumerable.Range(1, 5));

// instead of iterating through the list directly
// select the items of the list into a tuple, along
// with the index
foreach(var (item, index) in 
    list.Select((item, index) =&amp;gt; (item, index)))
{
    Console.WriteLine($&amp;quot;ItemValue: {item}&amp;quot;);
    Console.WriteLine($&amp;quot;index: {index}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the items in the list are select into a list of &lt;em&gt;tuples&lt;/em&gt;, each tuple containing the item itself, as well as the index. Iterating over this new list gives us access to both these values.&lt;/p&gt;
&lt;p&gt;The output is the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;ItemValue: 1
index: 0
ItemValue: 2
index: 1
ItemValue: 3
index: 2
ItemValue: 4
index: 3
ItemValue: 5
index: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cleaner, simpler and less prone to errors (forgetting to increment the index manually)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A relatively simple tip, but one which does make things easier as a developer -  however depending on the list size and the list type, could result in a performance hit. If the list is generally relatively small, the performance hit shouldn't be noticeable and the code is cleaner. But still perform benchmark and use the best solution for your use case&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidpine7/status/1584553974236971008"&gt;David Pine Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;202: 15-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>String comparison with StringComparer</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/14-string-comparison</guid>
			<pubDate>Mon, 14 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When comparing strings, instead of using &lt;code&gt;ToLower()&lt;/code&gt; (or &lt;code&gt;ToUpper&lt;/code&gt;) with the comparison operator &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;StringComparer.OrdinalIgnoreCase.Equals&lt;/code&gt; can be used, which is faster and uses less memory.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;p&gt;There are a number of different ways to compare strings in C# - this post will explore a number of these methods, as well as compare their performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="section"&gt;==&lt;/h3&gt;
&lt;p&gt;The most basic method is to use the comparison operator &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using ==&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1 == value2}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1 == value3}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using ==
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with this approach is that the &lt;em&gt;case of the string is not taken into account&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tolowertoupper"&gt;ToLower/ToUpper&lt;/h3&gt;
&lt;p&gt;An often use method, is to use the comparison operator, but to &lt;code&gt;ToUpper&lt;/code&gt; or &lt;code&gt;ToLower&lt;/code&gt; the string for comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using == and ToLower&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToLower() == value2.ToLower()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToLower() == value3.ToLower()}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

Console.WriteLine(&amp;quot;Using == and ToUpper&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.ToUpper() == value2.ToUpper()}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.ToUpper() == value3.ToUpper()}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using == and ToLower
value1 and value2: True
value1 and value3: False
-----
Using == and ToUpper
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both methods yield the same, accurate result.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="string.equals"&gt;string.Equals&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;string&lt;/code&gt; class has an &lt;code&gt;Equals&lt;/code&gt; method, which can also be used for comparison. One version is a &lt;em&gt;static method&lt;/em&gt;, and the other is an &lt;em&gt;instance method&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

// instance Equals method
Console.WriteLine(&amp;quot;Using instance Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {value1.Equals(value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {value1.Equals(value3)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);

// Static Equals method
Console.WriteLine(&amp;quot;Using static Equals&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using instance Equals
value1 and value2: False
value1 and value3: False
-----
Using static Equals
value1 and value2: False
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basic version of &lt;code&gt;Equals&lt;/code&gt; does not take the string case into account - however there is an additional parameter which can be passed to the &lt;code&gt;Equals&lt;/code&gt; method to define how the comparison is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using static Equals OrdinalIgnoreCase&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {string.Equals(value1, value2, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {string.Equals(value1, value3, 
    StringComparison.OrdinalIgnoreCase)}&amp;quot;);
Console.WriteLine(&amp;quot;-----&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using string.Equals OrdinalIgnoreCase
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="stringcomparer"&gt;StringComparer&lt;/h3&gt;
&lt;p&gt;The final method is using &lt;code&gt;StringComparer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var value1 = &amp;quot;String1&amp;quot;;
var value2 = &amp;quot;STRING1&amp;quot;;
var value3 = &amp;quot;String2&amp;quot;;

Console.WriteLine(&amp;quot;Using StringComparer&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value2: {StringComparer.OrdinalIgnoreCase.Equals(value1, value2)}&amp;quot;);
Console.WriteLine($&amp;quot;value1 and value3: {StringComparer.OrdinalIgnoreCase.Equals(value1, value3)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Using StringComparer
value1 and value2: True
value1 and value3: False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;Finally, we can benchmark all the different methods:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Median&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BasicComparison&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.972 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0392 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0348 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.974 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToLower&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.073 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.8145 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7619 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.187 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.34&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.61&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BasicToUpper&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.095 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.6650 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.7548 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;42.910 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.74&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.32&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0127&lt;/td&gt;
&lt;td style="text-align: right;"&gt;80 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringInstanceEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.903 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0465 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0388 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.912 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringStaticEquals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.896 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0272 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0227 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.899 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.96&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringEqualOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.083 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1480 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1584 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.078 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.09&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StringComparerOrdinalIgnoreCases&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.770 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0669 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0559 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.762 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.42&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, once can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In all instances where the case of the string is taken into account, performance is slower&lt;/li&gt;
&lt;li&gt;The often used &lt;code&gt;ToUpper/ToLower&lt;/code&gt; method is the slowest a large margin, and the only method to use memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringComparer&lt;/code&gt; is the most performant technique to use when a comparison needs to be done while ignoring the case&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Realistically, in most applications the performance of a string comparison is not going to have any material effect on performance. However if the application does a large number of string comparisons, the accumulative effect could be slightly noticeable and it might be worth investigating the use of &lt;code&gt;StringComparer&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/Tullo/status/1583491663577481219"&gt;&amp;#64;Tullo Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;201: 14-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>List AddRange performance</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/11-list-add-performance</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/11-list-add-performance</guid>
			<pubDate>Fri, 11 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When multiple items need to be added to a &lt;code&gt;List&lt;/code&gt;, using the &lt;code&gt;AddRange&lt;/code&gt; method is generally significantly more performant than using the &lt;code&gt;Add&lt;/code&gt; method - however, in some scenarios it might actually be slower!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;In all of the below examples, an initial List of 10, 1000 and 10000 items is used as a source and transferred transferer into another destination List.&lt;/p&gt;
&lt;h3 id="one-at-a-time"&gt;One at a time&lt;/h3&gt;
&lt;p&gt;In this benchmark, the &lt;code&gt;Add&lt;/code&gt; method is used to add items to a destination list, one at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void AllOneAtTime()
{
    var newList = new List&amp;lt;int&amp;gt;();

    foreach(var item in items)
    {
        newList.Add(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="filtered-one-at-a-time"&gt;Filtered one at a time&lt;/h3&gt;
&lt;p&gt;Here, only certain items are added to the destination list (this divisible by 2). A check is performed, and only if it passes is the specific item added to the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void FilteredOneAtTime()
{
    var newList = new List&amp;lt;int&amp;gt;();

    foreach (var item in items)
    {
        // only if divisible by 2
        if (item % 2 == 0)
        {
            newList.Add(item);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="add-range"&gt;Add range&lt;/h3&gt;
&lt;p&gt;In this benchmark, the entire source list is copied to the destination list using the &lt;code&gt;AddRange&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void AllOnce()
{
    var newList = new List&amp;lt;int&amp;gt;();

    newList.AddRange(items);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="filtered-add-range"&gt;Filtered add range&lt;/h3&gt;
&lt;p&gt;In the final benchmark, the entire source list is filtered using LINQ, and then &lt;code&gt;AddRange&lt;/code&gt; is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void FilteredOnce()
{
    var newList = new List&amp;lt;int&amp;gt;();

    newList.AddRange(items.Where(i =&amp;gt; i % 2 == 0).ToList());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;p&gt;The full results are below, but in summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AddRange&lt;/code&gt; is 2-3 times faster than using &lt;code&gt;Add&lt;/code&gt; multiple times (depending on the list size)&lt;/li&gt;
&lt;li&gt;When required to filter the list, its quicker to iterate through each item, perform the check and use &lt;code&gt;Add&lt;/code&gt;. This is in comparison to using LINQ to filter and then &lt;code&gt;AddRange&lt;/code&gt; (the bottleneck here is LINQ, not the &lt;em&gt;AddRange&lt;/em&gt; call)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="items"&gt;10 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;59.21 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.873 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.817 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0343&lt;/td&gt;
&lt;td style="text-align: right;"&gt;216 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.12 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.738 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.690 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.68&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.01&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0204&lt;/td&gt;
&lt;td style="text-align: right;"&gt;128 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;23.10 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.458 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.450 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.39&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.01&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0153&lt;/td&gt;
&lt;td style="text-align: right;"&gt;96 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;97.60 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.395 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.305 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.65&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0446&lt;/td&gt;
&lt;td style="text-align: right;"&gt;280 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3 id="items-1"&gt;1000 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,155.3 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;40.86 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;43.72 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.3390&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0229&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8.23 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,554.8 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;30.15 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;38.13 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.72&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6847&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0057&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.2 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;216.5 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.27 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.06 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6464&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0098&lt;/td&gt;
&lt;td style="text-align: right;"&gt;3.96 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2,870.1 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;36.82 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.44 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.33&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.0223&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0153&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.28 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.76&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="items-2"&gt;10000 items&lt;/h3&gt;
&lt;hr /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Error&lt;/th&gt;
&lt;th style="text-align: right;"&gt;StdDev&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;RatioSD&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AllOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;21.498 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4191 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.4659 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;20.8130&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4.1504&lt;/td&gt;
&lt;td style="text-align: right;"&gt;128.32 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOneAtTime&lt;/td&gt;
&lt;td style="text-align: right;"&gt;15.165 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1404 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.1172 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.71&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.02&lt;/td&gt;
&lt;td style="text-align: right;"&gt;10.4675&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.2817&lt;/td&gt;
&lt;td style="text-align: right;"&gt;64.3 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AllOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.127 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0408 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0382 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6.3667&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.7935&lt;/td&gt;
&lt;td style="text-align: right;"&gt;39.12 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilteredOnce&lt;/td&gt;
&lt;td style="text-align: right;"&gt;28.335 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.3079 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.2729 us&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.32&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.03&lt;/td&gt;
&lt;td style="text-align: right;"&gt;13.6414&lt;/td&gt;
&lt;td style="text-align: right;"&gt;2.2583&lt;/td&gt;
&lt;td style="text-align: right;"&gt;83.95 KB&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.65&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Generally, &lt;code&gt;AddRange&lt;/code&gt; is much quicker than multiple iterations of &lt;code&gt;Add&lt;/code&gt; - however, if using &lt;code&gt;AddRange&lt;/code&gt; in conjunction with a slower operation (such as LINQ's &lt;em&gt;where&lt;/em&gt;), then it doesn't really matter which is used, and to improve performance the bottleneck (LINQ) should be optimized.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/SY7K9/status/1580163986347405312"&gt;Sabig Gasim Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;200: 11-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Awaiting anything with GetAwaiter</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/10-awaiting-anything</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/10-awaiting-anything</guid>
			<pubDate>Thu, 10 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;All that is required to &lt;code&gt;await&lt;/code&gt; a specific type, is that the type has a method called &lt;code&gt;GetAwaiter&lt;/code&gt; which returns an instance of &lt;code&gt;TaskAwaiter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;GetAwaiter&lt;/code&gt; method can be an &lt;em&gt;extension method&lt;/em&gt; - which means &lt;code&gt;any type can be extended to be awaited&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case-double-parse"&gt;Use case: double parse&lt;/h2&gt;
&lt;p&gt;In general, the below use cases are not a recommendation or proposed best technique for solving the use case - but it's interesting to discover what is possible.&lt;/p&gt;
&lt;p&gt;In this use case, we are going to attempt to &lt;em&gt;make an async version of the double.TryParse method&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="tryparseasync"&gt;TryParseAsync&lt;/h3&gt;
&lt;p&gt;This solution doesn't require the usage of the &lt;code&gt;GetAwaiter&lt;/code&gt; method - in this first option we are just going to create a method which returns a &lt;code&gt;Task&lt;/code&gt; (and as such, the &lt;em&gt;Task&lt;/em&gt; is awaited):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// extension method on string
public static Task&amp;lt;bool&amp;gt; TryParseAsync(this string s, out double result)
{
    // perform the normal TryParse
    if(double.TryParse(s, out result))
    {
        // return a Task instead of the 
        // TryParse response
        return Task.FromResult(true);
    }
    
    // return a Task instead of the 
    // TryParse response
    return Task.FromResult(false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instead of doing it this OLD way
if(double.TryParse(&amp;quot;100&amp;quot;, out double result))
{
    Console.WriteLine(&amp;quot;100 is a double&amp;quot;);
}

// This is now possible:
// The TryParseAsync is called directly 
// on the string and can be awaited
if(await &amp;quot;100&amp;quot;.TryParseAsync(out double result1))
{
    Console.WriteLine(&amp;quot;100 is a double&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;TryParseAsync&lt;/code&gt; can be used on a string value directly, and as it returns a &lt;code&gt;Task&lt;/code&gt;, the call can be &lt;em&gt;awaited&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await-directly"&gt;await directly&lt;/h3&gt;
&lt;p&gt;However, what if there is a requirement to perform the same functionality as &lt;code&gt;TryParseAsync&lt;/code&gt;, but to &lt;em&gt;await&lt;/em&gt; the string directly - not call the &lt;code&gt;TryParseAsync&lt;/code&gt; method. Well, no problem!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static TaskAwaiter&amp;lt;bool&amp;gt; GetAwaiter(this string s)
{
    return s.TryParseAsync(out double _).GetAwaiter();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, a &lt;code&gt;GetAwaiter&lt;/code&gt; extension method is created on &lt;code&gt;string&lt;/code&gt; - by convention, this now allows &lt;code&gt;string to be awaited directly&lt;/code&gt;. In this instance, awaiting a string will try parse it as a double (using the previously created extension method).&lt;/p&gt;
&lt;p&gt;So now this can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// just await the string
if(await &amp;quot;500&amp;quot;)
{
    Console.WriteLine(&amp;quot;500 is a double&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned - this is not really a recommended approach at all - while the code is more concise, the readability is not great, with the code making no contextual sense. However, it is what can be done.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case-timespan"&gt;Use Case: TimeSpan&lt;/h2&gt;
&lt;p&gt;A more useful use case, is to &lt;em&gt;expand the functionality of TimeSpan&lt;/em&gt; to make it easier to &lt;em&gt;wait for specific lengths of time&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="delay"&gt;Delay&lt;/h3&gt;
&lt;p&gt;Generally when a delay is required in code, a variation of the following is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await Task.Delay(TimeSpan.FromMilliseconds(100));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing wrong with this, it works. However if used often throughout code, it's it fairly verbose.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await"&gt;await&lt;/h3&gt;
&lt;p&gt;As before, a &lt;code&gt;GetAwaiter&lt;/code&gt; method could be added to &lt;code&gt;TimeSpan&lt;/code&gt; to make it &lt;em&gt;awaitable&lt;/em&gt;, eliminating the need for the Task.Delay (this will still be required, it will just be wrapped up in the extension method):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// extension method on TimeSpan
public static TaskAwaiter GetAwaiter(this TimeSpan timeSpan)
{
    return Task.Delay(timeSpan).GetAwaiter();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await TimeSpan.FromMilliseconds(100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Definitely simpler and more concise than the previous version, and I'd argue actually more readable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="await-extended"&gt;await extended&lt;/h3&gt;
&lt;p&gt;This could even be taken a step further with an addition extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static TimeSpan MilliSeconds(this int i) =&amp;gt; TimeSpan.FromMilliseconds(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an extension method on an &lt;code&gt;int&lt;/code&gt;, which will convert the integer to an equivalent TimeSpan object.&lt;/p&gt;
&lt;p&gt;As we already have an existing extension method to &lt;em&gt;await&lt;/em&gt; a &lt;code&gt;TimeSpan&lt;/code&gt;, the two extensions methods can be used in conjunction - &lt;em&gt;convert an integer to a TimeSpan, which can then be awaited&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await 100.MilliSeconds();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While this is a very useful and convenient technique to add the &lt;em&gt;await&lt;/em&gt; functionality to &lt;em&gt;any class&lt;/em&gt;, it doesn't mean every class &lt;em&gt;should&lt;/em&gt; have this functionality. In the case of &lt;code&gt;TryParseAsync&lt;/code&gt;, the code was made less readable, for no real benefit. In the case of &lt;code&gt;TimeSpan&lt;/code&gt;, the &lt;em&gt;await&lt;/em&gt; extension to the class did add value to the developer.  Basically, made an informed choice to use &lt;code&gt;GetAwaiter&lt;/code&gt;, and only do so where it makes sense.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://steven-giesel.com/blogPost/5360d1c3-89f6-4a08-9ee3-6ddbe1b44236"&gt;Cursed C# - Doing shenanigans in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;199: 10-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Adding localization with dependency injection</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/09-localization-di</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/09-localization-di</guid>
			<pubDate>Wed, 09 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Localization&lt;/code&gt; is the &lt;em&gt;process of translating an application's resources into localized versions for each culture that the application will support&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Enabling this multi-culture, localization support is as easy as adding a few lines of code on application startup, and leveraging the &lt;code&gt;IStringLocalizer&lt;/code&gt; implementation when working with the variable, localized values.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-localized"&gt;Non-localized&lt;/h2&gt;
&lt;p&gt;Suppose we have an endpoint, which when called will return a string containing a random color:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.MapGet(&amp;quot;/get&amp;quot;, () =&amp;gt;
{
    var random = new Random();
    var randomValue = random.Next(3);

    var response = randomValue switch
    {
        0 =&amp;gt; &amp;quot;Blue&amp;quot;,
        1 =&amp;gt; &amp;quot;Green&amp;quot;,
        2 =&amp;gt; &amp;quot;Yellow&amp;quot;
    };

    return $&amp;quot;The color generated is: {response}&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code will generate a random number between 1 and 3, and return a string indicating the color generated.&lt;/p&gt;
&lt;p&gt;Calling the endpoint returns the following (the colour value may change with each call):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The color generated is: Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above return message the American spelling of &amp;quot;color&amp;quot; is returned, and not the British/South African spelling, &lt;em&gt;colour&lt;/em&gt;. We are going to add support for either variation, depending on the caller's culture - this is a fairly simple innocuous change, but the steps used here can be expended to add complete support for a different language.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="localized"&gt;Localized&lt;/h2&gt;
&lt;h3 id="defining-the-variations"&gt;Defining the variations&lt;/h3&gt;
&lt;p&gt;The first step is to define the various strings which will have different versions based on the culture. In our example this would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The return message&lt;/li&gt;
&lt;li&gt;The three different colours&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this specific use case these three different colour values will not change between cultures, but if the application is to support multi-culture, its a good idea to &amp;quot;localize&amp;quot; all string values.&lt;/p&gt;
&lt;p&gt;The various culture specific strings are stored in &lt;code&gt;resx files&lt;/code&gt;, which usually reside in a &lt;code&gt;Resources&lt;/code&gt; folder. These files follow the naming standard of &lt;code&gt;{Class}.{culture}.resx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this case, two files where added to the &lt;code&gt;Resources&lt;/code&gt; folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program.en-us.resx&lt;/li&gt;
&lt;li&gt;Program.en-za.resx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As we are using minimal apis, the usage of the values will be in the &lt;code&gt;Program&lt;/code&gt; class, hence the name of the resx files is &lt;em&gt;Program&lt;/em&gt;. The cultures supported in our application will be &lt;code&gt;English-Unites States&lt;/code&gt; and &lt;code&gt;English-South African&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The resx files will both contain the &lt;code&gt;same names&lt;/code&gt; (keys), but each will have the specific localized values:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Program.en-us.resx&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ColourResponseMessage&lt;/td&gt;
&lt;td&gt;The color generated is: {0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Program.en-za.resx&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;td&gt;Blue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ColourResponseMessage&lt;/td&gt;
&lt;td&gt;The colour generated is: {0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;td&gt;Green&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;td&gt;Yellow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As mentioned, in this example only the &lt;em&gt;ColourResponseMessage&lt;/em&gt; will differentiate between the two, with the slightly different spelling&lt;/p&gt;
&lt;p&gt;Now that we have the variable values defined, we begin by &lt;em&gt;adding localization support to the dependency injection container&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dependency-injection-configuration"&gt;Dependency injection configuration&lt;/h3&gt;
&lt;p&gt;During application startup, the following is added:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// add the localization support to the dependency injection container
// which includes the path to the resx files
builder.Services.AddLocalization(options =&amp;gt; options.ResourcesPath = &amp;quot;Resources&amp;quot;);

// add the cultures which will be supported
var supportedCultures = new[]
{
    new CultureInfo(&amp;quot;en-za&amp;quot;),
    new CultureInfo(&amp;quot;en-us&amp;quot;)
};
builder.Services.Configure&amp;lt;RequestLocalizationOptions&amp;gt;(options =&amp;gt; {
    options.DefaultRequestCulture = new RequestCulture(&amp;quot;en-us&amp;quot;);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we configured the DI container with the generic localization interfaces and implementations, as well as explicitly specified which cultures will be supported.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="middleware-configuration"&gt;Middleware configuration&lt;/h3&gt;
&lt;p&gt;The next step is to configure the middleware pipeline (this is defined before any of the endpoints are defined):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;app.UseRequestLocalization(app.Services
    .GetRequiredService&amp;lt;IOptions&amp;lt;RequestLocalizationOptions&amp;gt;&amp;gt;().Value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This middleware components will &lt;em&gt;automatically set culture information for requests based on information provided by the client&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Finally we are now able to take advantage of the localization capabilities and update the initial &lt;code&gt;/get&lt;/code&gt; endpoint defined above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="localized-endpoint"&gt;Localized endpoint&lt;/h3&gt;
&lt;p&gt;To leverage the localization functionality, the &lt;code&gt;IStringLocalizer&lt;/code&gt; interface and implementation is used - this is injected from the dependency injection container. Instead of the string value being hardcoded, &lt;code&gt;IStringLocalizer&lt;/code&gt; is used to lookup the culture specific string by name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// inject IStringLocalizer with the specific class
app.MapGet(&amp;quot;/get&amp;quot;, ([FromServices]IStringLocalizer&amp;lt;Program&amp;gt; localizer) =&amp;gt;
{
    var random = new Random();
    var randomValue = random.Next(3);

    // same logic as before
    var localizedResponse = randomValue switch 
    {
        // use IStringLocalizer to get the culture specific string
        // GetString also allows for arguments to be passed in and 
        // another localized string (the colour) is being passed in
        // as a parameter to format the ColourResponseMessage
        0 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Blue&amp;quot;)),
        1 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Green&amp;quot;)),
        2 =&amp;gt; localizer.GetString(&amp;quot;ColourResponseMessage&amp;quot;, localizer.GetString(&amp;quot;Yellow&amp;quot;)),
    };

    return localizedResponse.Value;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When &lt;em&gt;GetString&lt;/em&gt; is called on the &lt;em&gt;IStringLocalizer&lt;/em&gt; implementation, the current culture of the context is used - if no culture is explicitly supplied, then the default culture is used.&lt;/p&gt;
&lt;p&gt;Calling the endpoint as it stands returns the same result as before - the default culture is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The color generated is: Yellow
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="changing-culture"&gt;Changing culture&lt;/h3&gt;
&lt;p&gt;When the middleware pipeline was updated in a previous step using &lt;em&gt;UseRequestLocalization&lt;/em&gt;, it added the functionality to &lt;code&gt;change the culture based on a query string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Calling the endpoint with the culture specified &lt;code&gt;/get?culture=en-za&lt;/code&gt; now results in the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;The colour generated is: Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The strings are now culture specific! Localization support has been added to the application.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Adding localization support to an api is a relatively easy process, and only requires the steps mentioned above. For large api's, if the task seems daunting and over whelming, due to the nature of the updates, it can be done in a phased approach, one endpoint at a time, making it a bit more manageable.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/aspnetcore-localization/"&gt;Localization in ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;198: 09-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Target-type new expressions</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/08-target-type-new</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/08-target-type-new</guid>
			<pubDate>Tue, 08 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The target-type &lt;code&gt;new&lt;/code&gt; keyword can be used when declaring a new variable instance without having to specify the type, if .NET can infer the instance type (i.e. the &lt;code&gt;var&lt;/code&gt; keyword is not used).&lt;/p&gt;
&lt;p&gt;In addition, the &lt;code&gt;new keyword can also be used in other instances where .NET is able to infer the type - such as passing object instances to methods&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="instance-declaration"&gt;Instance declaration&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; keyword can be used when declaring an instance of an object, as long as .NET can infer the type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// var is used here,so the CreateRequest type
// needs to explicitly be stated so .NET knows the var type
var request = new CreateRequest(1);

// OR

// Explicitly define the type, but then just
// use the new keyword as the type can be inferred 
CreateRequest request1 = new(2);

// This is not valid. What is the type?
// var request2 = new(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above usage is however not what this post is above - there is another more interesting technique using &lt;code&gt;new&lt;/code&gt; and that is using it when passing variables to a method.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="method-invocation"&gt;Method invocation&lt;/h2&gt;
&lt;p&gt;As mentioned, this technique about to be shown is the the &lt;em&gt;new and interesting&lt;/em&gt; part of this post. The explicit usage of the type can be ignored when .NET can infer the type (as above) - so it makes sense this extends to method parameters, where the parameter type is know.&lt;/p&gt;
&lt;p&gt;Consider this &lt;em&gt;CreateEntity&lt;/em&gt; method which takes a &lt;em&gt;CreateRequest&lt;/em&gt; as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void CreateEntity(CreateRequest request)
{
    // do stuff
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The parameter type is fixed, and known by .NET, so instead of doing this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;CreateEntity(new CreateRequest(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;CreateEntity(new (4));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More concise, but not necessarily more readable.&lt;/p&gt;
&lt;p&gt;This technique can also be extended for nested parameters.&lt;/p&gt;
&lt;p&gt;Consider this absurd setup of nested parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// takes an instance of DeleteRequestOne
record DeleteRequest(DeleteRequestOne Request);
// takes an instance of DeleteRequestTwo
record DeleteRequestOne(DeleteRequestTwo Request);
// takes an instance of DeleteRequestTwo
record DeleteRequestTwo(DeleteRequestThree request);
// takes an instance of DeleteRequestFour
record DeleteRequestThree(DeleteRequestFour request);
// takes an instance of DeleteRequestTwo
record DeleteRequestFour(DeleteRequestFive request);
// takes an int value
record DeleteRequestFive(int Id);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following is possible, as all the types are known and inferred:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;DeleteEntity(new(new(new(new(new(new(6)))))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A very interesting concept, but again, not very readable at all.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;As mentioned, this is an interesting technique which does require less typing and results in more concise code - at the cost of readability. Use this technique sparingly where it makes sense.
Having said that, there are options in IDEs (in Visual Studio a the very least) to &lt;em&gt;display inline parameter hints&lt;/em&gt; which indicate the inferred types, so in the end the code is still readable, but with less typing. However this might not be available in all applications where the code is read (such as in Github or Azure DevOps code viewer).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/buhakmeh/status/1580969384696217605"&gt;Khalid Abuhakmeh Tweet&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;197: 08-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>List capacity and performance</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/07-list-capacity</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/07-list-capacity</guid>
			<pubDate>Mon, 07 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When declaring an instance of &lt;code&gt;List&lt;/code&gt;, explicitly specifying the &lt;code&gt;expected capacity can improve performance&lt;/code&gt; when adding items to the list. However, specifying the capacity incorrectly could be detrimental to performance.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;h3 id="no-capacity"&gt;No capacity&lt;/h3&gt;
&lt;p&gt;In the first example, a new &lt;code&gt;List&lt;/code&gt; is declared &lt;em&gt;without specifying a capacity&lt;/em&gt;, and then 20 items are added to the the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var list = new List&amp;lt;int&amp;gt;();

for (int i = 0; i &amp;lt; 20; i++)
{
    list.Add(i);
        Console.WriteLine($&amp;quot;List count: {list.Count} and &amp;quot; +
        $&amp;quot;the capacity is: {list.Capacity}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the output, the default capacity when not explicitly specified is &lt;code&gt;4&lt;/code&gt;, and when this capacity is reached, &lt;code&gt;the capacity is doubled&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 1 and the capacity is: 4
List count: 2 and the capacity is: 4
List count: 3 and the capacity is: 4
List count: 4 and the capacity is: 4
List count: 5 and the capacity is: 8
List count: 6 and the capacity is: 8
List count: 7 and the capacity is: 8
List count: 8 and the capacity is: 8
List count: 9 and the capacity is: 16
List count: 10 and the capacity is: 16
List count: 11 and the capacity is: 16
List count: 12 and the capacity is: 16
List count: 13 and the capacity is: 16
List count: 14 and the capacity is: 16
List count: 15 and the capacity is: 16
List count: 16 and the capacity is: 16
List count: 17 and the capacity is: 32
List count: 18 and the capacity is: 32
List count: 19 and the capacity is: 32
List count: 20 and the capacity is: 32
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="with-capacity"&gt;With capacity&lt;/h3&gt;
&lt;p&gt;To specify the capacity, the value is passed to the constructor of the &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// set the capacity to 10. Half the expected capacity
var list = new List&amp;lt;int&amp;gt;(10);

for (int i = 0; i &amp;lt; 20; i++)
{
    list.Add(i);
    Console.WriteLine($&amp;quot;List count: {list.Count} and &amp;quot; +
        $&amp;quot;the capacity is: {list.Capacity}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the output, the capacity starts at 10, and is only doubled once:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List count: 1 and the capacity is: 10
List count: 2 and the capacity is: 10
List count: 3 and the capacity is: 10
List count: 4 and the capacity is: 10
List count: 5 and the capacity is: 10
List count: 6 and the capacity is: 10
List count: 7 and the capacity is: 10
List count: 8 and the capacity is: 10
List count: 9 and the capacity is: 10
List count: 10 and the capacity is: 10
List count: 11 and the capacity is: 20
List count: 12 and the capacity is: 20
List count: 13 and the capacity is: 20
List count: 14 and the capacity is: 20
List count: 15 and the capacity is: 20
List count: 16 and the capacity is: 20
List count: 17 and the capacity is: 20
List count: 18 and the capacity is: 20
List count: 19 and the capacity is: 20
List count: 20 and the capacity is: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="benchmarks"&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;So how does specifying the capacity effect performance?&lt;/p&gt;
&lt;p&gt;In the below examples, a &lt;code&gt;List&lt;/code&gt; instance is declared, with the capacity explicitly set to varying sizes and then filled with values. The benchmarks evaluated performance when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no capacity specified&lt;/li&gt;
&lt;li&gt;the capacity was defined as exactly the expected size&lt;/li&gt;
&lt;li&gt;the capacity was defined as a half of the expected size&lt;/li&gt;
&lt;li&gt;the capacity was defined as a quarter of the expected size&lt;/li&gt;
&lt;li&gt;the capacity was defined as a tenth of the expected size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code snippets for the benchmarks were as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
[Benchmark(Baseline = true)]
public void NoCapacity()
{
    /// no capacity specified
    var list = new List&amp;lt;int&amp;gt;();

    // Iterations was either 10, 1000, or 100000
    for (int i = 0; i &amp;lt; Iterations; i++)
    {
        list.Add(i);
    }
}

[Benchmark]
public void WithExactCapacity()
{
    // here the list defined with exact capacity
    var list = new List&amp;lt;int&amp;gt;(Iterations);

    for (int i = 0; i &amp;lt; Iterations; i++)
    {
        list.Add(i);
    }
}

[Benchmark]
public void WithHalfCapacity()
{
    // for the fractional tests, Iterations
    // was divided by 2, 4 and 10 (not all shown here)
    var list = new List&amp;lt;int&amp;gt;(Iterations / 2);

    for (int i = 0; i &amp;lt; Iterations; i++)
    {
        list.Add(i);
    }
}

// other tests trimmed

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="items"&gt;10 items&lt;/h3&gt;
&lt;p&gt;Benchmarking adding 10 items to the list:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Iterations&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen2&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NoCapacity&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;51.72 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0344&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;216 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithExactCapacity&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;22.74 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0153&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;96 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.44&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithHalfCapacity&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;34.05 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.66&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0229&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;144 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.67&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithQuarterCapacity&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57.53 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.11&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0395&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;248 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithTenthCapacity&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style="text-align: right;"&gt;69.32 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.34&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0446&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;280 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Benchmarking adding 1000 items to the list:&lt;/p&gt;
&lt;h3 id="items-1"&gt;1000 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Iterations&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen2&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NoCapacity&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,714.12 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.3409&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0248&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;8424 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithExactCapacity&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,297.63 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.76&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.6447&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0095&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;4056 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithHalfCapacity&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,435.71 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.84&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.9689&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0210&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;6080 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.72&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithQuarterCapacity&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,525.41 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.89&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.1311&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0210&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;7104 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.84&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithTenthCapacity&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1,779.44 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.04&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.9989&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.0687&lt;/td&gt;
&lt;td style="text-align: right;"&gt;-&lt;/td&gt;
&lt;td style="text-align: right;"&gt;12552 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.49&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Benchmarking adding 100 000 items to the list:&lt;/p&gt;
&lt;h3 id="items-2"&gt;100 000 items&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Iterations&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Mean&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Ratio&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen0&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen1&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Gen2&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Allocated&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Alloc Ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NoCapacity&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;344,487.97 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;285.6445&lt;/td&gt;
&lt;td style="text-align: right;"&gt;285.6445&lt;/td&gt;
&lt;td style="text-align: right;"&gt;285.6445&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1049072 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithExactCapacity&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;227,840.62 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.66&lt;/td&gt;
&lt;td style="text-align: right;"&gt;124.7559&lt;/td&gt;
&lt;td style="text-align: right;"&gt;124.7559&lt;/td&gt;
&lt;td style="text-align: right;"&gt;124.7559&lt;/td&gt;
&lt;td style="text-align: right;"&gt;400098 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.38&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithHalfCapacity&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;236,859.59 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.69&lt;/td&gt;
&lt;td style="text-align: right;"&gt;181.6406&lt;/td&gt;
&lt;td style="text-align: right;"&gt;181.6406&lt;/td&gt;
&lt;td style="text-align: right;"&gt;181.6406&lt;/td&gt;
&lt;td style="text-align: right;"&gt;600141 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.57&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithQuarterCapacity&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;344,779.88 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.00&lt;/td&gt;
&lt;td style="text-align: right;"&gt;199.7070&lt;/td&gt;
&lt;td style="text-align: right;"&gt;199.7070&lt;/td&gt;
&lt;td style="text-align: right;"&gt;199.7070&lt;/td&gt;
&lt;td style="text-align: right;"&gt;700171 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;0.67&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithTenthCapacity&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style="text-align: right;"&gt;466,319.55 ns&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.37&lt;/td&gt;
&lt;td style="text-align: right;"&gt;333.0078&lt;/td&gt;
&lt;td style="text-align: right;"&gt;333.0078&lt;/td&gt;
&lt;td style="text-align: right;"&gt;333.0078&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1240264 B&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1.18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the results, one can see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In all cases, setting the list capacity to the &lt;code&gt;exact expected size is twice as fast&lt;/code&gt; as not setting a capacity&lt;/li&gt;
&lt;li&gt;In most cases, setting the list capacity &lt;code&gt;explicitly can result in significantly faster performance&lt;/code&gt; over not setting the capacity&lt;/li&gt;
&lt;li&gt;In some cases however, explicitly setting the &lt;code&gt;list capacity to a value which is too small, is slower&lt;/code&gt; than not setting a capacity at all - in the benchmarks, setting the capacity to 1/10th of the expected values&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;When instantiating a list, it can be beneficial to set the capacity to the estimated final size. Even setting it to a fraction of the final expected size can be beneficial to performance.&lt;br /&gt;
However setting the capacity to a value too small can be detrimental to performance, in which case its better to not set a capacity at all. Benchmark the specific use case, with the expected capacity and make an informed decision on how to set (or not set) the capacity.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://tomaszs2.medium.com/c-11-wants-to-be-your-friend-db4a31ed9710"&gt;What’s new in C# 11? Dev friendly features&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;196: 07-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Switch expression and string interpolation</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/04-interpolation-switch</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/04-interpolation-switch</guid>
			<pubDate>Fri, 04 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# 11 is introducing the ability to &lt;code&gt;use switch expressions inside a string interpolation expression&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This allows for more simplified code, as instead of creating a separate method to be used once-off when generating the string, all the &lt;em&gt;string building&lt;/em&gt; logic can be contained in a single place.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case"&gt;Use case&lt;/h2&gt;
&lt;p&gt;In our use case, we want to convert a numerical grade (e.g. 89%), to a string representation (&amp;quot;A&amp;quot; in this case). We also want to be able to output both of these values in a string.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="separate-expression-pre-c-11"&gt;Separate expression - pre C# 11&lt;/h3&gt;
&lt;p&gt;Prior to C# 11 it was not possible for &lt;em&gt;interpolation expressions&lt;/em&gt; to be &lt;em&gt;switch expressions&lt;/em&gt; directly - the expression had to be a separate method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// method which converts a numeric grade value
// to a string representation
public string GetGradeAsString(int grade) =&amp;gt; grade switch
{
    &amp;gt; 90 =&amp;gt; &amp;quot;A+&amp;quot;,
    &amp;gt; 80 =&amp;gt; &amp;quot;A&amp;quot;,
    &amp;gt; 70 =&amp;gt; &amp;quot;B&amp;quot;,
    &amp;gt; 60 =&amp;gt; &amp;quot;C&amp;quot;,
    &amp;gt; 50 =&amp;gt; &amp;quot;D&amp;quot;,
    &amp;gt; 40 =&amp;gt; &amp;quot;E&amp;quot;,
    _ =&amp;gt; &amp;quot;F&amp;quot;
};

var studentGrade = 89;

// using string interpolation, and calling the method defined
Console.WriteLine($&amp;quot;{studentGrade} converted to &amp;quot; +
    $&amp;quot;a string is {GetGradeAsString(studentGrade)}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is nothing wrong with this approach, and it will continue to work with C# 11 - however the &lt;em&gt;issue&lt;/em&gt; here, is that if the conversion is only ever required once (when outputting the data), a method was required to be defined.&lt;/p&gt;
&lt;p&gt;Is defining a method a big deal? No
Will it create massive overhead? No
Is there a slightly easier way in C# 11? Yes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="embedded-expression-c-11"&gt;Embedded expression - C# 11&lt;/h3&gt;
&lt;p&gt;C# 11 allows for &lt;code&gt;switch expressions to be used directly in interpolated strings&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var studentGrade = 89;

// a separate method is not required
Console.WriteLine($&amp;quot;{studentGrade} converted to a string is {
    studentGrade switch
    {
        &amp;gt; 90 =&amp;gt; &amp;quot;A+&amp;quot;,
        &amp;gt; 80 =&amp;gt; &amp;quot;A&amp;quot;,
        &amp;gt; 70 =&amp;gt; &amp;quot;B&amp;quot;,
        &amp;gt; 60 =&amp;gt; &amp;quot;C&amp;quot;,
        &amp;gt; 50 =&amp;gt; &amp;quot;D&amp;quot;,
        &amp;gt; 40 =&amp;gt; &amp;quot;E&amp;quot;,
        _ =&amp;gt; &amp;quot;F&amp;quot;
    }}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same outcome as below, just slightly more concise and contained code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;This is not a massive enhancement, but it does help reduce unnecessary ceremony (creating a method) when not required - ultimately resulting in cleaner, more concise and quicker to write code when the use case applies.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://tomaszs2.medium.com/c-11-wants-to-be-your-friend-db4a31ed9710"&gt;What’s new in C# 11? Dev friendly features&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;195: 04-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Primitive obsession and Value Records </title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/03-value-records</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/03-value-records</guid>
			<pubDate>Thu, 03 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The C# &lt;code&gt;record&lt;/code&gt; type can provide a clean, quick and easy way to overcome &lt;em&gt;primitive obsession&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Primitive obsession&lt;/em&gt;, as the name implies, is the overuse of primitive types (int, string, Guid, etc) to represent more complex business or domain concepts.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="primitive"&gt;Primitive&lt;/h2&gt;
&lt;p&gt;Let's look at an example, of a (very simplified) &lt;em&gt;Order&lt;/em&gt; entity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Order
{
    public int OrderId { get; set; }

    public decimal OrderTotal { get; set; }

    public int ItemCount { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the surface, this is all good. This will work and is probably what most developer are familiar with when it comes to entities.&lt;/p&gt;
&lt;p&gt;However, the above class structure allows for the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var order = new Order
{
    OrderId = 100,
    ItemCount = 2,
    OrderTotal = 148.95m
};

// This doesn't make sense!
order.OrderId = order.OrderId * 2;
// No!?
order.ItemCount = -10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As primitive types are used for &lt;em&gt;domain business concepts&lt;/em&gt; such as &lt;code&gt;OrderId&lt;/code&gt; or &lt;code&gt;ItemCount&lt;/code&gt;, these values can be manipulated in a which doesn't make sense in their business or domain context.&lt;/p&gt;
&lt;p&gt;Of course an option is to constantly perform validation on the &lt;em&gt;Order&lt;/em&gt; to ensure it is in a valid state - but another option is to use &lt;code&gt;Value Objects&lt;/code&gt;, which will be explored in the next section.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="value-object"&gt;Value object&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Value object&lt;/code&gt; is a simple, light-weight wrapper around the primitive type, which can also provide some validation for the internal primitive type.&lt;/p&gt;
&lt;h3 id="value-record"&gt;Value record&lt;/h3&gt;
&lt;p&gt;In the referenced article, Stephen Cleary introduces a concept called &lt;code&gt;Value Record&lt;/code&gt; - leveraging the C# &lt;code&gt;record&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; types, a simple &lt;em&gt;Value Object&lt;/em&gt; can easily be defined with one line of code.&lt;/p&gt;
&lt;p&gt;To replace the &lt;em&gt;int OrderId&lt;/em&gt; above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public readonly record struct OrderId(int Value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this technique has a number of benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;immutability&lt;/li&gt;
&lt;li&gt;equality, hash code and &lt;em&gt;ToString&lt;/em&gt; support built in&lt;/li&gt;
&lt;li&gt;value-type wrapper, with no additional memory allocated&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;Order&lt;/em&gt; entity can now be updated to use the &lt;em&gt;OrderId&lt;/em&gt; &lt;code&gt;value record&lt;/code&gt; (as well as other properties as well):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Order
{
    public OrderId OrderId { get; set; }

    public OrderTotal OrderTotal { get; set; }

    public ItemCount ItemCount { get; set; }
}


public readonly record struct OrderId(int Value);

public readonly record struct OrderTotal(decimal Value);

public readonly record struct ItemCount(int Value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var order = new Order
{
    OrderId = new OrderId(100),
    ItemCount = new ItemCount(2),
    OrderTotal = new OrderTotal(148.95m)
};

// An added benefit of records (over a class) 
// is that they can be printed as well
// The ToString() method can also be overwritten
// if required
Console.WriteLine(order.OrderId);

// ERROR - compilation error 
// this is now not possible as the 
// OrderId is immutable

// order.OrderId.Value = order.OrderId.Value * 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;OrderId { Value = 100 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;value records&lt;/code&gt; can be expanded with additional (light-weight) validation, but the &lt;em&gt;record struct&lt;/em&gt; method shown above allows for a quick, simple implementation.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A very useful as well as quick easy technique to implement - but also an technique which can be misused (as it is so easy to implement). Not all properties should be or need to be converted to a value object. However where it does make sense, the &lt;code&gt;value record&lt;/code&gt; method is a slick, minimal way to achieve this.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html"&gt;Modern C# Techniques, Part 2: Value Records&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;194: 03-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Platform specific path separator</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/11/02-directory-separator</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/11/02-directory-separator</guid>
			<pubDate>Wed, 02 Nov 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The static &lt;code&gt;Path&lt;/code&gt; class contains a number of helpful, platform specific properties (and methods) to assist when working with filenames and file paths. These include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The operating system specific directory separator character&lt;/li&gt;
&lt;li&gt;The operating system specific alternate directory separator character&lt;/li&gt;
&lt;li&gt;The operating system specific path separator character&lt;/li&gt;
&lt;li&gt;The operating system specific volume separator character&lt;/li&gt;
&lt;li&gt;The operating system specific invalid filename characters&lt;/li&gt;
&lt;li&gt;The operating system specific invalid path characters&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="code-snippet"&gt;Code snippet&lt;/h2&gt;
&lt;p&gt;A simple code snippet to demonstrate how to access the various characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// All the separator characters are available on the Path static class
Console.WriteLine($&amp;quot;DirectorySeparatorChar: '{Path.DirectorySeparatorChar}'&amp;quot;);
Console.WriteLine($&amp;quot;AltDirectorySeparatorChar: '{Path.AltDirectorySeparatorChar}'&amp;quot;);
Console.WriteLine($&amp;quot;PathSeparator: '{Path.PathSeparator}'&amp;quot;);
Console.WriteLine($&amp;quot;VolumeSeparatorChar: '{Path.VolumeSeparatorChar}'&amp;quot;);

// display all the invalid file name characters
Console.WriteLine($&amp;quot;Invalid filename chars:&amp;quot;);
foreach(var chr in Path.GetInvalidFileNameChars())
{
    Console.WriteLine($&amp;quot;   {chr}&amp;quot;);
}

// display all the invalid path characters
Console.WriteLine($&amp;quot;Invalid path chars:&amp;quot;);
foreach (var chr in Path.GetInvalidPathChars())
{
    Console.WriteLine($&amp;quot;   {chr}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="windows-output"&gt;Windows output&lt;/h3&gt;
&lt;p&gt;The output when running the above on a Windows environment - the invalid filename and invalid path characters have been trimmed as the list for Windows is fairly long:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;DirectorySeparatorChar: '\'
AltDirectorySeparatorChar: '/'
PathSeparator: ';'
VolumeSeparatorChar: ':'
Invalid filename chars:
   &amp;quot;
   &amp;lt;
   &amp;gt;
   |

   ☺
   ☻
   ♥
   ♦
   ♣
   ♠
// trimmed
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="linux-output"&gt;Linux output&lt;/h3&gt;
&lt;p&gt;Running the same code in a Linux environment yields different output - no trimming of the list here, as apparently Linux supports a larger list of characters than Windows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;DirectorySeparatorChar: '/'
AltDirectorySeparatorChar: '/'
PathSeparator: ':'
VolumeSeparatorChar: '/'
Invalid filename chars:
   ?
   /
Invalid path chars:
   ?
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Leveraging the above functionality makes building up and validating file names and file paths much easier, simpler and quicker, and should definitely be preferred over rolling out ones own path builder or filename validator.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/csharp-path-class/"&gt;Path Class in C#&lt;/a&gt;&lt;/p&gt;
&lt;?# DailyDrop ?&gt;193: 02-11-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>