<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://alwaysdeveloping.net/</link>
		<description>always learning | always growing</description>
		<copyright>Copyright © 2022</copyright>
		<pubDate>Mon, 01 Aug 2022 04:55:43 GMT</pubDate>
		<lastBuildDate>Mon, 01 Aug 2022 04:55:43 GMT</lastBuildDate>
		<item>
			<title>Readonly parameters with the in modifier</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/08/01-in-modifier</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/08/01-in-modifier</guid>
			<pubDate>Mon, 01 Aug 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; parameter modifying keyword is used to cause a parameter be passed by reference, and ensure that cannot be modified in the method.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; modifier's usage is similar to the &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; keywords, except &lt;code&gt;ref&lt;/code&gt; parameters can be modified and &lt;code&gt;out&lt;/code&gt; parameters must be modified/set, while the &lt;code&gt;in&lt;/code&gt; modifier effectively makes the parameter read-only.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="types"&gt;Types&lt;/h2&gt;
&lt;h3 id="simple-value-types"&gt;Simple value types&lt;/h3&gt;
&lt;p&gt;First lets have a look at how value types are handled in a few simple examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int originalValue = 1001;
InKeywordMethod(originalValue);

// parameter used in keyword
void InKeywordMethod(in int theValue)
{
    // this is not allowed and 
    // will not compile if uncommented
    // theValue = 999;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If uncommented, the application will not compile with the error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot assign to variable 'in int' because it is a readonly variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected based on the introduction, with the use of the &lt;code&gt;in&lt;/code&gt; keyword, the &lt;em&gt;theValue&lt;/em&gt; variable is read-only inside the scope of the method, and cannot be modified.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="structure-value-types"&gt;Structure value types&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; keyword applied to a &lt;code&gt;struct&lt;/code&gt; (a value type) parameter, yields in the same results as in the previous example with sample value types.&lt;/p&gt;
&lt;p&gt;Consider the following &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct StructOptions
{
    public int IntValue { get; set; }
    public string StringValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it's usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sOptions = new StructOptions
{
    IntValue = 759,
    StringValue = &amp;quot;StringValue&amp;quot;
};
InStructKeywordMethod(sOptions);

void InStructKeywordMethod(in StructOptions options)
{
    // this is not allowed and will not compile if uncommented
    // options.IntValue = 100;

    // this is also not allowed and will result in an error
    /*
    options = new StructOptions
    {
        IntValue = 123,
        StringValue = &amp;quot;NewStringValue!&amp;quot;
    }
    */
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The properties of the &lt;code&gt;struct&lt;/code&gt; as well as the &lt;code&gt;struct&lt;/code&gt; itself are both read-only.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="reference-types"&gt;Reference types&lt;/h3&gt;
&lt;p&gt;Reference types however operate slightly differently when used with the &lt;code&gt;in&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;We will use the same &lt;em&gt;Options&lt;/em&gt; data structure as in the previous example, however this time define it as a &lt;code&gt;class&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Options
{
    public int IntValue { get; set; }

    public string StringValue { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it's usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var options = new Options
{
    IntValue = 759,
    StringValue = &amp;quot;StringValue&amp;quot;
};

Console.WriteLine(options.IntValue);
InClassKeywordMethod(options);
Console.WriteLine(options.IntValue);

void InClassKeywordMethod(in Options options)
{
    // This is allowed!
    options.IntValue = 123;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the reference type, modifications of its properties are allowed. Running the above code does not result in any compiler errors, with the output as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;759
123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, modification of the &lt;code&gt;class&lt;/code&gt; instance (not it's properties) is &lt;strong&gt;NOT&lt;/strong&gt; allowed, and will result in a &lt;strong&gt;compiler error&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void InClassKeywordMethod(in Options options)
{
    // Cannot assign to variable 'in Options' because it is a readonly variable
    /*
    options = new Options
    {
        IntValue = 123,
        StringValue = &amp;quot;NewStringValue&amp;quot;
    };
    */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Not a modifier which will see everyday use, but interesting all the same. If using the &lt;code&gt;in&lt;/code&gt; keyword, keep in mind that reference types properties can still be modified, and consider other options to make them readonly (removing the &lt;em&gt;set&lt;/em&gt; accessor, for example)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier"&gt;in parameter modifier&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;128: 01-08-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Deconstructing a class instance into multiple variables</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/29-deconstruct-method</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/29-deconstruct-method</guid>
			<pubDate>Fri, 29 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;One or many &lt;code&gt;Deconstruct&lt;/code&gt; methods can be added to a class allowing the class properties to be deconstructed into one or more variables (depending on the &lt;code&gt;Deconstruct&lt;/code&gt; methods available). This helps created cleaner, more concise code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="non-deconstruct"&gt;Non-Deconstruct&lt;/h2&gt;
&lt;p&gt;Consider a &lt;em&gt;Song&lt;/em&gt; class, with three properties:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string SongName { get; init; }

    public string ArtistName { get; init; }

    public int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If there is a requirement to print out all the properties of a &lt;em&gt;Song&lt;/em&gt; instance, it could be done like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

Console.WriteLine($&amp;quot;The song '{song1.SongName}' by '{song1.ArtistName}' &amp;quot; +
    $&amp;quot;is {song1.LengthInSeconds} seconds long&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing especially wrong with this, but if the &lt;em&gt;Song&lt;/em&gt; class had more properties, with long names, the interpolated string could get long and unwieldy.&lt;/p&gt;
&lt;p&gt;This could be simplified by doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

var name = song1.SongName;
var artist = song1.ArtistName;
var length = song1.LengthInSeconds;

Console.WriteLine($&amp;quot;The song '{name}' by '{artist}' is {length} seconds long&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interpolated string is definitely more concise now, but thee extra variables have been defined and assigned. This would make sense if the values are being reused numerous times in the code - but if this is only used once-off, a lot of vertical space has been taken up for no real &amp;quot;value&amp;quot;.&lt;/p&gt;
&lt;p&gt;However, the &lt;code&gt;Deconstruct&lt;/code&gt; method makes this process even more concise and simpler.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="deconstruct"&gt;Deconstruct&lt;/h2&gt;
&lt;p&gt;One or many &lt;code&gt;Deconstruct&lt;/code&gt; method can be added to the &lt;em&gt;Song&lt;/em&gt; class to allow for the deconstruction of the instance into variables.&lt;/p&gt;
&lt;p&gt;A method called &lt;code&gt;Deconstruct&lt;/code&gt; is defined on the class, with one or more &lt;code&gt;out&lt;/code&gt; parameters in the method signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string SongName { get; init; }

    public string ArtistName { get; init; }

    public int LengthInSeconds { get; init; }

    // deconstruct all three properties
    public void Deconstruct(out string artist, out string name, out int length)
    {
        name = SongName;
        artist = ArtistName;
        length = LengthInSeconds;
    }

    // deconstruct into a string combination of song and artist
    // as well as the length
    public void Deconstruct(out string output, out int length)
    {
        output = $&amp;quot;'{SongName}' by {ArtistName}&amp;quot;;
        length = LengthInSeconds;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Deconstruct&lt;/code&gt; methods can now be used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

// deconstruct song1, into three variables
var (artist, name, length) = song1;
Console.WriteLine($&amp;quot;The song '{name}' by '{artist}' is {length} long&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the three variables &lt;em&gt;artist&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; are automatically defined and assigned to the &lt;code&gt;out&lt;/code&gt; parameter values of the matching corresponding &lt;code&gt;Deconstruct&lt;/code&gt; method. Definitely cleaner and more concise that previous techniques.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Deconstruct&lt;/code&gt; methods also work with the &lt;code&gt;discard&lt;/code&gt; character. In the above example there is a second &lt;code&gt;Deconstruct&lt;/code&gt; method which returns the string &lt;em&gt;output&lt;/em&gt; and the song &lt;em&gt;length&lt;/em&gt;. If only interested in the &lt;em&gt;output&lt;/em&gt; value, but not the &lt;em&gt;length&lt;/em&gt;, then the following can be done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song1 = new Song
{
    ArtistName = &amp;quot;Foo Fighters&amp;quot;,
    SongName = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};

// deconstruct song1, into only one variable
// discarding the length
var (output, _) = song1;
Console.WriteLine(output);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here no memory is allocated for the &lt;em&gt;length&lt;/em&gt; out parameter where the &lt;code&gt;discard&lt;/code&gt; is used.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;There are not too many practical use cases for the &lt;code&gt;Deconstruct&lt;/code&gt; method - but where it can be applied (in cases such as the ones described above), it will definitely assist with creating cleaner, more concise code.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct#user-defined-types"&gt;Deconstructing tuples and other types&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;127: 29-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Multiple applications - one host</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/28-multi-applications</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/28-multi-applications</guid>
			<pubDate>Thu, 28 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;Multiple applications can be executed inside a single ASPNET Core host - this effectively &lt;code&gt;allows different endpoints and functionality to be available on the same base URL, but with different ports&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I first learnt about this in  Khalid Abuhakmeh's &lt;a href="https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host"&gt;post on the subject&lt;/a&gt;, however his post dives into using the &lt;em&gt;IHostBuilder&lt;/em&gt; (the technique prior to .NET6's top level statement and minimal api model). This post explores how to achieve the same output, but with the .NET6 &lt;em&gt;WebApplicationBuilder&lt;/em&gt;, top level statements and minimal api.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="single-application"&gt;Single application&lt;/h2&gt;
&lt;p&gt;First let's look at the default host setup with a single application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Create the builder
var builder = WebApplication.CreateBuilder(args);

// create the app from the builder
var app = builder.Build();

// optionally set the port
app.Urls.Add(&amp;quot;http://*:5001&amp;quot;);

// define endpoints to expose on the port
app.MapGet(&amp;quot;/main&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the main application&amp;quot;;
});

// run the application
await app.RunAsync();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a number of steps to configuring an application for startup:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the &lt;em&gt;WebApplicationBuilder&lt;/em&gt; instance, and optionally configure the dependency injection container (not done in this example)&lt;/li&gt;
&lt;li&gt;Build the application, which returns a &lt;em&gt;WebApplication&lt;/em&gt; instance&lt;/li&gt;
&lt;li&gt;Optionally configure the port(s) the application exposes&lt;/li&gt;
&lt;li&gt;Optionally configure any endpoints to expose on the above ports&lt;/li&gt;
&lt;li&gt;Run the application&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To create multiple applications, basically these &lt;code&gt;steps need to be duplicated&lt;/code&gt;, with some slight changes.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="multiple-applications"&gt;Multiple applications&lt;/h2&gt;
&lt;h3 id="startup"&gt;Startup&lt;/h3&gt;
&lt;p&gt;In our sample, we are going to create two applications to be hosted - a &lt;em&gt;main&lt;/em&gt; application, which would expose business related endpoints, and an &lt;em&gt;admin&lt;/em&gt; application which exposes admin related endpoints. This setup is just for demo purposes - I wouldn't necessarily recommend this setup for a production application as a default.&lt;/p&gt;
&lt;p&gt;Let's start at the top and duplicate the configuration.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create the &lt;code&gt;WebApplicationBuilder instance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create the main application builder
var builder = WebApplication.CreateBuilder(args);
// create the admin application builder
var adminBuilder = WebApplication.CreateBuilder(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Build&lt;/code&gt; the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// main application
var app = builder.Build();
// admin application
var adminApp = adminBuilder.Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Configure the port(s)&lt;/code&gt; the applications each expose:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// the main application's endpoints will be exposed 
// on port 5001
app.Urls.Add(&amp;quot;http://*:5001&amp;quot;);
// the admin endpoints will be exposed 
// on port 5009
adminApp.Urls.Add(&amp;quot;http://*:5009&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure any &lt;code&gt;endpoints to be exposed&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// exposed the main application endpoints
app.MapGet(&amp;quot;/main&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the main application&amp;quot;;
});

// expose the admin endpoints
adminApp.MapGet(&amp;quot;/admin&amp;quot;, () =&amp;gt;
{
    return &amp;quot;Welcome to the admin application&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Run&lt;/code&gt; the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// as we have multiple applications running
// we execute both of them and wait for either
// to finish before shutting down the host
await Task.WhenAny(
    app.RunAsync(),
    adminApp.RunAsync()
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id="execution"&gt;Execution&lt;/h3&gt;
&lt;p&gt;Running the project/host now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Expose &lt;em&gt;main application&lt;/em&gt; functionality on port &lt;code&gt;5001&lt;/code&gt;. Browsing to &lt;code&gt;http://localhost:5001/main&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Welcome to the main application
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While trying to access the &lt;em&gt;admin&lt;/em&gt; endpoint on the &lt;code&gt;main application port 5001&lt;/code&gt; will not return any results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expose &lt;em&gt;admin&lt;/em&gt; functionality on port &lt;code&gt;5009&lt;/code&gt;. Browsing to &lt;code&gt;http://localhost:5009/admin&lt;/code&gt; will return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Welcome to the admin application
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While trying to access the &lt;em&gt;main&lt;/em&gt; endpoint on the &lt;code&gt;admin application port 5009&lt;/code&gt; will not return any results.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not something I would recommend as the default go-to method, the ability to segregate endpoints into completely separate applications can prove useful in certain use cases - such as separating business and admin functionality as demonstrated in the example or if running a multi-tenant application, another use case could to separate each tenant into their own application (and own ports).
However there are probably better ways than creating multiple applications in one host for both the above mentioned use cases - but the knowledge the this is possible, is another tool to potentially use when required.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host"&gt;Hosting Two ASP.NET Core Apps In One Host&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;126: 28-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Null forgiving operator</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/27-null-forgiving</guid>
			<pubDate>Wed, 27 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;C# contains a &lt;code&gt;unary, postfix, null-forgiving&lt;/code&gt; (or null-suppression) operator &lt;code&gt;!&lt;/code&gt;, which can be used to declare that an expression of a reference type is &lt;code&gt;not null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The null-forgiving operator is used in a nullable enabled context, has no effect at run time, and only affects the compiler's static flow analysis by changing the null state of the expression in question.&lt;/p&gt;
&lt;p&gt;Effectively, the operator informs the compiler that an expression which it has determined to be &lt;code&gt;null&lt;/code&gt;, is in fact not null and no diagnostic alert (a warning by default) needs to be raised.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="unit-testing"&gt;Unit testing&lt;/h3&gt;
&lt;p&gt;A practical use of the &lt;code&gt;!&lt;/code&gt; null-forgiving operator, is when performing unit tests.&lt;/p&gt;
&lt;p&gt;Consider the following class, which has an &lt;em&gt;Artist&lt;/em&gt; property, forced to be &lt;code&gt;non-null&lt;/code&gt; by the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Artist { get; }

    public Song(string artist)
    {
        Artist = artist ?? throw new ArgumentNullException(nameof(artist));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When unit testing the class, one would want to test all possible combinations of &lt;em&gt;Song&lt;/em&gt; instantiation - with and without a valid &lt;em&gt;artist&lt;/em&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
var exceptionSong = new Song(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue with the above, is at compile time, the compiler sees the &lt;code&gt;null&lt;/code&gt; being passed to the constructor and raises the following warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Cannot convert null literal to non-nullable reference type.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we &lt;strong&gt;want&lt;/strong&gt; to pass &lt;code&gt;null&lt;/code&gt; as part of a unit test to determine the correct behavior is seen. The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used to effectively tell the compiler, that the &lt;em&gt;&lt;code&gt;null&lt;/code&gt; expression is not null, and the compiler does not need to treat is as such&lt;/em&gt; (and thus no warning is generated)&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Instantiation to test created successfully
var song = new Song(&amp;quot;Foo Fighters&amp;quot;);

// Instantiation to test exception is thrown
// Null-forgiving operator added
var exceptionSong = new Song(null!);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="manual-check"&gt;Manual check&lt;/h3&gt;
&lt;p&gt;Another practical use of the &lt;code&gt;null-forgiving operator&lt;/code&gt;, is in situations when the compiler has &lt;code&gt;incorrectly&lt;/code&gt; determined that an expression could possibly be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consider the below method to validate an instance of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static bool IsValid(Song? song)
    =&amp;gt; song is not null &amp;amp;&amp;amp; song.Artist is not null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance 
// from a source
Song? s = GetSong();

// validate the song and output if valid
if (IsValid(s))
{
    Console.WriteLine($&amp;quot;Song by Artist `{s.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code generates the following warning on the &lt;code&gt;s.Artist&lt;/code&gt; usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Dereference of a possibly null reference.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This warning is due to the fact, that based on the data types, &lt;code&gt;s&lt;/code&gt; (of type &lt;code&gt;Song?&lt;/code&gt;) could contain a &lt;code&gt;null&lt;/code&gt; value, in which case &lt;code&gt;s.Artist&lt;/code&gt; would cause an exception. However, the &lt;code&gt;IsValid&lt;/code&gt; method is performing checks to ensure that &lt;code&gt;s.Artist can never be invoked when s is null&lt;/code&gt; - in this use case the warning is incorrect.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;null-forgiving&lt;/code&gt; operator can be used again to tell the compiler, that the &lt;em&gt;s&lt;/em&gt; expression in &lt;code&gt;s.Artist&lt;/code&gt; can be treated as never being null.&lt;/p&gt;
&lt;p&gt;Updating the code to the following, will remove the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// get a nullable Song instance
Song? s = GetSong();

if (IsValid(s))
{
    // null-forgiving operator added
    Console.WriteLine($&amp;quot;Song by Artist `{s!.Artist}` is valid&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;While not an operator for every day use for most applications, the &lt;code&gt;null-forgiving&lt;/code&gt; operator can be very useful in resolving certain inaccurate warnings. However take care when using the operator, and only implement when sure that the compiler is incorrect. While the code itself will not throw any exceptions &lt;strong&gt;because&lt;/strong&gt; of the operator usage (it's ignored at runtime), the code could throw exceptions due to the the expression in question being &lt;code&gt;null&lt;/code&gt; - which the compiler was trying to warn about (before being manually overwritten with the operator)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving"&gt;! (null-forgiving) operator&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;125: 27-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>IEnumerable's lazy evaluation</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/26-ienumerable-execution</guid>
			<pubDate>Tue, 26 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When executing a method which returns &lt;em&gt;IEnumerable&lt;/em&gt;, the method body is &lt;code&gt;not execute until the result is enumerated over&lt;/code&gt;. Invoking the method will not cause any of the method code to execute, including any code before the first &lt;code&gt;yield&lt;/code&gt; in the body - not until enumeration.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="ienumerable"&gt;IEnumerable&lt;/h2&gt;
&lt;p&gt;A quick summary of &lt;code&gt;IEnumerable&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; usage - when a method is defined to have a return type of IEnumberable&amp;lt;T&amp;gt;, it can be invoked and the results iterated over:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method in the foreach loop
foreach(var number in GetNumbers())
{
    Console.WriteLine(number);
}

public IEnumberable&amp;lt;int&amp;gt; GetNumbers()
{
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The great benefit of IEnumerable though, comes with its usage in conjunction with the &lt;code&gt;yield&lt;/code&gt; keyword - this is used inside the method to return a value and (temporarily) yield control to the calling iterator. Once the iteration body (&lt;em&gt;Console.WriteLine&lt;/em&gt; in our example) is complete, control is then returned back to the method, which is executed until the next &lt;code&gt;yield&lt;/code&gt; is encountered.&lt;/p&gt;
&lt;p&gt;The output for the above would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-evaluation"&gt;Lazy evaluation&lt;/h2&gt;
&lt;p&gt;In the above example we saw how the &lt;em&gt;GetNumbers&lt;/em&gt; method was called as part of the iterator (as part of the &lt;code&gt;foreach&lt;/code&gt;) - but it is also possible to invoke the method, and store the returned &lt;em&gt;IEnumerable&lt;/em&gt; for later execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call the GetNumbers method 
IEnumerable&amp;lt;int&amp;gt; numbers = GetNumbers();

// do more processing

// iterate over the IEnumerable&amp;lt;int&amp;gt; variable
foreach (var number in numbers)
{
    Console.WriteLine(number);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the same output as the previous example above.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="lazy-execution"&gt;Lazy execution&lt;/h2&gt;
&lt;p&gt;The interesting part about the lazy evaluation (and the reason for this post), is that when using &lt;code&gt;lazy evaluation&lt;/code&gt;, the method body is &lt;code&gt;not executed when the method is called&lt;/code&gt;, only when it's &lt;code&gt;iterated over&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Consider the following method which returns &lt;em&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/em&gt;, but before it returns a value it will log which value is being returned:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IEnumerable&amp;lt;string&amp;gt; GetStringsWithLogging()
{
    Console.WriteLine(&amp;quot;Executing iteration 1&amp;quot;);
    yield return &amp;quot;Iteration 1&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 2&amp;quot;);
    yield return &amp;quot;Iteration 2&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 3&amp;quot;);
    yield return &amp;quot;Iteration 3&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 4&amp;quot;);
    yield return &amp;quot;Iteration 4&amp;quot;;

    Console.WriteLine(&amp;quot;Executing iteration 5&amp;quot;);
    yield return &amp;quot;Iteration 5&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method is executed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine($&amp;quot;Before '{nameof(GetStringsWithLogging)}' called&amp;quot;);
var deferLogging = GetStringsWithLogging();
Console.WriteLine($&amp;quot;After '{nameof(GetStringsWithLogging)}' called&amp;quot;);

foreach (var item in deferLogging)
{
    Console.WriteLine(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of the above is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Before 'GetStringsWithLogging' called
After 'GetStringsWithLogging' called
Executing iteration 1
Iteration 1
Executing iteration 2
Iteration 2
Executing iteration 3
Iteration 3
Executing iteration 4
Iteration 4
Executing iteration 5
Iteration 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the output one can see that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is &lt;code&gt;not invoked&lt;/code&gt; when it is initially called - it is only when the &lt;em&gt;deferLogging&lt;/em&gt; variable is iterated over with the &lt;em&gt;foreach&lt;/em&gt; loop, that the body of &lt;em&gt;GetStringsWithLogging&lt;/em&gt; is executed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;My initial gut assumption with an IEnumerable method was that the body of the method in question (&lt;em&gt;GetStringsWithLogging&lt;/em&gt; here) would execute up until the first &lt;code&gt;yield&lt;/code&gt; when called, no matter if lazy or not. However working through sample examples, and understanding how the code is lowered, the deferred execution makes more sense - and I am glad my initial assumptions were incorrect.&lt;/p&gt;
&lt;p&gt;Having the ability to defer execution of the method allows for potentially long running processes which retrieve the results data (for example), to be deferred until/if actually needed (obviously all by design, I am sure) it very valuable. The &lt;em&gt;IEnumerable&lt;/em&gt; instance can be passed around between methods, and only materialized when required - instead of passing around the (potentially larger in size) materialized data, when it might not even be needed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.blog/2022/06/15/c-ienumerable-yield-return-and-lazy-evaluation/"&gt;C#: IEnumerable, yield return, and lazy evaluation&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;124: 26-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Environment specific startup Configure methods</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/25-environment-configuration</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/25-environment-configuration</guid>
			<pubDate>Mon, 25 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When using the &lt;code&gt;Startup&lt;/code&gt; class approach for application startup (vs the top level minimal api approach introduced in .NET6), instead of the normal &lt;em&gt;Configure&lt;/em&gt; method used to configure the middleware pipeline, a method can be specified &lt;code&gt;per environment&lt;/code&gt;. This environment specific &lt;em&gt;Configure&lt;/em&gt; method is automatically invoked depending on the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; environment variable value.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="startup"&gt;Startup&lt;/h2&gt;
&lt;p&gt;Prior to .NET 6, when creating an ASP.NET Core web API project, a &lt;code&gt;Program.cs&lt;/code&gt; file is created containing the &lt;em&gt;Main&lt;/em&gt; method, and a separate &lt;code&gt;Startup.cs&lt;/code&gt; file is created containing the dependency injection setup method (&lt;em&gt;ConfigureServices&lt;/em&gt;) as well as the middleware pipeline setup method &lt;strong&gt;&lt;em&gt;Configure&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The Host setup in &lt;code&gt;Program.cs&lt;/code&gt; is configured to use the &lt;em&gt;Startup&lt;/em&gt; class in &lt;code&gt;Startup.cs&lt;/code&gt; to get its configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            // Use the Startup class
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In .NET6 the default changes to contain only a &lt;code&gt;Program.cs&lt;/code&gt;, and instead of a instance of &lt;em&gt;HostBuilder&lt;/em&gt; being used, an instance of &lt;em&gt;WebApplicationBuilder&lt;/em&gt; is used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The .NET6 default can be retro-fitted to use the same approach as prior versions (Startup class), but this post is mainly focused on versions prior to .NET6.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="default-configuration"&gt;Default Configuration&lt;/h3&gt;
&lt;p&gt;By default in the &lt;code&gt;Startup.cs&lt;/code&gt; the &lt;em&gt;Configure&lt;/em&gt; method which is used to setup the middleware pipeline. This method is automatically invoked by the runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// This method gets called by the runtime. Use this method to 
// configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the pipeline needs to differ per environment, then checks, such as the one below, need to be implemented:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Check if we are running in a development environment
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the developer exception page is only configured if the application is running in &lt;em&gt;Development&lt;/em&gt; - when the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; is set to &lt;strong&gt;Development&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Using these checks is the default technique to configure the pipeline per environment - however, especially if the pipelines differ greatly per environment, these checks could become complicated and potentially confusing.&lt;/p&gt;
&lt;p&gt;An alternative technique is to setup a &lt;code&gt;configure method per environment&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="environment-configuration"&gt;Environment Configuration&lt;/h3&gt;
&lt;p EnvironmentName=""&gt;Setting up a &lt;em&gt;Configure&lt;/em&gt; method per environment is very simple - in the &lt;em&gt;Startup&lt;/em&gt; class, just create a new method called &lt;em&gt;Configure&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, the &lt;em&gt;ConfigureTest&lt;/em&gt; method will be called when running in &lt;strong&gt;Test&lt;/strong&gt;, instead of the default &lt;em&gt;Configure&lt;/em&gt; method, and the &lt;em&gt;ConfigureProduction&lt;/em&gt; method will be called when running in &lt;strong&gt;Production&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
public void ConfigureTest(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapGet(&amp;quot;/&amp;quot;, async (HttpContext ctx) =&amp;gt; 
            await ctx.Response.WriteAsync(&amp;quot;In Test environment&amp;quot;));
        endpoints.MapControllers();
    });
}

public void ConfigureProduction(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It no environment specific method could be found, then the default &lt;em&gt;Configure&lt;/em&gt; method is called.&lt;/p&gt;
&lt;p&gt;The same process can be applied to &amp;quot;non-built-in&amp;quot; environments (Development, Test, Production) - if when running locally, the &lt;strong&gt;ASPNETCORE_ENVIRONMENT&lt;/strong&gt; environment variable is set to &lt;strong&gt;LocalDevelopment&lt;/strong&gt;, for example, then the following method will be called:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Method named Configure{EnvironmentName}
 public void ConfigureLocalDevelopment(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();
    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapGet(&amp;quot;/debug&amp;quot;, async (HttpContext ctx) =&amp;gt; 
            await ctx.Response.WriteAsync(&amp;quot;Special debug information&amp;quot;));
        endpoints.MapControllers();

    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Perhaps not especially relevent if working with the latest version of .NET (6 and above), or if there is not major differences in middleware pipelines between difference environments - this is still an interesting technique available if one requires it to ensure cleaner and easier to understand code.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;123: 25-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Exploring the new required properties</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/22-require-property</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/22-require-property</guid>
			<pubDate>Fri, 22 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;As part of C#11 release later this year (2022), is a potential new keyword, &lt;code&gt;required&lt;/code&gt; (potential as it's still currently in preview and is not guaranteed to be included in the final release).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; keyword is applied to a &lt;em&gt;property&lt;/em&gt; and will force the property value to be set in the &lt;em&gt;object initializer&lt;/em&gt;. The compiler will generate an error and prevent compilation if the property is not set.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="current"&gt;Current&lt;/h2&gt;
&lt;p&gt;In our example we have a &lt;em&gt;Song&lt;/em&gt; class, which has three fields. We require that these three fields always be set, and cannot be updated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Name { get; init; }

    public string Artist { get; init; }

    public int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;init&lt;/code&gt; keyword is used to specify that the values of the properties can only be set on &lt;em&gt;initialization&lt;/em&gt; of the class, and after that they are read only. However, just doing the above &lt;code&gt;does not enforce the values be set&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following is completely valid:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    LengthInSeconds = 250
};

// Name will be NULL here.
Console.WriteLine(song.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only way with the current versions of C#, is to use a &lt;code&gt;constructor&lt;/code&gt; to enforce the property values be set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public string Name { get; init; }

    public string Artist { get; init; }

    public int LengthInSeconds { get; init; }

    // new constructor taking all three required arguments
    public Song(string name, string artist, int lengthInSeconds)
    {
        Name = name;
        Artist = artist;
        LengthInSeconds = lengthInSeconds;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the &lt;em&gt;object initializer syntax&lt;/em&gt; (the syntax in the previous initialization of &lt;em&gt;Song&lt;/em&gt;) is now invalid - the compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;There is no argument given that corresponds to the required formal parameter 'name' of 'Song.Song(string, string, int)'	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;constructor&lt;/code&gt; now needs to be used to initialize an instance of &lt;em&gt;Song&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(&amp;quot;Foo Fighters&amp;quot;, &amp;quot;Everlong&amp;quot;, 250);
Console.WriteLine(song.Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we've fulfilled our requirement - the three fields always be set, and cannot be updated? Yes! ...but....&lt;/p&gt;
&lt;p&gt;Imagine you have a class with &lt;code&gt;20 require properties&lt;/code&gt;, in conjunction with &lt;code&gt;10 optional properties&lt;/code&gt; - you'd end up with at least one constructor with at least 20 parameters. In addition, the 10 optional properties can either be set in a constructor resulting in a 30 parameter constructor, or using the &lt;em&gt;object initializer syntax&lt;/em&gt;, which forces the use of two different methods to set values when initializing a class.&lt;/p&gt;
&lt;p&gt;In the below, the optional &lt;em&gt;YearReleased&lt;/em&gt; &lt;code&gt;init&lt;/code&gt; only property has been added (but not added to the constructor):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song(&amp;quot;Foo Fighters&amp;quot;, &amp;quot;Everlong&amp;quot;, 250)
{
    YearReleased = 1997
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of this will &lt;em&gt;function&lt;/em&gt;, but it is not very intuitive or developer friendly - enter the &lt;code&gt;required&lt;/code&gt; keyword.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="required-keyword"&gt;Required keyword&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; keyword is applied to the property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Song
{
    public required string Name { get; init; }

    public required string Artist { get; init; }

    public required int LengthInSeconds { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And enforces that the property is set on object initialization.&lt;/p&gt;
&lt;p&gt;The following does &lt;strong&gt;NOT&lt;/strong&gt; compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    LengthInSeconds = 250
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generating the compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;Required member 'Song.Name' must be set in the object initializer or attribute constructor.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now there is &lt;code&gt;no need for the constructor&lt;/code&gt; as the compiler will enforce that &lt;code&gt;required&lt;/code&gt; properties are set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var song = new Song
{
    Artist = &amp;quot;Foo Fighters&amp;quot;,
    Name = &amp;quot;Everlong&amp;quot;,
    LengthInSeconds = 250
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in cleaner code, as there are no constructors with numerous arguments, and there is a single standard way in which required and optional properties can be initialized.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;I'm looking forward to this feature, and hoping that it is included in C#11. It will be interesting to explore how this can replace or mostly likely, work with the &lt;code&gt;Required&lt;/code&gt; attribute data annotation to perform the necessary checks at compile time, and not only at runtime.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=9CDgPgWF9IY"&gt;Nick Chapsas - Why I won’t need constructors anymore in C# 11&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;122: 22-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Configuration from memory with AddJsonStream</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/21-addjsonstream</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/21-addjsonstream</guid>
			<pubDate>Thu, 21 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When writing &lt;code&gt;unit test&lt;/code&gt; which require application configuration through &lt;code&gt;IConfiguration&lt;/code&gt;, the &lt;code&gt;AddJsonStream&lt;/code&gt; method can be used to load different application settings configuration from memory (instead of from an appsettings.json file).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;The setup is a fairly common pattern I've experienced when writing &lt;code&gt;shared, reusable, packaged libraries&lt;/code&gt; - a piece of functionality is packaged into a library (not shown in this post, but published to a NuGet store). This library functionality is configured and added to the dependency injection container at startup using an extension method, with the configuration options for the library (optionally) specified in the appsettings.json file.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;class library&lt;/code&gt; is created for the shared component.&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;interface&lt;/code&gt; is created as an abstraction for the logic:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IDoWork
{
    int DoSomeWork();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we also have an &lt;code&gt;options&lt;/code&gt;/settings/configuration class which contains the settings for the library:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DoWorkOptions
{
    public bool IsEnabled { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then there is the implementation of the interface, the logic for the library (incredibly simple in this demo):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DoWork : IDoWork
{
    /// &amp;lt;summary&amp;gt;
    /// Stores the configuration options
    /// &amp;lt;/summary&amp;gt;
    private readonly DoWorkOptions _options;

    /// &amp;lt;summary&amp;gt;
    /// Constructor
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;options&amp;quot;&amp;gt;The configuration options&amp;lt;/param&amp;gt;
    public DoWork(DoWorkOptions options)
    {
        _options = options;
    }

    /// &amp;lt;summary&amp;gt;
    /// Executes the functionality of the library
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;1 if enabled, 0 if disabled&amp;lt;/returns&amp;gt;
    public int DoSomeWork()
    {
        if(_options.IsEnabled)
        {
            return 1;
        }

        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally an extension method on &lt;code&gt;IServiceCollection&lt;/code&gt; to configure all the pieces with the dependency injection container:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class DoWorkExtensions
{
    /// &amp;lt;summary&amp;gt;
    /// Configure the library with the DI container
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;services&amp;quot;&amp;gt;The IServiceCollection implementation&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&amp;quot;configuration&amp;quot;&amp;gt;The IConfiguration implementation&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static IServiceCollection AddDoWork(this IServiceCollection services, 
        IConfiguration configuration)
    {
        // load the options from the configuration implementation
        var options = new DoWorkOptions();
        configuration.GetSection(&amp;quot;doWorkOptions&amp;quot;).Bind(options);

        // add the functionality to DI
        services.AddTransient(typeof(IDoWork), typeof(DoWork));
        // add the options to DI
        services.AddSingleton(options);

        return services;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To recap - we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an interface for the functionality (&lt;em&gt;IDoWork&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;with an implementation of the functionality (&lt;em&gt;DoWork&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;which is configured using options (&lt;em&gt;DoWorkOptions&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;and setup with the dependency injection container using an extension method (&lt;em&gt;DoWorkExtensions&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our very simple shared library is now &lt;code&gt;complete and ready to be used&lt;/code&gt;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="web-api"&gt;Web api&lt;/h2&gt;
&lt;p&gt;First a look at how this would be used in an &lt;code&gt;minimal web api&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the necessary references in place, the extension method can be invoked on startup, which then allows for the the &lt;em&gt;IDoWork&lt;/em&gt; interface to be injected into the endpoint handler delegate:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

// this line is not explicitly needed as its automatically done 
// if not specified here, but the configuration get loaded from the 
// appsettings.json file
builder.Configuration.AddJsonFile(&amp;quot;appsettings.json&amp;quot;);

// configured with dependency injection container
builder.Services.AddDoWork(builder.Configuration);

var app = builder.Build();

// injected IDoWork
app.MapGet(&amp;quot;/work&amp;quot;, (IDoWork worker) =&amp;gt;
{
    // execute the logic
    return worker.DoSomeWork();
});

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the appsettings.json being as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;DoWorkOptions&amp;quot;: {
    &amp;quot;IsEnabled&amp;quot; :  true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the &lt;code&gt;/work&lt;/code&gt; endpoint will return a &lt;code&gt;1 or 0&lt;/code&gt; dependant on if the &lt;em&gt;DoWorkOptions -&amp;gt; IsEnabled&lt;/em&gt; flag is set to &lt;code&gt;true or false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;So how do we unit test a piece of code which is dependant on json configuration? - with the &lt;code&gt;AddJsonStream&lt;/code&gt; method!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="unit-test"&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AddJsonStream&lt;/code&gt; is an extension method on &lt;em&gt;ConfigurationBuilder&lt;/em&gt;, which as the name implies, allows for loading of JSON configuration data from memory, instead of from file as is the the case with &lt;code&gt;AddJsonFile&lt;/code&gt; above.&lt;/p&gt;
&lt;p&gt;We can leverage this to write unit tests with different setups of configuration.&lt;/p&gt;
&lt;p&gt;A note - there are other/better ways of performing endpoint testing, &lt;code&gt;WebApplicationFactory&lt;/code&gt; for example, but these are intentionally simple and the logic is being tested directly (from the DI container), and not through an endpoint.&lt;/p&gt;
&lt;p&gt;Test when the option is &lt;em&gt;&lt;strong&gt;enabled&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TestMethod]
public void Test_Enabled_Config()
{
    // create a memory stream with the json configuration
    var sr = new MemoryStream(Encoding.ASCII.GetBytes(&amp;#64;&amp;quot;
{
&amp;quot;&amp;quot;DoWorkOptions&amp;quot;&amp;quot; : {
    &amp;quot;&amp;quot;IsEnabled&amp;quot;&amp;quot; : true
}
}&amp;quot;));

    // setup host
    var host = Host.CreateDefaultBuilder()
        .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
        {
            // load from the memory stream, and not from file
            config.AddJsonStream(sr);
        })
        .ConfigureServices((context, services) =&amp;gt; services
            .AddDoWork(context.Configuration)
        ).Build();

    // get the implementation from the DI container
    var worker = (IDoWork)host.Services.GetService(typeof(IDoWork));

    // invoke and assert the result
    Assert.AreEqual(1, worker.DoSomeWork());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test when the option is &lt;em&gt;&lt;strong&gt;disabled&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[TestMethod]
public void Test_Disabled_Config()
{
    // create a memory stream with the json configuration
    var sr = new MemoryStream(Encoding.ASCII.GetBytes(&amp;#64;&amp;quot;
{
&amp;quot;&amp;quot;DoWorkOptions&amp;quot;&amp;quot; : {
    &amp;quot;&amp;quot;IsEnabled&amp;quot;&amp;quot; : false
}
}&amp;quot;));

    // setup host
    var host = Host.CreateDefaultBuilder()
        .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
        {
            // load from the memory stream, and not from file
            config.AddJsonStream(sr);
        })
        .ConfigureServices((context, services) =&amp;gt; services
            .AddDoWork(context.Configuration)
        ).Build();

    // get the implementation from the DI container
    var worker = (IDoWork)host.Services.GetService(typeof(IDoWork));

    // invoke and assert the result
    Assert.AreEqual(0, worker.DoSomeWork());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additional tests can obviously be included for additional use cases (empty configuration file, invalid name or value in the file etc.) - and these are easy and quick to add and configure with &lt;code&gt;AddJsonStream&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AddJsonStream&lt;/code&gt; is a very useful method when writing unit tests - I'm not sure how useful it would be outside of a unit test, during the normal execution of an application, but its available if required.&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;121: 21-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>SQL wildcard characters</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/20-sql-wildcards</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/20-sql-wildcards</guid>
			<pubDate>Wed, 20 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;There are a number of SQL wildcard characters, apart from the commonly used (at least in my case) &lt;code&gt;zero or more characters, %&lt;/code&gt; wildcard. These include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; - representing a single character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - representing any single character within the brackets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; - representing any character not in the brackets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; - representing any single character in the specified range&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="table-setup"&gt;Table setup&lt;/h2&gt;
&lt;p&gt;We have a simple &lt;code&gt;Word&lt;/code&gt; table, with one column, also called &lt;code&gt;Word&lt;/code&gt;. The table is populated with 5 records:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;flout
hit
hot
hut
shout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;h3 id="single-character"&gt;Single character&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;_&lt;/code&gt; is used to represent a single character.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which start with an 'h' and end with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h_t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="single-character-array"&gt;Single character array&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;[]&lt;/code&gt; characters are used to represent any single character specified within the brackets.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which start with an 'h', have an 'o' OR 'u' as the middle letter, and which end with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To reiterate,  only a &lt;code&gt;single character&lt;/code&gt; from within the brackets is matched. For example&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'sh[ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No rows will be returned, as &lt;code&gt;shout&lt;/code&gt; is NOT a match. Only &lt;code&gt;shot&lt;/code&gt; and &lt;code&gt;shut&lt;/code&gt; would be matched.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="character-array-negation"&gt;Character array negation&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;^&lt;/code&gt; character is used, in conjunction with the characters in the brackets &lt;code&gt;[]&lt;/code&gt;, as a negation.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words which end in 'out', but NOT preceded by an 'l'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE '%[^l]out'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;shout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The negation applies to all character in the brackets.&lt;/p&gt;
&lt;p&gt;The following will select &lt;code&gt;any three letter word, which starts with an 'h', does NOT contain 'o' or 'u' as the middle letter, and ends in 't'&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[^ou]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="character-range"&gt;Character range&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;-&lt;/code&gt; character is used in conjunction with the characters in the brackets &lt;code&gt;[]&lt;/code&gt;, as a range specifier.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;three letter words starting with 'h', has any character in the alphabet between, and including, 'o' and 'u' in the middle, and ending in 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE 'h[o-u]t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hot
hut
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="multiple-characters"&gt;Multiple characters&lt;/h3&gt;
&lt;p&gt;A quick look at the more common &lt;code&gt;%&lt;/code&gt; character, which is used to represent zero or more characters.&lt;/p&gt;
&lt;p&gt;The following will select any &lt;code&gt;words starting with zero or more of any characters, followed by an 'h', followed by zero or more of any characters, and finally ending with a 't'&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * 
FROM Word
WHERE Word LIKE '%h%t'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;hit
hot
hut
shout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;Personally, I've never had any specific need or requirement for any of these wildcards, apart from &lt;code&gt;%&lt;/code&gt; -  however, they all have their place. With the knowledge of their existence, one is at least equipped to determine if any can add any value with each specific use case or requirement.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.w3schools.com/sql/sql_wildcards.asp"&gt;SQL Wildcard Characters&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;120: 20-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>nameof usage for better code quality</title>
			<link>https://alwaysdeveloping.net/dailydrop/2022/07/19-nameof-constants</link>
			<description>always learning | always growing</description>
			<guid>https://alwaysdeveloping.net/dailydrop/2022/07/19-nameof-constants</guid>
			<pubDate>Tue, 19 Jul 2022 01:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="daily-knowledge-drop"&gt;Daily Knowledge Drop&lt;/h2&gt;
&lt;p&gt;When defining string with constants (in particular, but other situations also apply) the &lt;code&gt;nameof operator&lt;/code&gt; can be leveraged to remove explicitly set values, ensuring more consistent, cleaner and less error prone code is produced.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="nameof-expression"&gt;nameof expression&lt;/h2&gt;
&lt;p&gt;So briefly, what does &lt;code&gt;nameof&lt;/code&gt; do? - it &lt;em&gt;produces the name of a variable type, or member as the string constant&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var fibonacci = new List&amp;lt;int&amp;gt; { 0, 1, 1, 2, 3, 5 } ;
Console.WriteLine(nameof(List&amp;lt;int&amp;gt;));  // outputs the type
Console.WriteLine(nameof(fibonacci)); // outputs the variable name
Console.WriteLine(nameof(fibonacci.Count)); // outputs the method name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-terminal"&gt;List
fibonacci
Count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So let's see how we can leverage &lt;code&gt;nameof&lt;/code&gt; in the following use cases.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="constants"&gt;Constants&lt;/h2&gt;
&lt;h3 id="issue"&gt;Issue&lt;/h3&gt;
&lt;p&gt;Suppose our application has a list of &lt;em&gt;system statuses&lt;/em&gt; stored as &lt;code&gt;string constants&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = &amp;quot;Starting&amp;quot;;
    public const string Running = &amp;quot;Running&amp;quot;;
    public const string ShuttingDown = &amp;quot;ShuttingDown&amp;quot;;
    public const string Offline = &amp;quot;Offline&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the usage and output being:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(SystemStatus.ShuttingDown); // outputs &amp;quot;ShuttingDown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is there anything &lt;code&gt;inherently wrong&lt;/code&gt; with this approach? Not really, it still functions as expected.&lt;/p&gt;
&lt;p&gt;However, suppose we need to &lt;code&gt;change the &amp;quot;ShuttingDown&amp;quot; status to &amp;quot;Terminating&amp;quot;&lt;/code&gt;. Navigating to one of the usages of &lt;em&gt;SystemStatus.ShuttingDown&lt;/em&gt;, we rename the &lt;code&gt;const&lt;/code&gt; (using F2 &lt;em&gt;Rename&lt;/em&gt;, for example).&lt;/p&gt;
&lt;p&gt;We now have this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(SystemStatus.Terminating); // still outputs &amp;quot;ShuttingDown&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However the output is still &lt;code&gt;&amp;quot;ShuttingDown&amp;quot;&lt;/code&gt;, even though the &lt;code&gt;const&lt;/code&gt; name has been changed to &lt;em&gt;Terminating&lt;/em&gt;! We now either have &lt;code&gt;misleading code at best or a bug at worst.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="resolution"&gt;Resolution&lt;/h3&gt;
&lt;p&gt;As this post implies, the solution is to use the &lt;code&gt;nameof&lt;/code&gt; operator instead of a hard-coded string!&lt;/p&gt;
&lt;p&gt;Replacing the string values, with &lt;code&gt;nameof&lt;/code&gt; referencing the same variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = nameof(Starting);
    public const string Running = nameof(Running);
    public const string ShuttingDown = nameof(ShuttingDown);
    public const string Offline = nameof(Offline);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This for example will set the value of the &lt;em&gt;Starting&lt;/em&gt; constants to the name of the constant, &amp;quot;Starting&amp;quot;.&lt;/p&gt;
&lt;p&gt;Now when renaming one of the &lt;code&gt;const&lt;/code&gt; names, it's value will be kept consistent - the same as the &lt;code&gt;const&lt;/code&gt; name. If manually renaming one of the &lt;code&gt;const&lt;/code&gt; names, but forgetting to rename its usage in &lt;code&gt;nameof&lt;/code&gt; will result in a compiler error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class SystemStatus
{
    public const string Starting = nameof(Starting);
    public const string Running = nameof(Running);
    // Compiler error &amp;quot;ShuttingDown&amp;quot; does not exist
    public const string Terminating = nameof(ShuttingDown);
    public const string Offline = nameof(Offline);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result - cleaner, more consistent and less error prone code!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="parameters"&gt;Parameters&lt;/h2&gt;
&lt;h3 id="issue-1"&gt;Issue&lt;/h3&gt;
&lt;p&gt;A similar issue can be experience in instances where a &lt;code&gt;parameter name is used&lt;/code&gt;, in an exception message, for example.&lt;/p&gt;
&lt;p&gt;If we have this method, with the parameter name hardcoded in the exception string message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int div)
{
    if(div == 0)
    {
        // string value is hardcoded with the parameter name
        throw new ArgumentException($&amp;quot;Parameter 'div' cannot be zero&amp;quot;);
    }

    return dividend / div;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We realize the &lt;code&gt;div&lt;/code&gt; parameter is not a good parameter name, and should be renamed to &lt;code&gt;divisor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int divisor)
{
    if(divisor == 0)
    {
        // string value is hardcoded with the INCORRECT parameter name
        throw new ArgumentException($&amp;quot;Parameter 'div' cannot be zero&amp;quot;);
    }

    return dividend / divisor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Its very easy to miss the hardcoded string when refactoring, especially if using an IDE rename feature, which won't automatically rename the hand-coded parameter name within the string.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="resolution-1"&gt;Resolution&lt;/h3&gt;
&lt;p&gt;Again, the remedy is to use the &lt;code&gt;nameof&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public int Division(int dividend, int divisor)
{
    if (divisor == 0)
    {
        throw new ArgumentException($&amp;quot;Parameter '{nameof(divisor)}' cannot be zero&amp;quot;);
    }

    return dividend / divisor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if renaming the parameter name, the exception message is automatically updated as well (or will throw a compiler error if not all usages of the parameter are not updated):&lt;/p&gt;
&lt;p&gt;The result - cleaner, more consistent and less error prone code!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;A small, simple technique to incorporate into daily coding, which may not have any obvious immediate benefit - but if/when it comes time to do any refactoring, will definitely save time and effort due to its cleaner, more consistent approach.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.reddit.com/r/csharp/comments/v81c13/can_anyone_tell_me_the_point_of_this_syntax_im/"&gt;Reddit CSharp post&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;?# DailyDrop ?&gt;119: 19-07-2022&lt;?#/ DailyDrop ?&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>