<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DailyDrop on Always Developing</title><link>https://always-developing.github.io/categories/dailydrop/</link><description>Recent content in DailyDrop on Always Developing</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Tue, 15 Feb 2022 01:00:00 +0200</lastBuildDate><atom:link href="https://always-developing.github.io/categories/dailydrop/index.xml" rel="self" type="application/rss+xml"/><item><title>Aliases with global using directives</title><link>https://always-developing.github.io/dailydrop/2022/02/15-global-using-directives/</link><pubDate>Tue, 15 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/15-global-using-directives/</guid><description>Daily Knowledge Drop With the introduction of global usings in C#10, it is now also possible to defined a global alias to have a shortcut to a specific type, across an entire project.
Global usings A quick intro to global usings - In C#10 the concept of global usings was introduced. It allows for a using statement to be prefixed with global, which then includes that using in all files automatically when compiled.</description></item><item><title>Filtering try-catch statement</title><link>https://always-developing.github.io/dailydrop/2022/02/14-exceptions-when/</link><pubDate>Mon, 14 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/14-exceptions-when/</guid><description>Daily Knowledge Drop It is possible to filter the catch portion of the try-catch statement, as well as catch multiple exceptions at the same time using the C# when keyword.
Multiple exceptions In our use case, there are two exception types we are particularly interested in IndexOutOfRangeException and DivideByZeroException.
If either of these exceptions occur, we want to log the exception, and carry on with the workflow. However if any other exception occurs, it should be logged and re-thrown to be handled higher up the call stack.</description></item><item><title>Extract calling method metadata with C#</title><link>https://always-developing.github.io/dailydrop/2022/02/11-caller-metadata/</link><pubDate>Fri, 11 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/11-caller-metadata/</guid><description>Daily Knowledge Drop As part of the C# System.Runtime assembly, there are a number of Attributes which can be used to get information about the caller of a method.
The pattern for usage is the same for all attributes. To extract the metadata when a method is called, the following needs to be done:
A new parameter needs to be added to the method (the type of the parameter depends on the attribute, see examples below) The new parameter must have a default value The new parameter must be decorated with the relevant Attribute Attributes Lets look at a few examples.</description></item><item><title>C# Channels - Produce &amp; Consume data</title><link>https://always-developing.github.io/dailydrop/2022/02/10-channels/</link><pubDate>Thu, 10 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/10-channels/</guid><description>Daily Knowledge Drop Today we dive into a little-known C# feature, I&amp;rsquo;d previously never heard about called Channels.
So what is a channel? - In short, a channel is a feature which allows for passing of data between a producer and consumer(s). It is an efficient, thread-safe queuing mechanism.
Usage The examples set out below are very simple, and do not reflect a real world scenario. They have eben kept as minimal as possible to display the core concepts of the Channel.</description></item><item><title>Performant logging with LoggerMessageAttribute</title><link>https://always-developing.github.io/dailydrop/2022/02/09-logger-message-attribute/</link><pubDate>Wed, 09 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/09-logger-message-attribute/</guid><description>Daily Knowledge Drop .NET6 introduced a new attribute called LoggerMessageAttribute, which leverages source generators and is designed to deliver a highly useable and performant logging solution.
It works by using source generators, triggered at compile time by the presence of LoggerMessageAttribute to generate the additional source code. This solution, due to the compile time generation, is able to eliminate performance hits, such as boxing, temporary memory allocation as well as copies which enables it to be typically considerably faster than the existing run time logging methods.</description></item><item><title>Scheduling with GitHub Actions</title><link>https://always-developing.github.io/dailydrop/2022/02/08-github-action-schedule/</link><pubDate>Tue, 08 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/08-github-action-schedule/</guid><description>Daily Knowledge Drop A GitHub Action can be configured to executed on a set schedule, and it&amp;rsquo;s as simple as adding a line to the workflow YAML using Cron syntax.
As part of the development of this blog, there was a requirement to execute an Action on a schedule - which turned out to be easier than anticipated.
Cron Quick intro to Cron syntax - if you are already familiar with this you can jump straight to how to implement in workflow YAML</description></item><item><title>C# ValueTuple</title><link>https://always-developing.github.io/dailydrop/2022/02/07-valuetuple/</link><pubDate>Mon, 07 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/07-valuetuple/</guid><description>Daily Knowledge Drop You may have heard of C# the Tuple type, but there is also a ValueTuple type available, which has existed in C# since .NET 4.7!
The post will will take a brief look at the Tuple type and compare its functionality to that of the ValueTuple type.
Tuple Tuple usage A Tuple is a data structure which has a specific number and sequence of elements. The data structure can contain up to 8 elements, but if more are required, nested tuple objects can be leveraged in the 8th element to extent the number of elements.</description></item><item><title>EF Core 6: GroupBy enhancements</title><link>https://always-developing.github.io/dailydrop/2022/02/04-ef-core6-groupby/</link><pubDate>Fri, 04 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/04-ef-core6-groupby/</guid><description>Daily Knowledge Drop The GroupBy support in Entity Framework Core 6 got an update, and has made things a lot easier.
In short, the following is now supported:
Translate GroupBy followed by FirstOrDefault (or similar) over a group Supports selecting the top N results from a group Expands navigation&amp;rsquo;s after the GroupBy operator has been applied Examples Setup In all the example below the setup is very simple - a single Song entity and corresponding database table.</description></item><item><title>Use IOptions&lt;> for application configuration</title><link>https://always-developing.github.io/dailydrop/2022/02/03-ioptions/</link><pubDate>Thu, 03 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/03-ioptions/</guid><description>Daily Knowledge Drop Instead of trying to manually setup the dependency injection container with configuration from the, for example, appsettings.json file, use the built in .NET functionality and use the IOptions interface instead - and get IOptionsSnapshot and IOptionsMonitor for free!
This post won&amp;rsquo;t go into details around the options pattern specifically, but it&amp;rsquo;s the recommended approach when dealing with application settings as it enables the application to adhere to two important software architecture principles:</description></item><item><title>C# Records - the rundown</title><link>https://always-developing.github.io/dailydrop/2022/02/02-record-intro/</link><pubDate>Wed, 02 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/02-record-intro/</guid><description>Daily Knowledge Drop Heard about the new feature of C# called records, but not entirely sure whats its all about? Here&amp;rsquo;s the brief overview.
Records:
Are reference types - just like normal classes Have equality based on value and not memory - unlike normal classes Are immutable (sometimes) - unlike normal classes Can be inherited - just like normal classes Internally the compiler converts will convert a record declaration to a specialized class, so that it conforms to the above.</description></item><item><title>Use the ILogger IsEnabled method</title><link>https://always-developing.github.io/dailydrop/2022/02/01-ilogger-isenabled/</link><pubDate>Tue, 01 Feb 2022 01:00:00 +0200</pubDate><guid>https://always-developing.github.io/dailydrop/2022/02/01-ilogger-isenabled/</guid><description>Daily Knowledge Drop When performing logging using the ILogger interface, to have more effective memory usage, ensure to check if logging is enabled for the relevant log level before calling the log method.
For example:
❌ Don&amp;rsquo;t do this: 1 logger.LogWarning(&amp;#34;Value is outside expected range of &amp;#39;{0}&amp;#39; to &amp;#39;{1}&amp;#39;&amp;#34;, 100, 120);
✅ Do this: 1 2 3 4 if(logger.IsEnabled(LogLevel.Warning)) { logger.LogWarning(&amp;#34;Value is outside expected range of &amp;#39;{0}&amp;#39; to &amp;#39;{1}&amp;#39;&amp;#34;, 100, 120); }</description></item></channel></rss>